<html>
<head>
    <script type="text/javascript" src="Test/Builder.js"></script>
    <script type="text/javascript" src="Test/More.js"></script>
    <script type="text/javascript" src="../MochiKit/Base.js"></script>
</head>
<body>

<pre id="test">
<script type="text/javascript">
try {
        
    // Counting the number of tests is really lame
    plan({'tests': 80});
   
    // test bind
    var not_self = {"toString": function () { return "not self"; } };
    var self = {"toString": function () { return "self" } };
    var func = function (arg) { return this.toString() + " " + arg; };
    var boundFunc = bind(func, self);
    not_self.boundFunc = boundFunc;

    is( boundFunc("foo"), "self foo", "boundFunc bound to self properly" );
    is( not_self.boundFunc("foo"), "self foo", "boundFunc bound to self on another obj" );
    is( bind(boundFunc, not_self)("foo"), "not self foo", "boundFunc successfully rebound!" );

    // test bindMethods

    var O = function (value) {
        bindMethods(this);
        this.value = value;
    };
    O.prototype.func = function () {
        return this.value;
    };

    var o = new O("boring");
    var p = {};
    p.func = o.func;
    var func = o.func;
    is( o.func(), "boring", "bindMethods doesn't break shit" );
    is( p.func(), "boring", "bindMethods works on other objects" );
    is( func(), "boring", "bindMethods works on functions" );
    
    // test boring boolean funcs

    is( isCallable(isCallable), true, "isCallable returns true on itself" );
    is( isCallable(1), false, "isCallable returns false on numbers" );

    is( isUndefined(null), false, "null is not undefined" );
    is( isUndefined(""), false, "empty string is not undefined" );
    is( isUndefined(undefined), true, "undefined is undefined" );
    is( isUndefined({}.foo), true, "missing property is undefined" );

    is( isUndefinedOrNull(null), true, "null is undefined or null" );
    is( isUndefinedOrNull(""), false, "empty string is not undefined or null" );
    is( isUndefinedOrNull(undefined), true, "undefined is undefined or null" );
    is( isUndefinedOrNull({}.foo), true, "missing property is undefined or null" );

    // test extension of arrays
    var a = [];
    var b = [];
    var three = [1, 2, 3];

    extend(a, three, 1);
    ok( objEqual(a, [2, 3]), "extend to an empty array" );
    extend(a, three, 1)
    ok( objEqual(a, [2, 3, 2, 3]), "extend to a non-empty array" );

    extend(b, three);
    ok( objEqual(b, three), "extend of an empty array" );

    is( compare(1, 2), -1, "numbers compare lt" );
    is( compare(2, 1), 1, "numbers compare gt" );
    is( compare(1, 1), 0, "numbers compare eq" );
    is( compare([1], [1]), 0, "arrays compare eq" );
    is( compare([1], [1, 2]), -1, "arrays compare lt (length)" );
    is( compare([1, 2], [2, 1]), -1, "arrays compare lt (contents)" );
    is( compare([1, 2], [1]), 1, "arrays compare gt (length)" );
    is( compare([2, 1], [1, 1]), 1, "arrays compare gt (contents)" );
    
    // test partial application
    var a = [];
    var func = function (a, b) { return this.value + a + b; };
    var self = {"value": 1, "func": func};
    is( self.func(2, 3), 6, "setup for test is correct" );
    self.funcTwo = partial(self.func, 2);
    is( self.funcTwo(3), 6, "partial application works" );
    
    // nodeWalk test
    // ... looks a lot like a DOM tree on purpose
    var tree = {
        "id": "nodeWalkTestTree",
        "test:int": "1",
        "childNodes": [
            {
                "test:int": "2",
                "childNodes": [
                    {"test:int": "5"},
                    "ignored string",
                    {"ignored": "object"},
                    ["ignored", "list"],
                    {
                        "test:skipchildren": "1",
                        "childNodes": [{"test:int": 6}]
                    }
                ]
            },
            {"test:int": "3"},
            {"test:int": "4"}
        ]
    }

    var visitedNodes = [];
    nodeWalk(tree, function (node) {
        var attr = node["test:int"];
        if (attr) {
            visitedNodes.push(attr);
        }
        if (node["test:skipchildren"]) {
                return;
        }
        return node.childNodes;
    });

    ok( objEqual(visitedNodes, ["1", "2", "3", "4", "5"]), "nodeWalk looks like it works");
    
    // test map
    var minusOne = function (x) { return x - 1; };
    var res = map(minusOne, [1, 2, 3]);
    ok( objEqual(res, [0, 1, 2]), "map works" );

    var res2 = xmap(minusOne, 1, 2, 3);
    ok( objEqual(res2, res), "xmap works" );

    res = map(operator.add, [1, 2, 3], [2, 4, 6]);
    ok( objEqual(res, [3, 6, 9]), "map(fn, p, q) works" );

    res = map(operator.add, [1, 2, 3], [2, 4, 6, 8]);
    ok( objEqual(res, [3, 6, 9]), "map(fn, p, q) works (q long)" );

    res = map(operator.add, [1, 2, 3, 4], [2, 4, 6]);
    ok( objEqual(res, [3, 6, 9]), "map(fn, p, q) works (p long)" );

    res = map(null, [1, 2, 3], [2, 4, 6]);
    ok( objEqual(res, [[1, 2], [2, 4], [3, 6]]), "map(null, p, q) works" );

    res = zip([1, 2, 3], [2, 4, 6]);
    ok( objEqual(res, [[1, 2], [2, 4], [3, 6]]), "zip(p, q) works" );

    res = map(null, [1, 2, 3]);
    ok( objEqual(res, [1, 2, 3]), "map(null, lst) works" );


    
    
    is( isNotEmpty("foo"), true, "3 char string is not empty" );
    is( isNotEmpty(""), false, "0 char string is empty" );
    is( isNotEmpty([1, 2, 3]), true, "3 element list is not empty" );
    is( isNotEmpty([]), false, "0 element list is empty" );

    // test filter
    var greaterThanOne = function (x) { return x > 1; };
    var res = filter(greaterThanOne, [-1, 0, 1, 2, 3]);
    ok( objEqual(res, [2, 3]), "filter works" );
    var res2 = xfilter(greaterThanOne, -1, 0, 1, 2, 3);
    ok( objEqual(res2, res), "xfilter works" );
 
    is(objMax(1, 2, 9, 12, 42, -16, 16), 42, "objMax works (with numbers)");
    is(objMin(1, 2, 9, 12, 42, -16, 16), -16, "objMin works (with numbers)");
    
    // test adapter registry

    var R = new AdapterRegistry();
    R.register("callable", isCallable, function () { return "callable"; });
    R.register("arrayLike", isArrayLike, function () { return "arrayLike"; });
    is( R.match(function () {}), "callable", "registry found callable" );
    is( R.match([]), "arrayLike", "registry found ArrayLike" );
    try {
        R.match(null);
        ok( false, "non-matching didn't raise!" );
    } catch (e) {
        is( e, NotFound, "non-matching raised correctly" );
    }
    R.register("undefinedOrNull", isUndefinedOrNull, function () { return "undefinedOrNull" });
    R.register("undefined", isUndefined, function () { return "undefined" });
    is( R.match(undefined), "undefinedOrNull", "priorities are as documented" );
    ok( R.unregister("undefinedOrNull"), "removed adapter" );
    is( R.match(undefined), "undefined", "adapter was removed" );
    R.register("undefinedOrNull", isUndefinedOrNull, function () { return "undefinedOrNull" }, true);
    is( R.match(undefined), "undefinedOrNull", "override works" );
    
    var a1 = {"a": 1, "b": 2, "c": 2};
    var a2 = {"a": 2, "b": 1, "c": 2};
    is( keyComparator("a")(a1, a2), -1, "keyComparator 1 lt" );
    is( keyComparator("c")(a1, a2), 0, "keyComparator 1 eq" );
    is( keyComparator("c", "b")(a1, a2), 1, "keyComparator 2 eq gt" );
    is( keyComparator("c", "a")(a1, a2), -1, "keyComparator 2 eq lt" );
    is( reverseKeyComparator("a")(a1, a2), 1, "reverseKeyComparator" );
    is( compare(concat([1], [2], [3]), [1, 2, 3]), 0, "concat" );
    is( repr("foo"), '"foo"', "string repr" );
    is( repr(1), '1', "number repr" );
    is( listMin([1, 3, 5, 3, -1]), -1, "listMin" );
    is( objMin(1, 3, 5, 3, -1), -1, "objMin" );
    is( listMax([1, 3, 5, 3, -1]), 5, "listMax" );
    is( objMax(1, 3, 5, 3, -1), 5, "objMax" );

    is( compare(keys(a1), ["a", "b", "c"]), 0, "keys" );
    is( compare(items(a1), [["a", 1], ["b", 2], ["c", 2]]), 0, "items" );

    var StringMap = function() {};
    a = new StringMap();
    a.foo = "bar";
    b = new StringMap();
    b.foo = "bar";
    try {
        compare(a, b);
        ok( false, "bad comparison registered!?" );
    } catch (e) {
        ok( e instanceof TypeError, "bad comparison raised TypeError" );
    }

    is( repr(a), "[object Object]", "default repr for StringMap" );
    var isStringMap = function () {
        for (var i = 0; i < arguments.length; i++) {
            if (!(arguments[i] instanceof StringMap)) {
                return false;
            }
        }
        return true;
    };

    registerRepr("stringMap",
        isStringMap,
        function (obj) {
            return "StringMap(" + repr(items(obj)) + ")";
        }
    );

    is( repr(a), 'StringMap([["foo", "bar"]])', "repr worked" );

    // not public API
    _REPRS.unregister("stringMap");
    
    is( repr(a), "[object Object]", "default repr for StringMap" );

    registerComparator("stringMap",
        isStringMap,
        function (a, b) {
            // no sorted(...) in base
            a = items(a);
            b = items(b);
            a.sort(compare);
            b.sort(compare);
            return compare(a, b);
        }
    );

    is( compare(a, b), 0, "registerComparator" );

    update(a, {"foo": "bar"}, {"wibble": "baz"})
    is( a.foo, "bar", "update worked (first obj)" );
    is( a.wibble, "baz", "update worked (second obj)" );

    is( compare(a, b), 1, "update worked (comparison)" );

    setdefault(a, {"foo": "unf"}, {"bar": "web taco"} );
    is( a.foo, "bar", "setdefault worked (skipped existing)" );
    is( a.bar, "web taco", "setdefault worked (set non-existing)" );

    var c = merge({"foo": "bar"}, {"wibble": "baz"});
    is( compare(items(c), [["foo", "bar"], ["wibble", "baz"]]), 0, "merge worked" );
    
    // not public API
    _COMPARATORS.unregister("stringMap");
    
    try {
        compare(a, b);
        ok( false, "bad comparison registered!?" );
    } catch (e) {
        ok( e instanceof TypeError, "bad comparison raised TypeError" );
    }
    
    
    // Done!

    ok( true, "test suite finished!");
    
} catch (err) {
    
    var s = "test suite failure!\n";
    var o = {};
    var k = null;
    for (k in err) {
        // ensure unique keys?!
        if (!o[k]) {
            s +=  k + ": " + err[k] + "\n";
            o[k] = err[k];
        }
    }
    ok ( false, s );

}
</script>
</pre>
</body>
</html>
