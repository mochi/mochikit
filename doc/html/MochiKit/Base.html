<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.7: http://docutils.sourceforge.net/" />
<title>MochiKit.Base - functional programming and useful comparisons</title>

<link rel="stylesheet" href="../../../include/css/documentation.css" type="text/css" />
<script type="text/javascript" src="../../../packed/MochiKit/MochiKit.js"></script>
<script type="text/javascript" src="../../js/toc.js"></script>
</head>
<body>
<a href="https://mochi.github.io/mochikit"><img id="mainlink" src="../../../include/img/g_logo_doc.gif" alt="MochiKit" /></a>
<a class='indexlink' href='index.html'>Back to docs index</a>
<div class="document">
<div class="section" id="name">
<h1>Name</h1>
<p>MochiKit.Base - functional programming and useful comparisons</p>
</div>
<div class="section" id="synopsis">
<h1>Synopsis</h1>
<pre class="literal-block">
myObjectRepr = function () {
    // gives a nice, stable string representation for objects,
    // ignoring any methods
    var keyValuePairs = [];
    for (var k in this) {
        var v = this[k];
        if (typeof(v) != 'function') {
            keyValuePairs.push([k, v]);
        }
    };
    keyValuePairs.sort(compare);
    return &quot;{&quot; + map(
        function (pair) {
            return map(repr, pair).join(&quot;:&quot;);
        },
        keyValuePairs
    ).join(&quot;, &quot;) + &quot;}&quot;;
};

// repr() will look for objects that have a repr method
myObjectArray = [
    {&quot;a&quot;: 3, &quot;b&quot;: 2, &quot;repr&quot;: myObjectRepr},
    {&quot;a&quot;: 1, &quot;b&quot;: 2, &quot;repr&quot;: myObjectRepr}
];

// sort it by the &quot;a&quot; property, check to see if it matches
myObjectArray.sort(keyComparator(&quot;a&quot;));
expectedRepr = '[{&quot;a&quot;: 1, &quot;b&quot;: 2}, {&quot;a&quot;: 3, &quot;b&quot;: 2}]';
assert( repr(myObjectArray) == expectedRepr );

// get just the &quot;a&quot; values out into an array
sortedAValues = map(itemgetter(&quot;a&quot;), myObjectArray);
assert( compare(sortedAValues, [1, 3]) == 0 );

// serialize an array as JSON, unserialize it, expect something equivalent
myArray = [1, 2, &quot;3&quot;, null, undefined];
assert( objEqual(evalJSON(serializeJSON(myArray)), myArray) );
</pre>
</div>
<div class="section" id="description">
<h1>Description</h1>
<p><a class="mochiref reference external" href="Base.html">MochiKit.Base</a> is the foundation for the MochiKit suite.
It provides:</p>
<ul class="simple">
<li>An extensible comparison facility
(<a class="mochiref reference external" href="#fn-compare">compare</a>, <a class="mochiref reference external" href="#fn-registercomparator">registerComparator</a>)</li>
<li>An extensible programmer representation facility
(<a class="mochiref reference external" href="#fn-repr">repr</a>, <a class="mochiref reference external" href="#fn-registerrepr">registerRepr</a>)</li>
<li>An extensible JSON <a class="footnote-reference" href="#id7" id="id1">[1]</a> serialization and evaluation facility
(<a class="mochiref reference external" href="#fn-serializejson">serializeJSON</a>, <a class="mochiref reference external" href="#fn-evaljson">evalJSON</a>,
<a class="mochiref reference external" href="#fn-registerjson">registerJSON</a>)</li>
<li>A simple adaptation facility (<a class="mochiref reference external" href="#fn-adapterregistry">AdapterRegistry</a>)</li>
<li>Convenience functions for manipulating objects and Arrays
(<a class="mochiref reference external" href="#fn-update">update</a>, <a class="mochiref reference external" href="#fn-setdefault">setdefault</a>, <a class="mochiref reference external" href="#fn-extend">extend</a>, etc.)</li>
<li>Array-based functional programming
(<a class="mochiref reference external" href="#fn-map">map</a>, <a class="mochiref reference external" href="#fn-filter">filter</a>, etc.)</li>
<li>Bound and partially applied functions
(<a class="mochiref reference external" href="#fn-bind">bind</a>, <a class="mochiref reference external" href="#fn-method">method</a>, <a class="mochiref reference external" href="#fn-partial">partial</a>)</li>
</ul>
<p>Python users will feel at home with <a class="mochiref reference external" href="Base.html">MochiKit.Base</a>, as the
facilities are quite similar to those available as part of Python and
the Python standard library.</p>
</div>
<div class="section" id="dependencies">
<h1>Dependencies</h1>
<p>None.</p>
</div>
<div class="section" id="overview">
<h1>Overview</h1>
<div class="section" id="comparison">
<h2>Comparison</h2>
<p>The comparators (operators for comparison) in JavaScript are deeply
broken, and it is not possible to teach them new tricks.</p>
<p>MochiKit exposes an extensible comparison facility as a simple
<a class="mochiref reference external" href="#fn-compare">compare(a, b)</a> function, which should be used in lieu of
JavaScript's operators whenever comparing objects other than numbers
or strings (though you can certainly use <a class="mochiref reference external" href="#fn-compare">compare</a> for
those, too!).</p>
<p>The <a class="mochiref reference external" href="#fn-compare">compare</a> function has the same signature and return
value as a sort function for <tt class="docutils literal">Array.prototype.sort</tt>, and is often
used in that context.</p>
<p>Defining new comparators for the <a class="mochiref reference external" href="#fn-compare">compare</a> function to use
is done by adding an entry to its <a class="mochiref reference external" href="#fn-adapterregistry">AdapterRegistry</a> with the
<a class="mochiref reference external" href="#fn-registercomparator">registerComparator</a> function.</p>
</div>
<div class="section" id="programmer-representation">
<h2>Programmer Representation</h2>
<p>JavaScript's default representation mechanism, <tt class="docutils literal">toString</tt>, is
notorious for having terrible default behavior. It's also very unwise
to change that default, as other JavaScript code you may be using may
depend on it.</p>
<p>It's also useful to separate the concept of a &quot;string representation&quot;
and a &quot;string representation for programmers&quot;, much like Python does
with its str and repr protocols.</p>
<p><a class="mochiref reference external" href="#fn-repr">repr</a> provides this programmer representation for
JavaScript, in a way that doesn't require object prototype hacking:
using an <a class="mochiref reference external" href="#fn-adapterregistry">AdapterRegistry</a>.</p>
<p>Objects that implement the repr protocol can either implement a
<tt class="docutils literal">.repr()</tt> or <tt class="docutils literal">.__repr__()</tt> method, or they can simply have an
adapter setup to generate programmer representations. By default, the
registry provides nice representations for <tt class="docutils literal">null</tt>, <tt class="docutils literal">undefined</tt>,
<tt class="docutils literal">Array</tt>, and objects or functions with a <tt class="docutils literal">NAME</tt> attribute that use
the default <tt class="docutils literal">toString</tt>. For objects that <tt class="docutils literal">repr</tt> doesn't already
understand, it simply defaults to <tt class="docutils literal">toString</tt>, so it will integrate
seamlessly with code that implements the idiomatic JavaScript
<tt class="docutils literal">toString</tt> method!</p>
<p>To define a programmer representation for your own objects, simply add
a <tt class="docutils literal">.repr()</tt> or <tt class="docutils literal">.__repr__()</tt> method that returns a string. For
objects that you didn't create (e.g., from a script you didn't write,
or a built-in object), it is instead recommended that you create an
adapter with <a class="mochiref reference external" href="#fn-registerrepr">registerRepr</a>.</p>
</div>
<div class="section" id="json-serialization">
<h2>JSON Serialization</h2>
<p>JSON <a class="footnote-reference" href="#id7" id="id2">[1]</a>, JavaScript Object Notation, is a widely used serialization
format in the context of web development. It's extremely simple,
lightweight, and fast. In its essence, JSON is a restricted subset of
JavaScript syntax suitable for sending over the wire that can be
unserialized with a simple eval. It's often used as an alternative to
XML in &quot;AJAX&quot; contexts because it is compact, fast, and much simpler
to use for most purposes.</p>
<p>To create a JSON serialization of any object, simply call
<a class="mochiref reference external" href="#fn-serializejson">serializeJSON()</a> with that object. To unserialize a JSON
string, simply call <a class="mochiref reference external" href="#fn-evaljson">evalJSON()</a> with the serialization.</p>
<p>In order of precedence, <a class="mochiref reference external" href="#fn-serializejson">serializeJSON</a> coerces the given
argument into a JSON serialization:</p>
<ol class="arabic simple">
<li>Primitive types are returned as their JSON representation:
<tt class="docutils literal">string</tt>, <tt class="docutils literal">number</tt>, <tt class="docutils literal">boolean</tt>, <tt class="docutils literal">null</tt>.</li>
<li>If the object has a <tt class="docutils literal">toJSON</tt>, <tt class="docutils literal">__json__</tt> or <tt class="docutils literal">json</tt> method,
then it is called with no arguments. If the result of this method
is not the object itself, then the new object goes through rule
processing again (e.g. it may return a string, which is then
serialized in JSON format).</li>
<li>If the object is <tt class="docutils literal">Array</tt>-like (has a <tt class="docutils literal">length</tt> property that is
a number, and is not a function), then it is serialized as a JSON
array.  Each element will be processed according to these rules in
order.  Elements that can not be serialized (e.g. functions) will
be replaced with <tt class="docutils literal">undefined</tt>.</li>
<li>The <tt class="docutils literal">jsonRegistry</tt> <a class="mochiref reference external" href="#fn-adapterregistry">AdapterRegistry</a> is consulted for
an adapter for this object. JSON adapters take one argument (the
object), and are expected to behave like a <tt class="docutils literal">__json__</tt> or
<tt class="docutils literal">json</tt> method (return another object to be serialized, or
itself).</li>
<li>If the object is <tt class="docutils literal">undefined</tt>, a <tt class="docutils literal">TypeError</tt> is thrown. If you
wish to serialize <tt class="docutils literal">undefined</tt> as <tt class="docutils literal">null</tt> or some other value, you
should create an adapter to do so.</li>
<li>If no adapter is available, the object is enumerated and
serialized as a JSON object (name:value pairs). All names are
expected to be strings.  Each value is serialized according to
these rules, and if it can not be serialized (e.g. methods), then
that name:value pair will be skipped.</li>
</ol>
</div>
<div class="section" id="adapter-registries">
<h2>Adapter Registries</h2>
<p>MochiKit makes extensive use of adapter registries, which enable you
to implement object-specific behaviors for objects that you do not
necessarily want to modify, such as built-in objects. This is
especially useful because JavaScript does not provide a method for
hiding user-defined properties from <tt class="docutils literal">for propName in obj</tt>
enumeration.</p>
<p><a class="mochiref reference external" href="#fn-adapterregistry">AdapterRegistry</a> is simply an encapsulation for an ordered
list of &quot;check&quot; and &quot;wrap&quot; function pairs. Each
<a class="mochiref reference external" href="#fn-adapterregistry">AdapterRegistry</a> instance should perform one function, but
may have multiple ways to achieve that function based upon the
arguments. One way to think of it is as a poor man's generic function,
or multiple dispatch (on arbitrary functions, not just type!).</p>
<p>Check functions take one or more arguments, and return <tt class="docutils literal">true</tt> if the
argument list is suitable for the wrap function. Check functions
should perform &quot;cheap&quot; checks of an object's type or contents, before
the &quot;expensive&quot; wrap function is called.</p>
<p>Wrap functions take the same arguments as check functions and do some
operation, such as creating a programmer representation or comparing
both arguments.</p>
</div>
<div class="section" id="convenience-functions">
<h2>Convenience Functions</h2>
<p>Much of <a class="mochiref reference external" href="Base.html">MochiKit.Base</a> is there to simply remove the grunt
work of doing generic JavaScript programming.</p>
<p>Need to take every property from one object and set them on another?
No problem, just call <a class="mochiref reference external" href="#fn-update">update(dest, src)</a>! What if you just
wanted to update keys that weren't already set? Look no further than
<a class="mochiref reference external" href="#fn-setdefault">setdefault(dest, src[, ...])</a>.</p>
<p>Want to return a mutable object, but don't want to suffer the
consequences if the user mutates it? Just <a class="mochiref reference external" href="#fn-clone">clone(it)</a> and
you'll get a copy-on-write clone. Cheaper than a copy!</p>
<p>Need to extend an <tt class="docutils literal">Array</tt> with another array? Or even an
<tt class="docutils literal">Array</tt>-like object such as a <tt class="docutils literal">NodeList</tt> or the special
<tt class="docutils literal">arguments</tt> object? Even if you need to skip the first few elements
of the source <tt class="docutils literal">Array</tt>-like object, it's no problem with
<a class="mochiref reference external" href="#fn-extend">extend(dstArray, srcArrayLike[, skip])</a>!</p>
<p>Wouldn't it be convenient to have all of the JavaScript operators were
available as functions somewhere? That's what the
<a class="mochiref reference external" href="#fn-operators">operators</a> table is for, and it even comes with additional
operators based on the <a class="mochiref reference external" href="#fn-compare">compare</a> function.</p>
<p>Need to walk some tree of objects and manipulate or find something in
it?  A DOM element tree perhaps? Use <a class="mochiref reference external" href="#fn-nodewalk">nodeWalk(node,
visitor)</a>!</p>
<p>There's plenty more, so check out the <a class="reference internal" href="#api-reference">API Reference</a> below.</p>
</div>
<div class="section" id="functional-programming">
<h2>Functional Programming</h2>
<p>Functional programming constructs such as <a class="mochiref reference external" href="#fn-map">map</a> and
<a class="mochiref reference external" href="#fn-filter">filter</a> can save you a lot of time, because JavaScript
iteration is error-prone and arduous. Writing less code is the best
way to prevent bugs, and functional programming can help you do that.</p>
<p><a class="mochiref reference external" href="Base.html">MochiKit.Base</a> ships with a few simple Array-based
functional programming constructs, namely <a class="mochiref reference external" href="#fn-map">map</a> and
<a class="mochiref reference external" href="#fn-filter">filter</a>, and their &quot;extended&quot; brethren, <a class="mochiref reference external" href="#fn-xmap">xmap</a>
and <a class="mochiref reference external" href="#fn-xfilter">xfilter</a>.</p>
<p><a class="mochiref reference external" href="#fn-map">map(func, arrayLike[, ...])</a> takes a function and an
<tt class="docutils literal">Array</tt>-like object, and creates a new <tt class="docutils literal">Array</tt>. The new <tt class="docutils literal">Array</tt>
is the result of <tt class="docutils literal">func(element)</tt> for every element of <tt class="docutils literal">arrayLike</tt>,
much like the <tt class="docutils literal">Array.prototype.map</tt> extension in Mozilla. However,
<a class="mochiref reference external" href="Base.html">MochiKit.Base</a> takes that a step further and gives you the
full blown Python version of <a class="mochiref reference external" href="#fn-map">map</a>, which will take several
<tt class="docutils literal">Array</tt>-like objects, and calls the function with one argument per
given <tt class="docutils literal">Array</tt>-like, e.g.:</p>
<pre class="literal-block">
var arrayOne = [1, 2, 3, 4, 5];
var arrayTwo = [1, 5, 2, 4, 3];
var arrayThree = [5, 2, 1, 3, 4];
var biggestElements = map(objMax, arrayOne, arrayTwo, arrayThree);
assert( objEqual(biggestElements, [5, 5, 3, 4, 5]) );
</pre>
<p><a class="mochiref reference external" href="#fn-filter">filter(func, arrayLike[, self])</a> takes a function and an
<tt class="docutils literal">Array</tt>-like object, and returns a new <tt class="docutils literal">Array</tt>.  This is basically
identical to the <tt class="docutils literal">Array.prototype.filter</tt> extension in
Mozilla. self, if given, will be used as <tt class="docutils literal">this</tt> in the context of
func when called.</p>
<p><a class="mochiref reference external" href="#fn-xmap">xmap</a> and <a class="mochiref reference external" href="#fn-xfilter">xfilter</a> are just special forms of
<a class="mochiref reference external" href="#fn-map">map</a> and <a class="mochiref reference external" href="#fn-filter">filter</a> that accept a function as the
first argument, and use the extra arguments as the <tt class="docutils literal">Array</tt>-like. Not
terribly interesting, but a definite time-saver in some cases.</p>
<p>If you appreciate the functional programming facilities here, you
should definitely check out <a class="mochiref reference external" href="Iter.html">MochiKit.Iter</a>, which provides
full blown iterators, <a class="mochiref reference external" href="Iter.html#fn-range">MochiKit.Iter.range</a>,
<a class="mochiref reference external" href="Iter.html#fn-reduce">MochiKit.Iter.reduce</a>, and a near-complete port of Python's
itertools <a class="footnote-reference" href="#id8" id="id3">[2]</a> module, with some extra stuff thrown in for good
measure!</p>
</div>
<div class="section" id="bound-and-partial-functions">
<h2>Bound and Partial Functions</h2>
<p>JavaScript's method-calling special form and lack of bound functions
(functions that know what <tt class="docutils literal">this</tt> should be) are one of the first
stumbling blocks that programmers new to JavaScript face. The
<a class="mochiref reference external" href="#fn-bind">bind(func, self)</a> method fixes that right up by returning a
new function that calls func with the right <tt class="docutils literal">this</tt>.</p>
<p>In order to take real advantage of all this fancy functional
programming stuff, you're probably going to want partial
application. This allows you to create a new function from an existing
function that remembers some of the arguments.  For example, if you
wanted to compare a given object to a slew of other objects, you could
do something like this:</p>
<pre class="literal-block">
compareWithOne = partial(compare, 1);
results = map(compareWithOne, [0, 1, 2, 3]);
assert( objEqual(results, [-1, 0, 1, 1]) );
</pre>
<p>One of the better uses of partial functions is in
<a class="mochiref reference external" href="DOM.html">MochiKit.DOM</a>, which is certainly a must-see for those of
you creating lots of DOM elements with JavaScript!</p>
</div>
</div>
<div class="section" id="api-reference">
<h1>API Reference</h1>
<div class="section" id="errors">
<h2>Errors</h2>
<p>
<a name="fn-notfound"></a>
<a class="mochidef reference external" href="#fn-notfound">NotFound</a>:</p>
<blockquote>
<p>A singleton error raised when no suitable adapter is found</p>
<dl class="docutils">
<dt><em>Availability</em>:</dt>
<dd>Available in MochiKit 1.3.1+</dd>
</dl>
</blockquote>
</div>
<div class="section" id="constructors">
<h2>Constructors</h2>
<p>
<a name="fn-adapterregistry"></a>
<a class="mochidef reference external" href="#fn-adapterregistry">AdapterRegistry</a>:</p>
<blockquote>
<p>A registry to facilitate adaptation.</p>
<p>All <tt class="docutils literal">check</tt>/<tt class="docutils literal">wrap</tt> function pairs in a given registry should
take the same number of arguments.</p>
<dl class="docutils">
<dt><em>Availability</em>:</dt>
<dd>Available in MochiKit 1.3.1+</dd>
</dl>
</blockquote>
<p>
<a name="fn-adapterregistry.prototype.register"></a>
<a class="mochidef reference external" href="#fn-adapterregistry.prototype.register">AdapterRegistry.prototype.register(name, check, wrap[, override])</a>:</p>
<blockquote>
<dl class="docutils">
<dt><tt class="docutils literal">name</tt>:</dt>
<dd>a unique identifier used to identify this adapter so that it
may be unregistered.</dd>
<dt><tt class="docutils literal">check</tt>:</dt>
<dd>function that should return <tt class="docutils literal">true</tt> if the given arguments
are appropriate for the <tt class="docutils literal">wrap</tt> function.</dd>
<dt><tt class="docutils literal">wrap</tt>:</dt>
<dd>function that takes the same parameters as <tt class="docutils literal">check</tt> and does
the adaptation.  Every <tt class="docutils literal">wrap</tt>/<tt class="docutils literal">check</tt> function pair in the
registry should have the same number of arguments.</dd>
<dt><tt class="docutils literal">override</tt>:</dt>
<dd>if <tt class="docutils literal">true</tt>, the <tt class="docutils literal">check</tt> function will be
given highest priority. Otherwise, the lowest.</dd>
<dt><em>Availability</em>:</dt>
<dd>Available in MochiKit 1.3.1+</dd>
</dl>
</blockquote>
<p>
<a name="fn-adapterregistry.prototype.match"></a>
<a class="mochidef reference external" href="#fn-adapterregistry.prototype.match">AdapterRegistry.prototype.match(obj[, ...])</a>:</p>
<blockquote>
<p>Find an adapter for the given arguments by calling every <tt class="docutils literal">check</tt>
function until one returns <tt class="docutils literal">true</tt>.</p>
<p>If no suitable adapter is found, throws <a class="mochiref reference external" href="#fn-notfound">NotFound</a>.</p>
<dl class="docutils">
<dt><em>Availability</em>:</dt>
<dd>Available in MochiKit 1.3.1+</dd>
</dl>
</blockquote>
<p>
<a name="fn-adapterregistry.prototype.unregister"></a>
<a class="mochidef reference external" href="#fn-adapterregistry.prototype.unregister">AdapterRegistry.prototype.unregister(name)</a>:</p>
<blockquote>
<p>Remove a named adapter from the registry</p>
<dl class="docutils">
<dt><em>Availability</em>:</dt>
<dd>Available in MochiKit 1.3.1+</dd>
</dl>
</blockquote>
<p>
<a name="fn-namederror"></a>
<a class="mochidef reference external" href="#fn-namederror">NamedError</a>:</p>
<blockquote>
<p>Convenience constructor for creating new errors
(e.g. <a class="mochiref reference external" href="#fn-notfound">NotFound</a>)</p>
<dl class="docutils">
<dt><em>Availability</em>:</dt>
<dd>Available in MochiKit 1.3.1+</dd>
</dl>
</blockquote>
</div>
<div class="section" id="functions">
<h2>Functions</h2>
<p>
<a name="fn-arrayequal"></a>
<a class="mochidef reference external" href="#fn-arrayequal">arrayEqual(self, arr)</a>:</p>
<blockquote>
<p>Compare the arrays <tt class="docutils literal">self</tt> and <tt class="docutils literal">arr</tt> for equality using
<tt class="docutils literal">compare</tt> on each element. Uses a fast-path for length
differences.</p>
<dl class="docutils">
<dt><em>Availability</em>:</dt>
<dd>Available in MochiKit 1.3.1+</dd>
</dl>
</blockquote>
<p>
<a name="fn-average"></a>
<a class="mochidef reference external" href="#fn-average">average(lst[, ...])</a>:</p>
<blockquote>
<p>This function is an alias of <a class="mochiref reference external" href="#fn-mean">mean()</a>.</p>
<dl class="docutils">
<dt><em>Availability</em>:</dt>
<dd>Available in MochiKit 1.3.1+</dd>
</dl>
</blockquote>
<p>
<a name="fn-bind"></a>
<a class="mochidef reference external" href="#fn-bind">bind(func, self[, arg, ...])</a>:</p>
<blockquote>
<p>Return a copy of <tt class="docutils literal">func</tt> bound to <tt class="docutils literal">self</tt>. This means whenever
and however the returned function is called, <tt class="docutils literal">this</tt> will always
reference the given <tt class="docutils literal">self</tt>. <tt class="docutils literal">func</tt> may be either a function
object, or a string. If it is a string, then <tt class="docutils literal">self[func]</tt> will
be used, making these two statements equivalent:</p>
<pre class="literal-block">
bind(&quot;method&quot;, self);
bind(self.method, self);
</pre>
<p>Calling <a class="mochiref reference external" href="#fn-bind">bind(func, self)</a> on an already bound function
will return a new function that is bound to the new <tt class="docutils literal">self</tt>! If
<tt class="docutils literal">self</tt> is <tt class="docutils literal">undefined</tt>, then the previous <tt class="docutils literal">self</tt> is used.  If
<tt class="docutils literal">self</tt> is <tt class="docutils literal">null</tt>, then the <tt class="docutils literal">this</tt> object is used (which may
or may not be the global object). To force binding to the global
object, you should pass it explicitly.</p>
<p>Additional arguments, if given, will be partially applied to the
function. These three expressions are equivalent and return
equally efficient functions (<a class="mochiref reference external" href="#fn-bind">bind</a> and
<a class="mochiref reference external" href="#fn-partial">partial</a> share the same code path):</p>
<ul class="simple">
<li><a class="mochiref reference external" href="#fn-bind">bind(oldfunc, self, arg1, arg2)</a></li>
<li><a class="mochiref reference external" href="#fn-bind">bind(partial(oldfunc, arg1, arg2), self)</a></li>
<li><a class="mochiref reference external" href="#fn-partial">partial(bind(oldfunc, self), arg1, arg2)</a></li>
</ul>
<dl class="docutils">
<dt><em>Availability</em>:</dt>
<dd>Available in MochiKit 1.3.1+</dd>
</dl>
</blockquote>
<p>
<a name="fn-bindlate"></a>
<a class="mochidef reference external" href="#fn-bindlate">bindLate(func, self[, arg, ...])</a>:</p>
<blockquote>
<p>Alternate version of <a class="mochiref reference external" href="#fn-bind">bind</a> that uses late lookup of
the <tt class="docutils literal">func</tt> parameter in <tt class="docutils literal">self</tt>. I.e, the <tt class="docutils literal">self[func]</tt>
function lookup will occur on each call to the returned function,
not when <tt class="docutils literal">bindLate</tt> is called. Note that this difference is
only applicable when <tt class="docutils literal">func</tt> is a string, otherwise <tt class="docutils literal">bindLate</tt>
and <tt class="docutils literal">bind</tt> are identical.</p>
<dl class="docutils">
<dt><em>Availability</em>:</dt>
<dd>Available in MochiKit 1.4+</dd>
</dl>
</blockquote>
<p>
<a name="fn-bindmethods"></a>
<a class="mochidef reference external" href="#fn-bindmethods">bindMethods(self)</a>:</p>
<blockquote>
<p>Replace all functions <tt class="docutils literal">meth</tt> on <tt class="docutils literal">self</tt> with
<a class="mochiref reference external" href="#fn-bind">bind(meth, self)</a>.  This emulates Python's bound
instance methods, where there is no need to worry about preserving
<tt class="docutils literal">this</tt> when the method is used as a callback.</p>
<dl class="docutils">
<dt><em>Availability</em>:</dt>
<dd>Available in MochiKit 1.3.1+</dd>
</dl>
</blockquote>
<p>
<a name="fn-bool"></a>
<a class="mochidef reference external" href="#fn-bool">bool(value)</a>:</p>
<blockquote>
<p>Converts <tt class="docutils literal">value</tt> into a boolean. The conversion varies depending on
<tt class="docutils literal">typeof(value)</tt>:</p>
<ol class="arabic simple">
<li>A boolean <tt class="docutils literal">value</tt> is returned as-is.</li>
<li>A string <tt class="docutils literal">value</tt> is considered false if and only if it equals <tt class="docutils literal">&quot;&quot;</tt>,
<tt class="docutils literal">&quot;false&quot;</tt>, <tt class="docutils literal">&quot;null&quot;</tt>, <tt class="docutils literal">&quot;undefined&quot;</tt> or <tt class="docutils literal">&quot;0&quot;</tt>.</li>
<li>A number <tt class="docutils literal">value</tt> is considered false if and only if <tt class="docutils literal">isNaN(value)</tt>
or <tt class="docutils literal">value == 0</tt>.</li>
<li>A array-like <tt class="docutils literal">value</tt> is considered false if and only if
<tt class="docutils literal">value.length == 0</tt>.</li>
<li>Any other <tt class="docutils literal">value</tt> is considered false if and only if <tt class="docutils literal">value == null</tt>.</li>
</ol>
<dl class="docutils">
<dt><em>Availability</em>:</dt>
<dd>Available in MochiKit 1.5+</dd>
</dl>
</blockquote>
<p>
<a name="fn-camelize"></a>
<a class="mochidef reference external" href="#fn-camelize">camelize(str)</a>:</p>
<blockquote>
<p>Converts hyphenated strings to camelCase:</p>
<pre class="literal-block">
assert( camelize(&quot;border-left&quot;) == &quot;borderLeft&quot; );
</pre>
<dl class="docutils">
<dt><em>Availability</em>:</dt>
<dd>Available in MochiKit 1.4+</dd>
</dl>
</blockquote>
<p>
<a name="fn-clone"></a>
<a class="mochidef reference external" href="#fn-clone">clone(obj)</a>:</p>
<blockquote>
<p>Return a new object using <tt class="docutils literal">obj</tt> as its prototype. Use this if
you want to return a mutable object (e.g. instance state), but
don't want the user to mutate it. If they do, it won't have any
effect on the original <tt class="docutils literal">obj</tt>.</p>
<p>Note that this is a shallow clone, so mutable properties will have
to be cloned separately if you want to &quot;protect&quot; them.</p>
<dl class="docutils">
<dt><em>Availability</em>:</dt>
<dd>Available in MochiKit 1.3.1+</dd>
</dl>
</blockquote>
<p>
<a name="fn-compare"></a>
<a class="mochidef reference external" href="#fn-compare">compare(a, b)</a>:</p>
<blockquote>
<p>Compare two objects in a sensible manner. Currently this is:</p>
<ol class="arabic simple">
<li><tt class="docutils literal">undefined</tt> and <tt class="docutils literal">null</tt> compare equal to each other</li>
<li><tt class="docutils literal">undefined</tt> and <tt class="docutils literal">null</tt> are less than anything else</li>
<li>If JavaScript says <tt class="docutils literal">a == b</tt>, then we trust it</li>
<li>comparators registered with registerComparator are used to
find a good comparator. Built-in comparators are currently
available for <tt class="docutils literal">Array</tt>-like and <tt class="docutils literal">Date</tt>-like objects.</li>
<li>Otherwise hope that the built-in comparison operators do
something useful, which should work for numbers and strings.</li>
<li>If neither <tt class="docutils literal">a &lt; b</tt> or <tt class="docutils literal">a &gt; b</tt>, then throw a <tt class="docutils literal">TypeError</tt></li>
</ol>
<p>Returns what one would expect from a comparison function:</p>
<table border="1" class="docutils">
<colgroup>
<col width="42%" />
<col width="58%" />
</colgroup>
<tbody valign="top">
<tr><td>Value</td>
<td>Condition</td>
</tr>
<tr><td><tt class="docutils literal">0</tt></td>
<td><tt class="docutils literal">a == b</tt></td>
</tr>
<tr><td><tt class="docutils literal">1</tt></td>
<td><tt class="docutils literal">a &gt; b</tt></td>
</tr>
<tr><td><tt class="docutils literal"><span class="pre">-1</span></tt></td>
<td><tt class="docutils literal">a &lt; b</tt></td>
</tr>
</tbody>
</table>
<dl class="docutils">
<dt><em>Availability</em>:</dt>
<dd>Available in MochiKit 1.3.1+</dd>
</dl>
</blockquote>
<p>
<a name="fn-compose"></a>
<a class="mochidef reference external" href="#fn-compose">compose(f1, f2, ..., fN)</a>:</p>
<blockquote>
<p>Return a new function as the combination of the given function
arguments, equivalent to <tt class="docutils literal">f1(f2(arguments))</tt>.</p>
<dl class="docutils">
<dt><em>Availability</em>:</dt>
<dd>Available in MochiKit 1.4+</dd>
</dl>
</blockquote>
<p>
<a name="fn-concat"></a>
<a class="mochidef reference external" href="#fn-concat">concat(lst[, ...])</a>:</p>
<blockquote>
<p>Concatenates all given <tt class="docutils literal">Array</tt>-like arguments and returns
a new <tt class="docutils literal">Array</tt>:</p>
<pre class="literal-block">
var lst = concat([&quot;1&quot;,&quot;3&quot;,&quot;5&quot;], [&quot;2&quot;,&quot;4&quot;,&quot;6&quot;]);
assert( lst.toString() == &quot;1,3,5,2,4,6&quot; );
</pre>
<dl class="docutils">
<dt><em>Availability</em>:</dt>
<dd>Available in MochiKit 1.3.1+</dd>
</dl>
</blockquote>
<p>
<a name="fn-counter"></a>
<a class="mochidef reference external" href="#fn-counter">counter(n=1)</a>:</p>
<blockquote>
<p>Returns a function that will return a number one greater than
the previous returned value, starting at <tt class="docutils literal">n</tt>. For example:</p>
<pre class="literal-block">
nextId = counter()
assert( nextId() == 1 )
assert( nextId() == 2 )
</pre>
<p>For an iterator with this behavior, see
<a class="mochiref reference external" href="Iter.html#fn-count">MochiKit.Iter.count</a>.</p>
<dl class="docutils">
<dt><em>Availability</em>:</dt>
<dd>Available in MochiKit 1.3.1+</dd>
</dl>
</blockquote>
<p>
<a name="fn-extend"></a>
<a class="mochidef reference external" href="#fn-extend">extend(self, obj, skip=0)</a>:</p>
<blockquote>
<p>Mutate the array <tt class="docutils literal">self</tt> by extending it with an <tt class="docutils literal">Array</tt>-like
<tt class="docutils literal">obj</tt>, starting from index <tt class="docutils literal">skip</tt>. If <tt class="docutils literal">null</tt> is given as the
initial array, a new one will be created.</p>
<p>This mutates <em>and returns</em> <tt class="docutils literal">self</tt>, be warned.</p>
<dl class="docutils">
<dt><em>Availability</em>:</dt>
<dd>Available in MochiKit 1.3.1+</dd>
</dl>
</blockquote>
<p>
<a name="fn-evaljson"></a>
<a class="mochidef reference external" href="#fn-evaljson">evalJSON(jsonText)</a>:</p>
<blockquote>
<p>Unserialize a JSON <a class="footnote-reference" href="#id7" id="id4">[1]</a> representation of an object.</p>
<p>Note that this uses the <tt class="docutils literal">eval</tt> function of the interpreter, and
therefore trusts the contents of <tt class="docutils literal">jsonText</tt> to be safe.  This
is acceptable when the JSON and JavaScript application originate
from the same server, but in other scenarios it may not be the
appropriate security model. Currently, a validating JSON parser is
beyond the scope of MochiKit, but in most modern browsers the
<tt class="docutils literal">JSON.parse</tt> function is built-in for this purpose. There is
also one available from json.org <a class="footnote-reference" href="#id7" id="id5">[1]</a>.</p>
<dl class="docutils">
<dt><em>Availability</em>:</dt>
<dd>Available in MochiKit 1.3.1+</dd>
</dl>
</blockquote>
<p>
<a name="fn-filter"></a>
<a class="mochidef reference external" href="#fn-filter">filter(fn, lst)</a>:</p>
<blockquote>
<p>Returns a new <tt class="docutils literal">Array</tt> composed of all elements from <tt class="docutils literal">lst</tt>
where <tt class="docutils literal">fn(lst[i])</tt> returns a true value.</p>
<p>If <tt class="docutils literal">fn</tt> is <tt class="docutils literal">null</tt>, <tt class="docutils literal">operator.truth</tt> will be used.</p>
<dl class="docutils">
<dt><em>Availability</em>:</dt>
<dd>Available in MochiKit 1.3.1+</dd>
</dl>
</blockquote>
<p>
<a name="fn-findvalue"></a>
<a class="mochidef reference external" href="#fn-findvalue">findValue(lst, value, start=0, end=lst.length)</a>:</p>
<blockquote>
<p>Finds the index of <tt class="docutils literal">value</tt> in the <tt class="docutils literal">Array</tt>-like object <tt class="docutils literal">lst</tt>
using <a class="mochiref reference external" href="#fn-compare">compare</a>. The search starts at the index
<tt class="docutils literal">start</tt>, and ends at the index <tt class="docutils literal">end - 1</tt>. If <tt class="docutils literal">value</tt> is not
found in <tt class="docutils literal">lst</tt>, it will return <tt class="docutils literal"><span class="pre">-1</span></tt>.</p>
<p>For example:</p>
<pre class="literal-block">
assert( findValue([1, 2, 3, 2, 1], 2) == 1 )
assert( findValue([1, 2, 3, 2, 1], 2, 2) == 3 )
</pre>
<dl class="docutils">
<dt><em>Availability</em>:</dt>
<dd>Available in MochiKit 1.3.1+</dd>
</dl>
</blockquote>
<p>
<a name="fn-findidentical"></a>
<a class="mochidef reference external" href="#fn-findidentical">findIdentical(lst, value, start=0, end=lst.length)</a>:</p>
<blockquote>
<p>Finds the index of <tt class="docutils literal">value</tt> in the <tt class="docutils literal">Array</tt>-like object <tt class="docutils literal">lst</tt>
using the <tt class="docutils literal">===</tt> operator. The search starts at the index
<tt class="docutils literal">start</tt>, and ends at the index <tt class="docutils literal">end - 1</tt>. If <tt class="docutils literal">value</tt> is not
found in <tt class="docutils literal">lst</tt>, it will return <tt class="docutils literal"><span class="pre">-1</span></tt>.</p>
<p>You should use this function instead of <a class="mochiref reference external" href="#fn-findvalue">findValue</a> if
<tt class="docutils literal">lst</tt> may be comprised of objects for which no comparator is
defined and all you care about is finding an identical object
(e.g. the same instance), or if <tt class="docutils literal">lst</tt> is comprised of just
numbers or strings and performance is important.</p>
<p>For example:</p>
<pre class="literal-block">
assert( findIdentical([1, 2, 3, 2, 1], 2) == 1 )
assert( findIdentical([1, 2, 3, 2, 1], 2, 2) == 3 )
</pre>
<dl class="docutils">
<dt><em>Availability</em>:</dt>
<dd>Available in MochiKit 1.3.1+</dd>
</dl>
</blockquote>
<p>
<a name="fn-flattenarguments"></a>
<a class="mochidef reference external" href="#fn-flattenarguments">flattenArguments(arg[, ...])</a>:</p>
<blockquote>
<p>Given a bunch of arguments, return a single <tt class="docutils literal">Array</tt> containing
all of those arguments. Any <tt class="docutils literal">Array</tt>-like argument will be extended
in-place, e.g.:</p>
<pre class="literal-block">
compare(flattenArguments(1, [2, 3, [4, 5]]), [1, 2, 3, 4, 5]) == 0
</pre>
<dl class="docutils">
<dt><em>Availability</em>:</dt>
<dd>Available in MochiKit 1.3.1+</dd>
</dl>
</blockquote>
<p>
<a name="fn-flattenarray"></a>
<a class="mochidef reference external" href="#fn-flattenarray">flattenArray(lst)</a>:</p>
<blockquote>
<p>Return a new <tt class="docutils literal">Array</tt> consisting of every item in lst with <tt class="docutils literal">Array</tt>
items expanded in-place recursively. This differs from
<a class="mochiref reference external" href="#fn-flattenarguments">flattenArguments</a> in that it only takes one argument and
it only flattens items that are <tt class="docutils literal">instanceof Array</tt>.</p>
<blockquote>
compare(flattenArray([1, [2, 3, [4, 5]]]), [1, 2, 3, 4, 5]) == 0</blockquote>
<dl class="docutils">
<dt><em>Availability</em>:</dt>
<dd>Available in MochiKit 1.4+</dd>
</dl>
</blockquote>
<p>
<a name="fn-forwardcall"></a>
<a class="mochidef reference external" href="#fn-forwardcall">forwardCall(name)</a>:</p>
<blockquote>
<p>Returns a function that forwards a method call to
<tt class="docutils literal"><span class="pre">this.name(...)</span></tt></p>
<dl class="docutils">
<dt><em>Availability</em>:</dt>
<dd>Available in MochiKit 1.3.1+</dd>
</dl>
</blockquote>
<p>
<a name="fn-isarraylike"></a>
<a class="mochidef reference external" href="#fn-isarraylike">isArrayLike(obj[, ...])</a>:</p>
<blockquote>
<p>Returns <tt class="docutils literal">true</tt> if all given arguments are <tt class="docutils literal">Array</tt>-like (have a
<tt class="docutils literal">.length</tt> property and <tt class="docutils literal">typeof(obj) == 'object'</tt>)</p>
<dl class="docutils">
<dt><em>Availability</em>:</dt>
<dd>Available in MochiKit 1.3.1+</dd>
</dl>
</blockquote>
<p>
<a name="fn-iscallable"></a>
<a class="mochidef reference external" href="#fn-iscallable">isCallable(obj[, ...])</a>:</p>
<blockquote>
<p>Returns <tt class="docutils literal">true</tt> if all given arguments are functions.</p>
<dl class="docutils">
<dt><em>Availability</em>:</dt>
<dd>Available in MochiKit 1.3.1+</dd>
</dl>
</blockquote>
<p>
<a name="fn-isdatelike"></a>
<a class="mochidef reference external" href="#fn-isdatelike">isDateLike(obj[, ...])</a>:</p>
<blockquote>
<p>Returns <tt class="docutils literal">true</tt> if all given arguments are <tt class="docutils literal">Date</tt>-like (have a
<tt class="docutils literal">.getTime()</tt> method)</p>
<dl class="docutils">
<dt><em>Availability</em>:</dt>
<dd>Available in MochiKit 1.3.1+</dd>
</dl>
</blockquote>
<p>
<a name="fn-isempty"></a>
<a class="mochidef reference external" href="#fn-isempty">isEmpty(obj[, ...])</a>:</p>
<blockquote>
<p>Returns <tt class="docutils literal">true</tt> if all the given <tt class="docutils literal">Array</tt>-like or string
arguments are empty <tt class="docutils literal">(obj.length == 0)</tt></p>
<dl class="docutils">
<dt><em>Availability</em>:</dt>
<dd>Available in MochiKit 1.3.1+</dd>
</dl>
</blockquote>
<p>
<a name="fn-isnotempty"></a>
<a class="mochidef reference external" href="#fn-isnotempty">isNotEmpty(obj[, ...])</a>:</p>
<blockquote>
<p>Returns <tt class="docutils literal">true</tt> if all the given <tt class="docutils literal">Array</tt>-like or string
arguments are not empty <tt class="docutils literal">(obj.length &gt; 0)</tt></p>
<dl class="docutils">
<dt><em>Availability</em>:</dt>
<dd>Available in MochiKit 1.3.1+</dd>
</dl>
</blockquote>
<p>
<a name="fn-isnull"></a>
<a class="mochidef reference external" href="#fn-isnull">isNull(obj[, ...])</a>:</p>
<blockquote>
<p>Returns <tt class="docutils literal">true</tt> if all arguments are <tt class="docutils literal">null</tt>.</p>
<dl class="docutils">
<dt><em>Availability</em>:</dt>
<dd>Available in MochiKit 1.3.1+</dd>
</dl>
</blockquote>
<p>
<a name="fn-isundefined"></a>
<a class="mochidef reference external" href="#fn-isundefined">isUndefined(obj[, ...])</a>:</p>
<blockquote>
<p>Returns <tt class="docutils literal">true</tt> if all arguments are undefined. Note that <tt class="docutils literal">null</tt>
values are NOT undefined in JavaScript (use
<a class="mochiref reference external" href="#fn-isundefinedornull">isUndefinedOrNull</a> for that).</p>
<dl class="docutils">
<dt><em>Availability</em>:</dt>
<dd>Available in MochiKit 1.3.1+</dd>
</dl>
</blockquote>
<p>
<a name="fn-isundefinedornull"></a>
<a class="mochidef reference external" href="#fn-isundefinedornull">isUndefinedOrNull(obj[, ...])</a>:</p>
<blockquote>
<p>Returns <tt class="docutils literal">true</tt> if all arguments are undefined or <tt class="docutils literal">null</tt></p>
<dl class="docutils">
<dt><em>Availability</em>:</dt>
<dd>Available in MochiKit 1.3.1+</dd>
</dl>
</blockquote>
<p>
<a name="fn-isvalue"></a>
<a class="mochidef reference external" href="#fn-isvalue">isValue(obj[, ...])</a>:</p>
<blockquote>
<p>Returns <tt class="docutils literal">true</tt> if all arguments are boolean, number or
string values (i.e. basic JavaScript values, not objects or
functions).</p>
<dl class="docutils">
<dt><em>Availability</em>:</dt>
<dd>Available in MochiKit 1.5+</dd>
</dl>
</blockquote>
<p>
<a name="fn-itemgetter"></a>
<a class="mochidef reference external" href="#fn-itemgetter">itemgetter(name)</a>:</p>
<blockquote>
<p>Returns a <tt class="docutils literal">function(obj)</tt> that returns <tt class="docutils literal">obj[name]</tt></p>
<dl class="docutils">
<dt><em>Availability</em>:</dt>
<dd>Available in MochiKit 1.3.1+</dd>
</dl>
</blockquote>
<p>
<a name="fn-items"></a>
<a class="mochidef reference external" href="#fn-items">items(obj)</a>:</p>
<blockquote>
<p>Return an <tt class="docutils literal">Array</tt> of <tt class="docutils literal">[propertyName, propertyValue]</tt> pairs for
the given <tt class="docutils literal">obj</tt> (in the order determined by <tt class="docutils literal">for propName in
obj</tt>).</p>
<dl class="docutils">
<dt><em>Availability</em>:</dt>
<dd>Available in MochiKit 1.3.1+</dd>
</dl>
</blockquote>
<p>
<a name="fn-keycomparator"></a>
<a class="mochidef reference external" href="#fn-keycomparator">keyComparator(key[, ...])</a>:</p>
<blockquote>
<p>A comparator factory that compares <tt class="docutils literal">a[key]</tt> with <tt class="docutils literal">b[key]</tt>.
e.g.:</p>
<pre class="literal-block">
var lst = [&quot;a&quot;, &quot;bbb&quot;, &quot;cc&quot;];
lst.sort(keyComparator(&quot;length&quot;));
assert( lst.toString() == &quot;a,cc,bbb&quot; );
</pre>
<dl class="docutils">
<dt><em>Availability</em>:</dt>
<dd>Available in MochiKit 1.3.1+</dd>
</dl>
</blockquote>
<p>
<a name="fn-keys"></a>
<a class="mochidef reference external" href="#fn-keys">keys(obj)</a>:</p>
<blockquote>
<p>Return an <tt class="docutils literal">Array</tt> of the property names of an object (in the
order determined by <tt class="docutils literal">for propName in obj</tt>).</p>
<dl class="docutils">
<dt><em>Availability</em>:</dt>
<dd>Available in MochiKit 1.3.1+</dd>
</dl>
</blockquote>
<p>
<a name="fn-listmax"></a>
<a class="mochidef reference external" href="#fn-listmax">listMax(lst)</a>:</p>
<blockquote>
<p>Return the largest element of an <tt class="docutils literal">Array</tt>-like object, as
determined by <a class="mochiref reference external" href="#fn-compare">compare</a>. This is a special form of
<a class="mochiref reference external" href="#fn-listminmax">listMinMax</a>, specifically
<a class="mochiref reference external" href="#fn-partial">partial(listMinMax, 1)</a>.</p>
<dl class="docutils">
<dt><em>Availability</em>:</dt>
<dd>Available in MochiKit 1.3.1+</dd>
</dl>
</blockquote>
<p>
<a name="fn-listmin"></a>
<a class="mochidef reference external" href="#fn-listmin">listMin(lst)</a>:</p>
<blockquote>
<p>Return the smallest element of an <tt class="docutils literal">Array</tt>-like object, as
determined by <a class="mochiref reference external" href="#fn-compare">compare</a>. This is a special form of
<a class="mochiref reference external" href="#fn-listminmax">listMinMax</a>, specifically
<a class="mochiref reference external" href="#fn-partial">partial(listMinMax, -1)</a>.</p>
<dl class="docutils">
<dt><em>Availability</em>:</dt>
<dd>Available in MochiKit 1.3.1+</dd>
</dl>
</blockquote>
<p>
<a name="fn-listminmax"></a>
<a class="mochidef reference external" href="#fn-listminmax">listMinMax(which, lst)</a>:</p>
<blockquote>
<p>If <tt class="docutils literal">which == <span class="pre">-1</span></tt> then it will return the smallest element of the
<tt class="docutils literal">Array</tt>-like <tt class="docutils literal">lst</tt>. This is also available as
<a class="mochiref reference external" href="#fn-listmin">listMin(lst)</a>.</p>
<p>If <tt class="docutils literal">which == 1</tt> then it will return the largest element of the
<tt class="docutils literal">Array</tt>-like <tt class="docutils literal">lst</tt>. This is also available as
<a class="mochiref reference external" href="#fn-listmax">listMax(list)</a>.</p>
<dl class="docutils">
<dt><em>Availability</em>:</dt>
<dd>Available in MochiKit 1.3.1+</dd>
</dl>
</blockquote>
<p>
<a name="fn-map"></a>
<a class="mochidef reference external" href="#fn-map">map(fn, lst[, ...])</a>:</p>
<blockquote>
<p>Return a new array composed of the results of <tt class="docutils literal">fn(x)</tt> for every
<tt class="docutils literal">x</tt> in <tt class="docutils literal">lst</tt>.</p>
<p>If <tt class="docutils literal">fn</tt> is <tt class="docutils literal">null</tt>, and only one sequence argument is given the
identity function is used.</p>
<blockquote>
<a class="mochiref reference external" href="#fn-map">map(null, lst)</a> -&gt; <tt class="docutils literal">lst.slice()</tt>;</blockquote>
<p>If <tt class="docutils literal">fn</tt> is not <tt class="docutils literal">null</tt> and more than one sequence argument is
given, then one element from each sequence is used to build the
argument list for <tt class="docutils literal">fn</tt>.</p>
<blockquote>
<dl class="docutils">
<dt><a class="mochiref reference external" href="#fn-map">map(fn, p, q, ...)</a></dt>
<dd>-&gt;  <tt class="docutils literal">[fn(p[0], q[0], <span class="pre">..),</span> fn(p[1], q[1], <span class="pre">...),</span> <span class="pre">...]</span></tt></dd>
</dl>
</blockquote>
<p>If <tt class="docutils literal">fn</tt> is <tt class="docutils literal">null</tt>, and more than one sequence is given as
arguments, then the <tt class="docutils literal">Array</tt> function is used.</p>
<blockquote>
<dl class="docutils">
<dt><a class="mochiref reference external" href="#fn-map">map(null, p, q, ...)</a></dt>
<dd>-&gt; <a class="mochiref reference external" href="Iter.html#fn-zip">MochiKit.Iter.zip(p, q, ...)</a>
-&gt; <tt class="docutils literal">[[p0, q0, <span class="pre">...],</span> [p1, q1, <span class="pre">...],</span> <span class="pre">...];</span></tt></dd>
</dl>
</blockquote>
<p>Since this is a common idiom, <a class="mochiref reference external" href="#fn-zip">zip(p, q, ...)</a>
is actually a shortcut for this.</p>
<dl class="docutils">
<dt><em>Availability</em>:</dt>
<dd>Available in MochiKit 1.3.1+</dd>
</dl>
</blockquote>
<p>
<a name="fn-mean"></a>
<a class="mochidef reference external" href="#fn-mean">mean(lst[, ...])</a>:</p>
<blockquote>
<p>Returns the arithmetic mean (average) of the argument list, or an array.
This function applies <a class="mochiref reference external" href="#fn-flattenarguments">flattenArguments()</a> to the argument list.</p>
<dl class="docutils">
<dt><em>Availability</em>:</dt>
<dd>Available in MochiKit 1.4+</dd>
</dl>
</blockquote>
<p>
<a name="fn-median"></a>
<a class="mochidef reference external" href="#fn-median">median(lst[, ...])</a>:</p>
<blockquote>
<p>Returns the median of the argument list, or an array. This function
applies <a class="mochiref reference external" href="#fn-flattenarguments">flattenArguments()</a> to the argument list.</p>
<dl class="docutils">
<dt><em>Availability</em>:</dt>
<dd>Available in MochiKit 1.4+</dd>
</dl>
</blockquote>
<p>
<a name="fn-merge"></a>
<a class="mochidef reference external" href="#fn-merge">merge(obj[, ...])</a>:</p>
<blockquote>
<p>Create a new instance of <tt class="docutils literal">Object</tt> that contains every property
from all given objects. If a property is defined on more than one
of the objects, the last property is used.</p>
<p>This is a special form of <a class="mochiref reference external" href="#fn-update">update(self, obj[, ...])</a>,
specifically, it is defined as <a class="mochiref reference external" href="#fn-partial">partial(update, null)</a>.</p>
<dl class="docutils">
<dt><em>Availability</em>:</dt>
<dd>Available in MochiKit 1.3.1+</dd>
</dl>
</blockquote>
<p>
<a name="fn-method"></a>
<a class="mochidef reference external" href="#fn-method">method(self, func, ...)</a>:</p>
<blockquote>
<p>Alternate form of <a class="mochiref reference external" href="#fn-bind">bind</a> that takes the object before
the function. These two calls are equivalent:</p>
<pre class="literal-block">
bind(&quot;method&quot;, myobject)
method(myobject, &quot;method&quot;)
</pre>
<dl class="docutils">
<dt><em>Availability</em>:</dt>
<dd>Available in MochiKit 1.3.1+</dd>
</dl>
</blockquote>
<p>
<a name="fn-methodcaller"></a>
<a class="mochidef reference external" href="#fn-methodcaller">methodcaller(name[, args...])</a>:</p>
<blockquote>
<p>Return a new function that calls a method on its argument,
for example:</p>
<pre class="literal-block">
lst = map(methodcaller(&quot;toLowerCase&quot;), [&quot;THIS&quot;, &quot;is&quot;, &quot;LoWeRCaSe&quot;]);
assert( lst.join(&quot; &quot;) == &quot;this is lowercase&quot; );
</pre>
<dl class="docutils">
<dt><em>Availability</em>:</dt>
<dd>Available in MochiKit 1.4+</dd>
</dl>
</blockquote>
<p>
<a name="fn-module"></a>
<a class="mochidef reference external" href="#fn-module">module(parent, name, version, deps=[])</a>:</p>
<blockquote>
<p>Creates a new <tt class="docutils literal">name</tt> module in a <tt class="docutils literal">parent</tt> namespace. This
function will create a new empty module object with <tt class="docutils literal">NAME</tt>,
<tt class="docutils literal">VERSION</tt>, <tt class="docutils literal">toString</tt> and <tt class="docutils literal">__repr__</tt> properties. It will
also verify that all the strings in <tt class="docutils literal">deps</tt> are defined in
<tt class="docutils literal">parent</tt>, or an error will be thrown.</p>
<dl class="docutils">
<dt><tt class="docutils literal">parent</tt>:</dt>
<dd>The parent module or namespace (object). Use <tt class="docutils literal">this</tt> or
<tt class="docutils literal">window</tt> to create a global module.</dd>
<dt><tt class="docutils literal">name</tt>:</dt>
<dd>The new module name.</dd>
<dt><tt class="docutils literal">version</tt>:</dt>
<dd>The module version string, e.g. &quot;1.5&quot;.</dd>
<dt><tt class="docutils literal">deps</tt>:</dt>
<dd>The array of module dependencies, as strings.</dd>
</dl>
<p>Example:</p>
<pre class="literal-block">
module(MochiKit, 'Iter', '1.5', ['Base']);
</pre>
<dl class="docutils">
<dt><em>Availability</em>:</dt>
<dd>Available in MochiKit 1.5+</dd>
</dl>
</blockquote>
<p>
<a name="fn-moduleexport"></a>
<a class="mochidef reference external" href="#fn-moduleexport">moduleExport(namespace, module/*, ...*/)</a>:</p>
<blockquote>
<p>Exports all symbols from one or more modules into <tt class="docutils literal">namespace</tt>.
This is similar to <a class="mochiref reference external" href="#fn-update">update(self, obj[, ...])</a>, except
for special handling of the <tt class="docutils literal">__export__</tt> flag, contained
sub-modules (exported recursively), and names starting with
<tt class="docutils literal">_</tt>.</p>
<p>All symbols can be exported to global variables:</p>
<pre class="literal-block">
MochiKit.Base.moduleExport(this, MochiKit);
</pre>
<p>Or a few selected modules can be moved to a shortened name:</p>
<pre class="literal-block">
var dom = MochiKit.Base.moduleExport({}, MochiKit.Dom, MochiKit.Style);
</pre>
<dl class="docutils">
<dt><em>Availability</em>:</dt>
<dd>Available in MochiKit 1.5+</dd>
</dl>
</blockquote>
<p>
<a name="fn-namefunctions"></a>
<a class="mochidef reference external" href="#fn-namefunctions">nameFunctions(namespace)</a>:</p>
<blockquote>
<p>Given a <tt class="docutils literal">namespace</tt> (object or function) with a <tt class="docutils literal">NAME</tt>
property, find all methods in it and give them nice <tt class="docutils literal">NAME</tt>
properties too (for use with <a class="mochiref reference external" href="#fn-repr">repr</a>). e.g.:</p>
<pre class="literal-block">
namespace = {
    NAME: &quot;Awesome&quot;,
    Dude: function () {}
}
nameFunctions(namespace);
assert( namespace.Dude.NAME == 'Awesome.Dude' );
</pre>
<dl class="docutils">
<dt><em>Availability</em>:</dt>
<dd>Available in MochiKit 1.3.1+</dd>
</dl>
</blockquote>
<p>
<a name="fn-noop"></a>
<a class="mochidef reference external" href="#fn-noop">noop()</a>:</p>
<blockquote>
<p>A function that performs no operation. Use this where you would
otherwise use <tt class="docutils literal">(function () {})</tt> in order to avoid Internet
Explorer cyclic garbage leakage.</p>
<dl class="docutils">
<dt><em>Availability</em>:</dt>
<dd>Available in MochiKit 1.4</dd>
</dl>
</blockquote>
<p>
<a name="fn-objequal"></a>
<a class="mochidef reference external" href="#fn-objequal">objEqual(a, b)</a>:</p>
<blockquote>
<p>Return <tt class="docutils literal">true</tt> if <tt class="docutils literal">compare(a, b) == 0</tt></p>
<dl class="docutils">
<dt><em>Availability</em>:</dt>
<dd>Available in MochiKit 1.3.1+</dd>
</dl>
</blockquote>
<p>
<a name="fn-nodewalk"></a>
<a class="mochidef reference external" href="#fn-nodewalk">nodeWalk(node, visitor)</a>:</p>
<blockquote>
<p>Non-recursive generic node walking function (e.g. for a DOM).</p>
<p>The walk order for nodeWalk is breadth first, meaning that all
siblings will be visited before any children.</p>
<dl class="docutils">
<dt><tt class="docutils literal">node</tt>:</dt>
<dd>The initial node to be searched.</dd>
<dt><tt class="docutils literal">visitor</tt>:</dt>
<dd>The visitor function, will be called as <tt class="docutils literal">visitor(node)</tt>, and
should return an <tt class="docutils literal">Array</tt>-like of nodes to be searched next
(e.g. <tt class="docutils literal">node.childNodes</tt>).  Leaf nodes may return <tt class="docutils literal">null</tt> or
<tt class="docutils literal">undefined</tt>.</dd>
<dt><em>Availability</em>:</dt>
<dd>Available in MochiKit 1.3.1+</dd>
</dl>
</blockquote>
<p>
<a name="fn-objmax"></a>
<a class="mochidef reference external" href="#fn-objmax">objMax(obj[, ...])</a>:</p>
<blockquote>
<p>Return the maximum object according to <a class="mochiref reference external" href="#fn-compare">compare</a> out of
the given arguments. This is similar to <a class="mochiref reference external" href="#fn-listmax">listMax</a>,
except is uses the arguments instead of a given <tt class="docutils literal">Array</tt>-like.</p>
<dl class="docutils">
<dt><em>Availability</em>:</dt>
<dd>Available in MochiKit 1.3.1+</dd>
</dl>
</blockquote>
<p>
<a name="fn-objmin"></a>
<a class="mochidef reference external" href="#fn-objmin">objMin(obj[, ...])</a>:</p>
<blockquote>
<p>Return the minimum object according to <a class="mochiref reference external" href="#fn-compare">compare</a> out of
the given arguments. This is similar to <a class="mochiref reference external" href="#fn-listmin">listMin</a>,
except it uses the arguments instead of a given <tt class="docutils literal">Array</tt>-like.</p>
<dl class="docutils">
<dt><em>Availability</em>:</dt>
<dd>Available in MochiKit 1.3.1+</dd>
</dl>
</blockquote>
<p>
<a name="fn-operator"></a>
<a class="mochidef reference external" href="#fn-operator">operator</a>:</p>
<blockquote>
<p>A table of JavaScript's operators for usage with <a class="mochiref reference external" href="#fn-map">map</a>,
<a class="mochiref reference external" href="#fn-filter">filter</a>, etc.</p>
<p>Unary Logic Operators:</p>
<blockquote>
<table border="1" class="docutils">
<colgroup>
<col width="31%" />
<col width="40%" />
<col width="29%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">Operator</th>
<th class="head">Implementation</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr><td><tt class="docutils literal">truth(a)</tt></td>
<td><tt class="docutils literal">!!a</tt></td>
<td>Logical truth</td>
</tr>
<tr><td><tt class="docutils literal">lognot(a)</tt></td>
<td><tt class="docutils literal">!a</tt></td>
<td>Logical not</td>
</tr>
<tr><td><tt class="docutils literal">identity(a)</tt></td>
<td><tt class="docutils literal">a</tt></td>
<td>Logical identity</td>
</tr>
</tbody>
</table>
</blockquote>
<p>Unary Math Operators:</p>
<blockquote>
<table border="1" class="docutils">
<colgroup>
<col width="33%" />
<col width="43%" />
<col width="25%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">Operator</th>
<th class="head">Implementation</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr><td><tt class="docutils literal">not(a)</tt></td>
<td><tt class="docutils literal">~a</tt></td>
<td>Bitwise not</td>
</tr>
<tr><td><tt class="docutils literal">neg(a)</tt></td>
<td><tt class="docutils literal"><span class="pre">-a</span></tt></td>
<td>Negation</td>
</tr>
</tbody>
</table>
</blockquote>
<p>Binary Operators:</p>
<blockquote>
<table border="1" class="docutils">
<colgroup>
<col width="28%" />
<col width="28%" />
<col width="45%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">Operator</th>
<th class="head">Implementation</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr><td><tt class="docutils literal">add(a, b)</tt></td>
<td><tt class="docutils literal">a + b</tt></td>
<td>Addition</td>
</tr>
<tr><td><tt class="docutils literal">sub(a, b)</tt></td>
<td><tt class="docutils literal">a - b</tt></td>
<td>Subtraction</td>
</tr>
<tr><td><tt class="docutils literal">div(a, b)</tt></td>
<td><tt class="docutils literal">a / b</tt></td>
<td>Division</td>
</tr>
<tr><td><tt class="docutils literal">mod(a, b)</tt></td>
<td><tt class="docutils literal">a % b</tt></td>
<td>Modulus</td>
</tr>
<tr><td><tt class="docutils literal">mul(a, b)</tt></td>
<td><tt class="docutils literal">a * b</tt></td>
<td>Multiplication</td>
</tr>
<tr><td><tt class="docutils literal">and(a, b)</tt></td>
<td><tt class="docutils literal">a &amp; b</tt></td>
<td>Bitwise and</td>
</tr>
<tr><td><tt class="docutils literal">or(a, b)</tt></td>
<td><tt class="docutils literal">a | b</tt></td>
<td>Bitwise or</td>
</tr>
<tr><td><tt class="docutils literal">xor(a, b)</tt></td>
<td><tt class="docutils literal">a ^ b</tt></td>
<td>Bitwise exclusive or</td>
</tr>
<tr><td><tt class="docutils literal">lshift(a, b)</tt></td>
<td><tt class="docutils literal">a &lt;&lt; b</tt></td>
<td>Bitwise left shift</td>
</tr>
<tr><td><tt class="docutils literal">rshift(a, b)</tt></td>
<td><tt class="docutils literal">a &gt;&gt; b</tt></td>
<td>Bitwise signed right shift</td>
</tr>
<tr><td><tt class="docutils literal">zrshift(a, b)</tt></td>
<td><tt class="docutils literal">a &gt;&gt;&gt; b</tt></td>
<td>Bitwise unsigned right shift</td>
</tr>
</tbody>
</table>
</blockquote>
<p>Built-in Comparators:</p>
<blockquote>
<table border="1" class="docutils">
<colgroup>
<col width="25%" />
<col width="31%" />
<col width="44%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">Operator</th>
<th class="head">Implementation</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr><td><tt class="docutils literal">eq(a, b)</tt></td>
<td><tt class="docutils literal">a == b</tt></td>
<td>Equals</td>
</tr>
<tr><td><tt class="docutils literal">ne(a, b)</tt></td>
<td><tt class="docutils literal">a != b</tt></td>
<td>Not equals</td>
</tr>
<tr><td><tt class="docutils literal">gt(a, b)</tt></td>
<td><tt class="docutils literal">a &gt; b</tt></td>
<td>Greater than</td>
</tr>
<tr><td><tt class="docutils literal">ge(a, b)</tt></td>
<td><tt class="docutils literal">a &gt;= b</tt></td>
<td>Greater than or equal to</td>
</tr>
<tr><td><tt class="docutils literal">lt(a, b)</tt></td>
<td><tt class="docutils literal">a &lt; b</tt></td>
<td>Less than</td>
</tr>
<tr><td><tt class="docutils literal">le(a, b)</tt></td>
<td><tt class="docutils literal">a &lt;= b</tt></td>
<td>Less than or equal to</td>
</tr>
</tbody>
</table>
</blockquote>
<p>Strict Built-in Comparators:</p>
<blockquote>
<table border="1" class="docutils">
<colgroup>
<col width="25%" />
<col width="31%" />
<col width="44%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">Operator</th>
<th class="head">Implementation</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr><td><tt class="docutils literal">seq(a, b)</tt></td>
<td><tt class="docutils literal">a === b</tt></td>
<td>Strict equals</td>
</tr>
<tr><td><tt class="docutils literal">sne(a, b)</tt></td>
<td><tt class="docutils literal">a !== b</tt></td>
<td>Strict not equals</td>
</tr>
</tbody>
</table>
</blockquote>
<p>Extended Comparators (uses <a class="mochiref reference external" href="#fn-compare">compare</a>):</p>
<blockquote>
<table border="1" class="docutils">
<colgroup>
<col width="22%" />
<col width="39%" />
<col width="39%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">Operator</th>
<th class="head">Implementation</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr><td><tt class="docutils literal">ceq(a, b)</tt></td>
<td><tt class="docutils literal">compare(a, b) == 0</tt></td>
<td>Equals</td>
</tr>
<tr><td><tt class="docutils literal">cne(a, b)</tt></td>
<td><tt class="docutils literal">compare(a, b) != 0</tt></td>
<td>Not equals</td>
</tr>
<tr><td><tt class="docutils literal">cgt(a, b)</tt></td>
<td><tt class="docutils literal">compare(a, b) == 1</tt></td>
<td>Greater than</td>
</tr>
<tr><td><tt class="docutils literal">cge(a, b)</tt></td>
<td><tt class="docutils literal">compare(a, b) != <span class="pre">-1</span></tt></td>
<td>Greater than or equal to</td>
</tr>
<tr><td><tt class="docutils literal">clt(a, b)</tt></td>
<td><tt class="docutils literal">compare(a, b) == <span class="pre">-1</span></tt></td>
<td>Less than</td>
</tr>
<tr><td><tt class="docutils literal">cle(a, b)</tt></td>
<td><tt class="docutils literal">compare(a, b) != 1</tt></td>
<td>Less than or equal to</td>
</tr>
</tbody>
</table>
</blockquote>
<p>Binary Logical Operators:</p>
<blockquote>
<table border="1" class="docutils">
<colgroup>
<col width="33%" />
<col width="28%" />
<col width="39%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">Operator</th>
<th class="head">Implementation</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr><td><tt class="docutils literal">logand(a, b)</tt></td>
<td><tt class="docutils literal">a &amp;&amp; b</tt></td>
<td>Logical and</td>
</tr>
<tr><td><tt class="docutils literal">logor(a, b)</tt></td>
<td><tt class="docutils literal">a || b</tt></td>
<td>Logical or</td>
</tr>
<tr><td><tt class="docutils literal">contains(a, b)</tt></td>
<td><tt class="docutils literal">b in a</tt></td>
<td>Has property (note order)</td>
</tr>
</tbody>
</table>
</blockquote>
<dl class="docutils">
<dt><em>Availability</em>:</dt>
<dd>Available in MochiKit 1.3.1+</dd>
</dl>
</blockquote>
<p>
<a name="fn-parsequerystring"></a>
<a class="mochidef reference external" href="#fn-parsequerystring">parseQueryString(encodedString[, useArrays=false])</a>:</p>
<blockquote>
<p>Parse a name=value pair URL query string into an object with a
property for each pair. e.g.:</p>
<pre class="literal-block">
var args = parseQueryString(&quot;foo=value%20one&amp;bar=two&quot;);
assert( args.foo == &quot;value one&quot; &amp;&amp; args.bar == &quot;two&quot; );
</pre>
<p>If you expect that the query string will reuse the same name, then
give <tt class="docutils literal">true</tt> as a second argument, which will use arrays to store
the values. e.g.:</p>
<pre class="literal-block">
var args = parseQueryString(&quot;foo=one&amp;foo=two&quot;, true);
assert( args.foo[0] == &quot;one&quot; &amp;&amp; args.foo[1] == &quot;two&quot; );
</pre>
<dl class="docutils">
<dt><em>Availability</em>:</dt>
<dd>Available in MochiKit 1.3.1+</dd>
</dl>
</blockquote>
<p>
<a name="fn-partial"></a>
<a class="mochidef reference external" href="#fn-partial">partial(func, arg[, ...])</a>:</p>
<blockquote>
<p>Return a partially applied function, e.g.:</p>
<pre class="literal-block">
addNumbers = function (a, b) {
    return a + b;
}

addOne = partial(addNumbers, 1);

assert(addOne(2) == 3);
</pre>
<p><a class="mochiref reference external" href="#fn-partial">partial</a> is a special form of <a class="mochiref reference external" href="#fn-bind">bind</a> that
does not alter the bound <tt class="docutils literal">self</tt> (if any). It is equivalent to
calling:</p>
<pre class="literal-block">
bind(func, undefined, arg[, ...]);
</pre>
<p>See the documentation for <a class="mochiref reference external" href="#fn-bind">bind</a> for more details about
this facility.</p>
<p>This could be used to implement, but is NOT currying.</p>
<dl class="docutils">
<dt><em>Availability</em>:</dt>
<dd>Available in MochiKit 1.3.1+</dd>
</dl>
</blockquote>
<p>
<a name="fn-querystring"></a>
<a class="mochidef reference external" href="#fn-querystring">queryString(names, values)</a>:</p>
<blockquote>
<p>Creates a URL query string from a pair of <tt class="docutils literal">Array</tt>-like objects
representing <tt class="docutils literal">names</tt> and <tt class="docutils literal">values</tt>. Each name=value pair will
be URL encoded by <a class="mochiref reference external" href="#fn-urlencode">urlEncode</a>. name=value pairs with a
value of <tt class="docutils literal">undefined</tt> or <tt class="docutils literal">null</tt> will be skipped. e.g.:</p>
<pre class="literal-block">
var keys = [&quot;foo&quot;, &quot;bar&quot;];
var values = [&quot;value one&quot;, &quot;two&quot;];
assert( queryString(keys, values) == &quot;foo=value%20one&amp;bar=two&quot; );
</pre>
<dl class="docutils">
<dt>Alternate form 1:</dt>
<dd><a class="mochiref reference external" href="#fn-querystring">queryString(domElement)</a></dd>
</dl>
<p>If <a class="mochiref reference external" href="DOM.html">MochiKit.DOM</a> is loaded, one argument is given, and
that argument is either a string or has a <tt class="docutils literal">nodeType</tt> property
greater than zero, then <tt class="docutils literal">names</tt> and <tt class="docutils literal">values</tt> will be the
result of <a class="mochiref reference external" href="DOM.html#fn-formcontents">MochiKit.DOM.formContents(domElement)</a>.</p>
<dl class="docutils">
<dt>Alternate form 2:</dt>
<dd><a class="mochiref reference external" href="#fn-querystring">queryString({name: value, ...})</a></dd>
</dl>
<p>Note that when using the alternate form, the order of the
name=value pairs in the resultant query string is dependent on how
the particular JavaScript implementation handles <tt class="docutils literal">for <span class="pre">(..in..)</span></tt>
property enumeration.</p>
<p>When using the second alternate form, name=value pairs with
<tt class="docutils literal">typeof(value) == &quot;function&quot;</tt> are ignored. This is a workaround
for the case where a poorly designed library has modified
<tt class="docutils literal">Object.prototype</tt> and inserted &quot;convenience functions&quot;.</p>
<p>Values that are Array-like will be expanded as if they were multiply
defined HTML elements. For example:</p>
<pre class="literal-block">
assert( queryString({a: [1,2]}) === &quot;a=1&amp;a=2&quot; );
</pre>
<dl class="docutils">
<dt>Alternate form 2 (MochiKit 1.4+):</dt>
<dd><a class="mochiref reference external" href="#fn-querystring">queryString([names, values])</a></dd>
</dl>
<p>This form behaves identically to <a class="mochiref reference external" href="#fn-querystring">queryString(names, values)</a>,
except it takes both arguments as a single Array. This mirrors the
return value of <a class="mochiref reference external" href="DOM.html#fn-formcontents">MochiKit.DOM.formContents</a>.</p>
<dl class="docutils">
<dt><em>Availability</em>:</dt>
<dd>Available in MochiKit 1.3.1+</dd>
</dl>
</blockquote>
<p>
<a name="fn-registercomparator"></a>
<a class="mochidef reference external" href="#fn-registercomparator">registerComparator(name, check, comparator[, override])</a>:</p>
<blockquote>
<p>Register a comparator for use with <a class="mochiref reference external" href="#fn-compare">compare</a>.</p>
<dl class="docutils">
<dt><tt class="docutils literal">name</tt>:</dt>
<dd>unique identifier describing the comparator.</dd>
<dt><tt class="docutils literal">check</tt>:</dt>
<dd><tt class="docutils literal">function(a, b)</tt> that returns <tt class="docutils literal">true</tt> if <tt class="docutils literal">a</tt> and <tt class="docutils literal">b</tt>
can be compared with <tt class="docutils literal">comparator</tt>.</dd>
<dt><tt class="docutils literal">comparator</tt>:</dt>
<dd><p class="first"><tt class="docutils literal">function(a, b)</tt> that returns:</p>
<table border="1" class="docutils">
<colgroup>
<col width="39%" />
<col width="61%" />
</colgroup>
<tbody valign="top">
<tr><td>Value</td>
<td>Condition</td>
</tr>
<tr><td>0</td>
<td>a == b</td>
</tr>
<tr><td>1</td>
<td>a &gt; b</td>
</tr>
<tr><td>-1</td>
<td>a &lt; b</td>
</tr>
</tbody>
</table>
<p class="last"><tt class="docutils literal">comparator</tt> is guaranteed to only be called if <tt class="docutils literal">check(a,
b)</tt> returns a <tt class="docutils literal">true</tt> value.</p>
</dd>
<dt><tt class="docutils literal">override</tt>:</dt>
<dd>if <tt class="docutils literal">true</tt>, then this will be made the highest precedence
comparator.  Otherwise, the lowest.</dd>
<dt><em>Availability</em>:</dt>
<dd>Available in MochiKit 1.3.1+</dd>
</dl>
</blockquote>
<p>
<a name="fn-registerjson"></a>
<a class="mochidef reference external" href="#fn-registerjson">registerJSON(name, check, simplifier[, override])</a>:</p>
<blockquote>
<p>Register a simplifier function for use with
<a class="mochiref reference external" href="#fn-serializejson">serializeJSON</a>.</p>
<dl class="docutils">
<dt><tt class="docutils literal">name</tt>:</dt>
<dd>unique identifier describing the serialization.</dd>
<dt><tt class="docutils literal">check</tt>:</dt>
<dd><tt class="docutils literal">function(obj)</tt> that returns <tt class="docutils literal">true</tt> if <tt class="docutils literal">obj</tt> can
can be simplified for serialization by <tt class="docutils literal">simplifier</tt>.</dd>
<dt><tt class="docutils literal">simplifier</tt>:</dt>
<dd><p class="first"><tt class="docutils literal">function(obj)</tt> that returns a simpler object that can be
further serialized by <a class="mochiref reference external" href="#fn-serializejson">serializeJSON</a>. For example,
you could simplify <tt class="docutils literal">Date</tt>-like objects to ISO 8601 timestamp
strings with the following simplifier:</p>
<pre class="literal-block">
var simplifyDateAsISO = function (obj) {
    return toISOTimestamp(obj, true);
};
registerJSON(&quot;DateLike&quot;, isDateLike, simplifyDateAsISO);
</pre>
<p class="last"><tt class="docutils literal">simplifier</tt> is guaranteed to only be called if
<tt class="docutils literal">check(obj)</tt> returns a <tt class="docutils literal">true</tt> value.</p>
</dd>
<dt><tt class="docutils literal">override</tt>:</dt>
<dd>if <tt class="docutils literal">true</tt>, then this will be made the highest precedence
serialization. Otherwise, the lowest.</dd>
<dt><em>Availability</em>:</dt>
<dd>Available in MochiKit 1.3.1+</dd>
</dl>
</blockquote>
<p>
<a name="fn-registerrepr"></a>
<a class="mochidef reference external" href="#fn-registerrepr">registerRepr(name, check, wrap[, override])</a>:</p>
<blockquote>
<p>Register a programmer representation function.  <a class="mochiref reference external" href="#fn-repr">repr</a>
functions should take one argument and return a string
representation of it suitable for developers, primarily used when
debugging.</p>
<p>If <tt class="docutils literal">override</tt> is given, it is used as the highest priority repr,
otherwise it will be used as the lowest.</p>
<dl class="docutils">
<dt><em>Availability</em>:</dt>
<dd>Available in MochiKit 1.3.1+</dd>
</dl>
</blockquote>
<p>
<a name="fn-repr"></a>
<a class="mochidef reference external" href="#fn-repr">repr(obj)</a>:</p>
<blockquote>
<p>Return a programmer representation for <tt class="docutils literal">obj</tt>. See the
<a class="reference internal" href="#programmer-representation">Programmer Representation</a> overview for more information about
this function.</p>
<dl class="docutils">
<dt><em>Availability</em>:</dt>
<dd>Available in MochiKit 1.3.1+</dd>
</dl>
</blockquote>
<p>
<a name="fn-reversekeycomparator"></a>
<a class="mochidef reference external" href="#fn-reversekeycomparator">reverseKeyComparator(key)</a>:</p>
<blockquote>
<p>A comparator factory that compares <tt class="docutils literal">a[key]</tt> with <tt class="docutils literal">b[key]</tt> in
reverse.  e.g.:</p>
<pre class="literal-block">
var lst = [&quot;a&quot;, &quot;bbb&quot;, &quot;cc&quot;];
lst.sort(reverseKeyComparator(&quot;length&quot;));
assert(lst.toString() == &quot;bbb,cc,a&quot;);
</pre>
<dl class="docutils">
<dt><em>Availability</em>:</dt>
<dd>Available in MochiKit 1.3.1+</dd>
</dl>
</blockquote>
<p>
<a name="fn-serializejson"></a>
<a class="mochidef reference external" href="#fn-serializejson">serializeJSON(anObject)</a>:</p>
<blockquote>
<p>Serialize <tt class="docutils literal">anObject</tt> in the JSON <a class="footnote-reference" href="#id7" id="id6">[1]</a> format, see <a class="reference internal" href="#json-serialization">JSON
Serialization</a> for the coercion rules. For unserializable objects
(functions that do not have an adapter, <tt class="docutils literal">toJSON</tt> method,
<tt class="docutils literal">__json__</tt> method, or <tt class="docutils literal">json</tt> method), this will return
<tt class="docutils literal">undefined</tt>.</p>
<p>For those familiar with Python, JSON is similar in scope to
pickle, but it can not handle recursive object graphs.</p>
<dl class="docutils">
<dt><em>Availability</em>:</dt>
<dd>Available in MochiKit 1.3.1+</dd>
</dl>
</blockquote>
<p>
<a name="fn-setdefault"></a>
<a class="mochidef reference external" href="#fn-setdefault">setdefault(self, obj[, ...])</a>:</p>
<blockquote>
<p>Mutate <tt class="docutils literal">self</tt> by adding all properties from other object(s) that
it does not already have set.</p>
<p>If <tt class="docutils literal">self</tt> is <tt class="docutils literal">null</tt>, a new <tt class="docutils literal">Object</tt> instance will be created
and returned.</p>
<p>This mutates <em>and returns</em> <tt class="docutils literal">self</tt>, be warned.</p>
<dl class="docutils">
<dt><em>Availability</em>:</dt>
<dd>Available in MochiKit 1.3.1+</dd>
</dl>
</blockquote>
<p>
<a name="fn-typematcher"></a>
<a class="mochidef reference external" href="#fn-typematcher">typeMatcher(typ[, ...])</a>:</p>
<blockquote>
<p>Given a set of types (as string arguments), returns a
<tt class="docutils literal">function(obj[, <span class="pre">...])</span></tt> that will return <tt class="docutils literal">true</tt> if the types of
the given arguments are all members of that set.</p>
<dl class="docutils">
<dt><em>Availability</em>:</dt>
<dd>Available in MochiKit 1.3.1+</dd>
</dl>
</blockquote>
<p>
<a name="fn-update"></a>
<a class="mochidef reference external" href="#fn-update">update(self, obj[, ...])</a>:</p>
<blockquote>
<p>Mutate <tt class="docutils literal">self</tt> by replacing its key:value pairs with those from
other object(s). Key:value pairs from later objects will overwrite
those from earlier objects.</p>
<p>If <tt class="docutils literal">self</tt> is <tt class="docutils literal">null</tt>, a new <tt class="docutils literal">Object</tt> instance will be created
and returned.</p>
<p>This mutates <em>and returns</em> <tt class="docutils literal">self</tt>, be warned.</p>
<p>A version of this function that creates a new object is available
as <a class="mochiref reference external" href="#fn-merge">merge(a, b[, ...])</a></p>
<dl class="docutils">
<dt><em>Availability</em>:</dt>
<dd>Available in MochiKit 1.3.1+</dd>
</dl>
</blockquote>
<p>
<a name="fn-updatetree"></a>
<a class="mochidef reference external" href="#fn-updatetree">updatetree(self, obj[, ...])</a>:</p>
<blockquote>
<p>Mutate <tt class="docutils literal">self</tt> by replacing its key:value pairs with those from
other object(s). If a given key has an object value in both
<tt class="docutils literal">self</tt> and <tt class="docutils literal">obj</tt>, then this function will be called
recursively, updating instead of replacing that object.</p>
<p>If <tt class="docutils literal">self</tt> is <tt class="docutils literal">null</tt>, a new <tt class="docutils literal">Object</tt> instance will be created
and returned.</p>
<p>This mutates <em>and returns</em> <tt class="docutils literal">self</tt>, be warned.</p>
<dl class="docutils">
<dt><em>Availability</em>:</dt>
<dd>Available in MochiKit 1.3.1+</dd>
</dl>
</blockquote>
<p>
<a name="fn-urlencode"></a>
<a class="mochidef reference external" href="#fn-urlencode">urlEncode(unencoded)</a>:</p>
<blockquote>
<p>Converts <tt class="docutils literal">unencoded</tt> into a URL-encoded string. In this
implementation, spaces are converted to %20 instead of &quot;+&quot;. e.g.:</p>
<pre class="literal-block">
assert( URLencode(&quot;1+2=2&quot;) == &quot;1%2B2%3D2&quot;);
</pre>
<dl class="docutils">
<dt><em>Availability</em>:</dt>
<dd>Available in MochiKit 1.3.1+</dd>
</dl>
</blockquote>
<p>
<a name="fn-values"></a>
<a class="mochidef reference external" href="#fn-values">values(obj)</a>:</p>
<blockquote>
<p>Return an <tt class="docutils literal">Array</tt> of the property values of an object (in the
order determined by <tt class="docutils literal">for propName in obj</tt>).</p>
<dl class="docutils">
<dt><em>Availability</em>:</dt>
<dd>Available in MochiKit 1.4+</dd>
</dl>
</blockquote>
<p>
<a name="fn-xfilter"></a>
<a class="mochidef reference external" href="#fn-xfilter">xfilter(fn, obj[, ...])</a>:</p>
<blockquote>
<p>Returns a new <tt class="docutils literal">Array</tt> composed of the arguments where
<tt class="docutils literal">fn(obj)</tt> returns a true value.</p>
<p>If <tt class="docutils literal">fn</tt> is <tt class="docutils literal">null</tt>, <tt class="docutils literal">operator.truth</tt> will be used.</p>
<dl class="docutils">
<dt><em>Availability</em>:</dt>
<dd>Available in MochiKit 1.3.1+</dd>
</dl>
</blockquote>
<p>
<a name="fn-xmap"></a>
<a class="mochidef reference external" href="#fn-xmap">xmap(fn, obj[, ...)</a>:</p>
<blockquote>
<p>Return a new <tt class="docutils literal">Array</tt> composed of <tt class="docutils literal">fn(obj)</tt> for every <tt class="docutils literal">obj</tt>
given as an argument.</p>
<p>If <tt class="docutils literal">fn</tt> is <tt class="docutils literal">null</tt>, <tt class="docutils literal">operator.identity</tt> is used.</p>
<dl class="docutils">
<dt><em>Availability</em>:</dt>
<dd>Available in MochiKit 1.3.1+</dd>
</dl>
</blockquote>
<p>
<a name="fn-zip"></a>
<a class="mochidef reference external" href="#fn-zip">zip(p, q, ...)</a>:</p>
<blockquote>
<p>Returns an array where the n-th element is an array of the n-th
elements from each of the arrays p, q, ...</p>
<p>This is equivalent to calling <a class="mochiref reference external" href="#fn-map">map(fn, p, q, ...)</a> with
<tt class="docutils literal">null</tt> as the first argument.</p>
<blockquote>
<dl class="docutils">
<dt><a class="mochiref reference external" href="#fn-zip">zip(p, q, ...)</a></dt>
<dd>-&gt; <a class="mochiref reference external" href="#fn-map">map(null, p, q, ...)</a>
-&gt; <tt class="docutils literal">[[p0, q0, <span class="pre">...],</span> [p1, q1, <span class="pre">...],</span> <span class="pre">...];</span></tt></dd>
</dl>
</blockquote>
<dl class="docutils">
<dt><em>Availability</em>:</dt>
<dd>Available in MochiKit 1.3.1+</dd>
</dl>
</blockquote>
</div>
</div>
<div class="section" id="see-also">
<h1>See Also</h1>
<table class="docutils footnote" frame="void" id="id7" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[1]</td><td><em>(<a class="fn-backref" href="#id1">1</a>, <a class="fn-backref" href="#id2">2</a>, <a class="fn-backref" href="#id4">3</a>, <a class="fn-backref" href="#id5">4</a>, <a class="fn-backref" href="#id6">5</a>)</em> JSON, JavaScript Object Notation: <a class="reference external" href="http://json.org/">http://json.org/</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id8" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id3">[2]</a></td><td>Python's itertools
module: <a class="reference external" href="http://docs.python.org/lib/module-itertools.html">http://docs.python.org/lib/module-itertools.html</a></td></tr>
</tbody>
</table>
</div>
<div class="section" id="authors">
<h1>Authors</h1>
<ul class="simple">
<li>Bob Ippolito &lt;<a class="reference external" href="mailto:bob&#64;redivi.com">bob&#64;redivi.com</a>&gt;</li>
</ul>
</div>
<div class="section" id="copyright">
<h1>Copyright</h1>
<p>Copyright 2005 Bob Ippolito &lt;<a class="reference external" href="mailto:bob&#64;redivi.com">bob&#64;redivi.com</a>&gt;. This program is
dual-licensed free software; you can redistribute it and/or modify it
under the terms of the <a class="reference external" href="http://www.opensource.org/licenses/mit-license.php">MIT License</a> or the <a class="reference external" href="http://www.opensource.org/licenses/afl-2.1.php">Academic Free License
v2.1</a>.</p>
</div>
</div>

</body>
</html>
