<?xml version="1.0" encoding="utf8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf8" />
<meta name="generator" content="Docutils 0.3.10: http://docutils.sourceforge.net/" />
<title>MochiKit.Base</title>
</head>
<body>
<div class="document" id="mochikit-base">
<h1 class="title">MochiKit.Base</h1>
<!-- -*- mode: rst -*- -->
<div class="section" id="errors">
<h1><a name="errors">Errors</a></h1>
<dl class="docutils">
<dt>NamedError:</dt>
<dd>Used to create new errors (e.g. NotFound)</dd>
<dt>NotFound:</dt>
<dd>A singleton error raised when no suitable adapter is found</dd>
</dl>
</div>
<div class="section" id="constructors">
<h1><a name="constructors">Constructors</a></h1>
<dl class="docutils">
<dt>AdapterRegistry:</dt>
<dd><p class="first">A registry to facilitate adaptation.</p>
<p class="last">All check/wrap functions in this registry should be of the same arity.</p>
</dd>
<dt>AdapterRegistry.prototype.register(name, check, wrap[, override]):</dt>
<dd><p class="first">The check function should return true if the given arguments are
appropriate for the wrap function.</p>
<p class="last">If override is given and true, the check function will be given
highest priority.  Otherwise, it will be the lowest priority
adapter.</p>
</dd>
<dt>AdapterRegistry.prototype.match(obj[, ...]):</dt>
<dd><p class="first">Find an adapter for the given arguments.</p>
<p class="last">If no suitable adapter is found, throws NotFound.</p>
</dd>
<dt>AdapterRegistry.prototype.unregister(name):</dt>
<dd>Remove a named adapter from the registry</dd>
</dl>
</div>
<div class="section" id="functions">
<h1><a name="functions">Functions</a></h1>
<dl class="docutils">
<dt>extend(self, obj[, skip]):</dt>
<dd><p class="first">Mutate an array by extending it with an array-like obj,
starting with the &quot;skip&quot; index of obj.  If null is given
as the initial array, a new one will be created.</p>
<p class="last">This mutates <em>and returns</em> the given array, be warned.</p>
</dd>
<dt>update(self, obj[, ...]):</dt>
<dd><p class="first">Mutate an object by replacing its key:value pairs with those
from other object(s).  Key:value pairs from later objects will
overwrite those from earlier objects.</p>
<p>If null is given as the initial object, a new one will be created.</p>
<p>This mutates <em>and returns</em> the given object, be warned.</p>
<p class="last">A version of this function that creates a new object is available
as merge(o1, o2, ...)</p>
</dd>
<dt>setdefault(self, obj[, ...]):</dt>
<dd><p class="first">Mutate an object by replacing its key:value pairs with those
from other object(s) IF they are not already set on the initial
object.</p>
<p>If null is given as the initial object, a new one will be created.</p>
<p class="last">This mutates <em>and returns</em> the given object, be warned.</p>
</dd>
<dt>keys(obj):</dt>
<dd>Return an array of the property names of an object
(in no particular order).</dd>
<dt>items(obj):</dt>
<dd>Return an array of [propertyName, propertyValue] pairs for an
object (in no particular order).</dd>
<dt>operator:</dt>
<dd><p class="first">A table of JavaScript's operators for usage with map, filter, etc.</p>
<p>Unary Logic Operators:</p>
<table border="1" class="docutils">
<colgroup>
<col width="23%" />
<col width="32%" />
<col width="45%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">Operator</th>
<th class="head">Implementation</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>truth(a)</td>
<td>!!a</td>
<td>Logical truth</td>
</tr>
<tr><td>lognot(a)</td>
<td>!a</td>
<td>Logical not</td>
</tr>
<tr><td>identity(a)</td>
<td>a</td>
<td>Logical identity</td>
</tr>
</tbody>
</table>
<p>Unary Math Operators:</p>
<table border="1" class="docutils">
<colgroup>
<col width="23%" />
<col width="32%" />
<col width="45%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">Operator</th>
<th class="head">Implementation</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>not(a)</td>
<td>~a</td>
<td>Bitwise not</td>
</tr>
<tr><td>neg(a)</td>
<td>-a</td>
<td>Negation</td>
</tr>
</tbody>
</table>
<p>Binary Operators:</p>
<table border="1" class="docutils">
<colgroup>
<col width="23%" />
<col width="32%" />
<col width="45%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">Operator</th>
<th class="head">Implementation</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>add(a, b)</td>
<td>a + b</td>
<td>Addition</td>
</tr>
<tr><td>div(a, b)</td>
<td>a / b</td>
<td>Division</td>
</tr>
<tr><td>mod(a, b)</td>
<td>a % b</td>
<td>Modulus</td>
</tr>
<tr><td>and(a, b)</td>
<td>a &amp; b</td>
<td>Bitwise and</td>
</tr>
<tr><td>or(a, b)</td>
<td>a | b</td>
<td>Bitwise or</td>
</tr>
<tr><td>xor(a, b)</td>
<td>a ^ b</td>
<td>Bitwise exclusive or</td>
</tr>
<tr><td>lshift(a, b)</td>
<td>a &lt;&lt; b</td>
<td>Bitwise left shift</td>
</tr>
<tr><td>rshift(a, b)</td>
<td>a &gt;&gt; b</td>
<td>Bitwise signed right shift</td>
</tr>
<tr><td>zrshfit(a, b)</td>
<td>a &gt;&gt;&gt; b</td>
<td>Bitwise unsigned right shift</td>
</tr>
</tbody>
</table>
<p>Built-in Comparators:</p>
<table border="1" class="docutils">
<colgroup>
<col width="23%" />
<col width="32%" />
<col width="45%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">Operator</th>
<th class="head">Implementation</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>eq(a, b)</td>
<td>a == b</td>
<td>Equals</td>
</tr>
<tr><td>ne(a, b)</td>
<td>a != b</td>
<td>Not equals</td>
</tr>
<tr><td>gt(a, b)</td>
<td>a &gt; b</td>
<td>Greater than</td>
</tr>
<tr><td>ge(a, b)</td>
<td>a &gt;= b</td>
<td>Greater than or equal to</td>
</tr>
<tr><td>lt(a, b)</td>
<td>a &lt; b</td>
<td>Less than</td>
</tr>
<tr><td>le(a, b)</td>
<td>a &lt;= b</td>
<td>Less than or equal to</td>
</tr>
</tbody>
</table>
<p>Extended Comparators (uses compare):</p>
<table border="1" class="docutils">
<colgroup>
<col width="23%" />
<col width="32%" />
<col width="45%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">Operator</th>
<th class="head">Implementation</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>ceq(a, b)</td>
<td>compare(a, b) == 0</td>
<td>Equals</td>
</tr>
<tr><td>cne(a, b)</td>
<td>compare(a, b) != 0</td>
<td>Not equals</td>
</tr>
<tr><td>cgt(a, b)</td>
<td>compare(a, b) == 1</td>
<td>Greater than</td>
</tr>
<tr><td>cge(a, b)</td>
<td>compare(a, b) != -1</td>
<td>Greater than or equal to</td>
</tr>
<tr><td>clt(a, b)</td>
<td>compare(a, b) == -1</td>
<td>Less than</td>
</tr>
<tr><td>cle(a, b)</td>
<td>compare(a, b) != 1</td>
<td>Less than or equal to</td>
</tr>
</tbody>
</table>
<p>Binary Logical Operators:</p>
<table border="1" class="last docutils">
<colgroup>
<col width="23%" />
<col width="32%" />
<col width="45%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">Operator</th>
<th class="head">Implementation</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>logand(a, b)</td>
<td>a &amp;&amp; b</td>
<td>Logical and</td>
</tr>
<tr><td>logor(a, b)</td>
<td>a || b</td>
<td>Logical or</td>
</tr>
<tr><td>contains(a, b)</td>
<td>b in a</td>
<td>Has property (note order)</td>
</tr>
</tbody>
</table>
</dd>
<dt>forward(name):</dt>
<dd>Returns a function that forwards a method call to this.name(...)</dd>
<dt>itemgetter(name):</dt>
<dd>Returns a function(obj) that returns obj[name]</dd>
<dt>typeMatcher(typ[, ...]):</dt>
<dd>Given a set of types (as string arguments),
returns a function(obj[, ...]) that will return true if the
types of the given arguments are all members of that set.</dd>
<dt>isNull(obj[, ...]):</dt>
<dd>Returns true if all arguments are null.</dd>
<dt>isUndefinedOrNull(obj[, ...]):</dt>
<dd>Returns true if all arguments are undefined or null</dd>
<dt>isNotEmpty(obj[, ...]):</dt>
<dd>Returns true if all the given array or string arguments
are not empty (obj.length &gt; 0)</dd>
<dt>isArrayLike(obj[, ...]):</dt>
<dd>Returns true if all given arguments are Array-like</dd>
<dt>isDateLike(obj[, ...]):</dt>
<dd>Returns true if all given arguments are Date-like</dd>
<dt>xmap(fn, obj[, ...):</dt>
<dd><p class="first">Return an array composed of fn(obj) for every obj given as an
argument.</p>
<p class="last">If fn is null, operator.identity is used.</p>
</dd>
<dt>map(fn, lst[, ...]):</dt>
<dd><p class="first">Return a new array composed of the results of fn(x) for every x in
lst</p>
<p>If fn is null, and only one sequence argument is given the identity
function is used.</p>
<blockquote>
map(null, lst) -&gt; lst.slice();</blockquote>
<p>If fn is null, and more than one sequence is given as arguments,
then the Array function is used, making it equivalent to zip.</p>
<blockquote class="last">
<dl class="docutils">
<dt>map(null, p, q, ...)</dt>
<dd>-&gt; zip(p, q, ...)
-&gt; [[p0, q0, ...], [p1, q1, ...], ...];</dd>
</dl>
</blockquote>
</dd>
<dt>xfilter(fn, obj[, ...]):</dt>
<dd><p class="first">Returns a new array composed of the arguments where
fn(obj) returns a true value.</p>
<p class="last">If fn is null, operator.truth will be used.</p>
</dd>
<dt>filter(fn, lst):</dt>
<dd><p class="first">Returns a new array composed of elements from lst where
fn(lst[i]) returns a true value.</p>
<p class="last">If fn is null, operator.truth will be used.</p>
</dd>
<dt>bind(func, self):</dt>
<dd><p class="first">Return a copy of func bound to self.  This means whenever
and however the return value is called, &quot;this&quot; will always
reference the given &quot;self&quot;.</p>
<p class="last">Calling bind(func, self) on an already bound function will
return a new function that is bound to the new self.</p>
</dd>
<dt>bindMethods(self):</dt>
<dd>Bind all functions in self to self,
which gives you a semi-Pythonic sort of instance.</dd>
<dt>registerComparator(name, check, comparator[, override]):</dt>
<dd><p class="first">Register a comparator for use with the compare function.</p>
<p>name should be a unique identifier describing the comparator.</p>
<p>check is a function (a, b) that returns true if a and b
can be compared with comparator.</p>
<p>comparator is a function (a, b) that returns:</p>
<table border="1" class="docutils">
<colgroup>
<col width="39%" />
<col width="61%" />
</colgroup>
<tbody valign="top">
<tr><td>Value</td>
<td>Condition</td>
</tr>
<tr><td>0</td>
<td>a == b</td>
</tr>
<tr><td>1</td>
<td>a &gt; b</td>
</tr>
<tr><td>-1</td>
<td>a &lt; b</td>
</tr>
</tbody>
</table>
<p>comparator is guaranteed to only be called if check(a, b)
returns a true value.</p>
<p class="last">If override is given and true, then it will be made the
highest precedence comparator.  Otherwise, the lowest.</p>
</dd>
<dt>compare(a, b):</dt>
<dd><p class="first">Compare two objects in a sensible manner.  Currently this is:</p>
<blockquote>
<ol class="arabic simple">
<li>undefined and null compare equal to each other</li>
<li>undefined and null are less than anything else</li>
<li>comparators registered with registerComparator are
used to find a good comparator.  Built-in comparators
are currently available for arrays and dates.</li>
<li>Otherwise hope that the built-in comparison operators
do something useful, which should work for numbers
and strings.</li>
</ol>
</blockquote>
<p>Returns what one would expect from a comparison function:</p>
<table border="1" class="last docutils">
<colgroup>
<col width="39%" />
<col width="61%" />
</colgroup>
<tbody valign="top">
<tr><td>Value</td>
<td>Condition</td>
</tr>
<tr><td>0</td>
<td>a == b</td>
</tr>
<tr><td>1</td>
<td>a &gt; b</td>
</tr>
<tr><td>-1</td>
<td>a &lt; b</td>
</tr>
</tbody>
</table>
</dd>
<dt>registerRepr(name, check, wrap[, override]):</dt>
<dd><p class="first">Register a repr function.  repr functions should take
one argument and return a string representation of it
suitable for developers, primarily used when debugging.</p>
<p class="last">If override is given, it is used as the highest priority
repr, otherwise it will be used as the lowest.</p>
</dd>
<dt>repr(o):</dt>
<dd>Return a &quot;programmer representation&quot; for an object</dd>
<dt>objEqual(a, b):</dt>
<dd>Compare the equality of two objects.</dd>
<dt>arrayEqual(self, arr):</dt>
<dd>Compare two arrays for equality, with a fast-path for length
differences.</dd>
<dt>concat(lst[, ...]):</dt>
<dd><p class="first">Concatenates all given array-like arguments and returns
a new array:</p>
<pre class="last literal-block">
var lst = concat([&quot;1&quot;,&quot;3&quot;,&quot;5&quot;], [&quot;2&quot;,&quot;4&quot;,&quot;6&quot;]);
assert(lst.toString() == &quot;1,3,5,2,4,6&quot;);
</pre>
</dd>
<dt>keyComparator(key[, ...]):</dt>
<dd><p class="first">A comparator factory that compares a[key] with b[key].
e.g.:</p>
<blockquote class="last">
var lst = [&quot;a&quot;, &quot;bbb&quot;, &quot;cc&quot;];
lst.sort(keyComparator(&quot;length&quot;));
assert(lst.toString() == &quot;a,cc,bbb&quot;);</blockquote>
</dd>
<dt>reverseKeyComparator(key):</dt>
<dd><p class="first">A comparator factory that compares a[key] with b[key] in reverse.
e.g.:</p>
<blockquote class="last">
var lst = [&quot;a&quot;, &quot;bbb&quot;, &quot;cc&quot;];
lst.sort(reverseKeyComparator(&quot;length&quot;));
assert(lst.toString() == &quot;bbb,cc,aa&quot;);</blockquote>
</dd>
<dt>partial(func, arg[, ...]):</dt>
<dd><p class="first">Return a partially applied function, e.g.:</p>
<pre class="literal-block">
addNumbers = function (a, b) {
    return a + b;
}

addOne = partial(addNumbers, 1);

assert(addOne(2) == 3);
</pre>
<p class="last">NOTE: This could be used to implement, but is NOT currying.</p>
</dd>
<dt>listMinMax(which, lst):</dt>
<dd><p class="first">If which == -1 then it will return the smallest
element of the array-like lst.  This is also available
as:</p>
<pre class="literal-block">
listMin(lst)
</pre>
<p>If which == 1 then it will return the largest
element of the array-like lst.  This is also available
as:</p>
<pre class="last literal-block">
listMax(list)
</pre>
</dd>
<dt>objMax(obj[, ...]):</dt>
<dd>Return the maximum object out of the given arguments</dd>
<dt>objMin(obj[, ...]):</dt>
<dd>Return the minimum object out of the given arguments</dd>
<dt>nodeWalk(node, visitor):</dt>
<dd><p class="first">Non-recursive generic node walking function (e.g. for a DOM)</p>
<dl class="last docutils">
<dt>node:</dt>
<dd>The initial node to be searched.</dd>
<dt>visitor:</dt>
<dd>The visitor function, will be called as
visitor(node), and should return an Array-like
of notes to be searched next (e.g.  node.childNodes).</dd>
</dl>
</dd>
<dt>nameFunctions(namespace):</dt>
<dd><p class="first">Given a namespace with a NAME property, find all functions in it and
give them nice NAME properties too.  e.g.:</p>
<pre class="last literal-block">
namespace = {
    NAME: &quot;Awesome&quot;,
    Dude: function () {}
}
nameFunctions(namespace);
assert( namespace.Dude.NAME == 'Awesome.Dude' );
</pre>
</dd>
</dl>
</div>
</div>
</body>
</html>
