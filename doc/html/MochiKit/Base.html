<?xml version="1.0" encoding="utf8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf8" />
<meta name="generator" content="Docutils 0.3.10: http://docutils.sourceforge.net/" />
<title></title>
</head>
<body>
<div class="document">
<!-- -*- mode: rst -*- -->
<div class="section" id="name">
<h1><a name="name">Name</a></h1>
<p>MochiKit.Base - functional programming and useful comparisons</p>
</div>
<div class="section" id="synopsis">
<h1><a name="synopsis">Synopsis</a></h1>
<pre class="literal-block">
myObjectRepr = function () {
    // gives a nice, stable string representation for objects,
    // ignoring any methods
    var keyValuePairs = [];
    for (var k in this) {
        var v = this[k];
        if (typeof(v) != 'function') {
            keyValuePairs.push([k, v]);
        }
    };
    keyValuePairs.sort(compare);
    return &quot;{&quot; + map(
        function (pair) {
            return map(repr, pair).join(&quot;:&quot;);
        }, 
        keyValuePairs
    ).join(&quot;, &quot;) + &quot;}&quot;;
};
        
// repr() will look for objects that have a repr method
myObjectArray = [
    {&quot;a&quot;: 3, &quot;b&quot;: 2, &quot;repr&quot;: myObjectRepr},
    {&quot;a&quot;: 1, &quot;b&quot;: 2, &quot;repr&quot;, myObjectRepr}
];

// sort it by the &quot;a&quot; property, check to see if it matches
myObjectArray.sort(keyComparator(&quot;a&quot;));
expectedRepr = '[{&quot;a&quot;: 1, &quot;b&quot;: 2}, {&quot;a&quot;: 3, &quot;b&quot;: 2}]';
assert( repr(myObjectArray) == expectedRepr );

// get just the &quot;a&quot; values out into an array
sortedAValues = map(itemgetter(&quot;a&quot;), myObjectArray);
assert( compare(sortedAValues, [1, 3]) == 0 );
</pre>
</div>
<div class="section" id="description">
<h1><a name="description">Description</a></h1>
<p>MochiKit.Base is the foundation for the MochiKit suite.  It provides:</p>
<ul class="simple">
<li>An extensible comparison facility (<tt class="docutils literal"><span class="pre">compare</span></tt>, <tt class="docutils literal"><span class="pre">registerComparator</span></tt>)</li>
<li>An extensible programmer representation facility (<tt class="docutils literal"><span class="pre">repr</span></tt>)</li>
<li>A simple adaptation facility (<tt class="docutils literal"><span class="pre">AdapterRegistry</span></tt>)</li>
<li>Convenience functions for manipulating objects (<tt class="docutils literal"><span class="pre">update</span></tt>, <tt class="docutils literal"><span class="pre">extend</span></tt>, etc.)</li>
<li>Array-based functional programming (<tt class="docutils literal"><span class="pre">map</span></tt>, <tt class="docutils literal"><span class="pre">filter</span></tt>, <tt class="docutils literal"><span class="pre">setdefault</span></tt>, etc.)</li>
<li>Bound and partially applied functions (<tt class="docutils literal"><span class="pre">bind</span></tt>, <tt class="docutils literal"><span class="pre">partial</span></tt>)</li>
</ul>
<p>Python users will feel at home with MochiKit.Base, as the facilities are
quite similar to those available as part of Python and the Python standard
library.</p>
</div>
<div class="section" id="dependencies">
<h1><a name="dependencies">Dependencies</a></h1>
<p>None.</p>
</div>
<div class="section" id="overview">
<h1><a name="overview">Overview</a></h1>
<div class="section" id="comparison">
<h2><a name="comparison">Comparison</a></h2>
<p>The comparators (operators for comparison) in JavaScript are deeply broken,
and it is not possible to teach them new tricks.</p>
<p>The extensible comparison facility exposed by MochiKit as a simple
<tt class="docutils literal"><span class="pre">compare(a,</span> <span class="pre">b)</span></tt> function, which should be used in lieu of JavaScript's
operators whenever comparing objects other than numbers or strings (though you
can certainly use <tt class="docutils literal"><span class="pre">compare</span></tt> for those, too!).</p>
<p>The <tt class="docutils literal"><span class="pre">compare</span></tt> function has the same signature and return value as a sort
function for <tt class="docutils literal"><span class="pre">Array.prototype.sort</span></tt>, and is often used in that context.</p>
<p>Defining new comparators for the <tt class="docutils literal"><span class="pre">compare</span></tt> function to use is done
by adding an entry to its <tt class="docutils literal"><span class="pre">AdapterRegistry</span></tt> with the <tt class="docutils literal"><span class="pre">registerComparator</span></tt>
function.</p>
</div>
<div class="section" id="programmer-representation">
<h2><a name="programmer-representation">Programmer Representation</a></h2>
<p>JavaScript's default representation mechanism, <tt class="docutils literal"><span class="pre">toString</span></tt>, is notorious
for having terrible default behavior.  It's also very unwise to change that
default, as other JavaScript code you may be using may depend on it.</p>
<p>It's also useful to separate the concept of a &quot;string representation&quot; and a
&quot;string representation for programmers&quot;, much like Python does with its str
and repr protocols.</p>
<p><tt class="docutils literal"><span class="pre">repr</span></tt> provides this programmer representation for JavaScript, in a way
that doesn't require object prototype hacking: using an <tt class="docutils literal"><span class="pre">AdapterRegistry</span></tt>.
Objects that implement the repr protocol can either implement a <tt class="docutils literal"><span class="pre">.repr()</span></tt>
or <tt class="docutils literal"><span class="pre">.__repr__()</span></tt> method, or they can simply have an adapter setup to
generate programmer representations.  By default, the registry provides
nice representations for <tt class="docutils literal"><span class="pre">null</span></tt>, <tt class="docutils literal"><span class="pre">undefined</span></tt>, <tt class="docutils literal"><span class="pre">Array</span></tt>, and objects or
functions with a <tt class="docutils literal"><span class="pre">NAME</span></tt> attribute that use the default <tt class="docutils literal"><span class="pre">toString</span></tt>.  For
objects that <tt class="docutils literal"><span class="pre">repr</span></tt> doesn't already understand, it simply defaults to
<tt class="docutils literal"><span class="pre">toString</span></tt>, so it will integrate seamlessly with code that implements
the idiomatic JavaScript <tt class="docutils literal"><span class="pre">toString</span></tt> method!</p>
<p>To define a programmer representation for your own objects, simply add
a <tt class="docutils literal"><span class="pre">.repr()</span></tt> or <tt class="docutils literal"><span class="pre">.__repr__()</span></tt> method that returns a string.  For
objects that you didn't create (e.g., from a script you didn't write, or a 
built-in object), it is instead recommended that you create an adapter
with <tt class="docutils literal"><span class="pre">registerRepr</span></tt>.</p>
</div>
<div class="section" id="adapter-registries">
<h2><a name="adapter-registries">Adapter Registries</a></h2>
<p>MochiKit makes extensive use of adapter registries, which enable you to
implement object-specific behaviors for objects that you do not necessarily
want to modify, such as built-in objects.  This is especially useful because
JavaScript does not provide a method for hiding user-defined properties from
<tt class="docutils literal"><span class="pre">for</span> <span class="pre">propName</span> <span class="pre">in</span> <span class="pre">obj</span></tt> enumeration.</p>
<p><tt class="docutils literal"><span class="pre">AdapterRegistry</span></tt> is simply an encapsulation for an ordered list of &quot;check&quot;
and &quot;wrap&quot; function pairs.  Each <tt class="docutils literal"><span class="pre">AdapterRegistry</span></tt> instance should perform
one function, but may have multiple ways to achieve that function based upon
the arguments.  One way to think of it is as a poor man's generic function,
or multiple dispatch (on arbitrary functions, not just type!).</p>
<p>Check functions take one or more arguments, and return <tt class="docutils literal"><span class="pre">true</span></tt> if the
argument list is suitable for the wrap function.  Check functions should
perform &quot;cheap&quot; checks of an object's type or contents, before the
&quot;expensive&quot; wrap function is called.</p>
<p>Wrap functions take the same arguments as check functions and do some
operation, such as creating a programmer representation or comparing
both arguments.</p>
</div>
<div class="section" id="convenience-functions">
<h2><a name="convenience-functions">Convenience Functions</a></h2>
<p>Much of MochiKit.Base is there to simply remove the grunt work of doing
generic JavaScript programming.</p>
<p>Need to take every property from one object and set them on another?  No
problem, just call <tt class="docutils literal"><span class="pre">update(dest,</span> <span class="pre">src)</span></tt>!  What if you just wanted to
update keys that weren't already set?  Look no further than
<tt class="docutils literal"><span class="pre">setdefault(dest,</span> <span class="pre">src[,</span> <span class="pre">...])</span></tt>.</p>
<p>Need to extend an Array with another array?  Or even an array-like object
such as a <tt class="docutils literal"><span class="pre">NodeList</span></tt> or the special <tt class="docutils literal"><span class="pre">arguments</span></tt> object?  Even if you
need to skip the first few elements of the source array-like object, it's
no problem with <tt class="docutils literal"><span class="pre">extend(dstArray,</span> <span class="pre">srcArrayLike[,</span> <span class="pre">skip])</span></tt>!</p>
<p>Wouldn't it be convenient to have all of the JavaScript operators were
available as functions somewhere?  That's what the <tt class="docutils literal"><span class="pre">operators</span></tt> table is for,
and it even comes with additional operators based on the <tt class="docutils literal"><span class="pre">compare</span></tt> function.</p>
<p>Need to walk some tree of objects and manipulate or find something in it?
A DOM element tree perhaps?  Use <tt class="docutils literal"><span class="pre">nodeWalk(node,</span> <span class="pre">visitor)</span></tt>!</p>
<p>There's plenty more, so check out the <a class="reference" href="#api-reference">API Reference</a> below.</p>
</div>
<div class="section" id="functional-programming">
<h2><a name="functional-programming">Functional Programming</a></h2>
<p>Functional programming constructs such as <tt class="docutils literal"><span class="pre">map</span></tt> and <tt class="docutils literal"><span class="pre">filter</span></tt> can save you
a lot of time, because JavaScript iteration is error-prone and arduous.
Writing less code is the best way to prevent bugs, and functional programming
can help you do that.</p>
<p>MochiKit.Base ships with a few simple Array-based functional programming
constructs, namely <tt class="docutils literal"><span class="pre">map</span></tt> and <tt class="docutils literal"><span class="pre">filter</span></tt>, and their &quot;extended&quot; brethren,
<tt class="docutils literal"><span class="pre">xmap</span></tt> and <tt class="docutils literal"><span class="pre">xfilter</span></tt>.</p>
<p><tt class="docutils literal"><span class="pre">map(func,</span> <span class="pre">arrayLike[,</span> <span class="pre">...])</span></tt> takes a function and an array-like
object, and creates a new <tt class="docutils literal"><span class="pre">Array</span></tt>.  The new <tt class="docutils literal"><span class="pre">Array</span></tt> is the result of
<tt class="docutils literal"><span class="pre">func(element)</span></tt> for every element of <tt class="docutils literal"><span class="pre">arrayLike</span></tt>, much
like the <tt class="docutils literal"><span class="pre">Array.prototype.map</span></tt> extension in Mozilla.  However, MochiKit.Base
takes that a step further and gives you the full blown Python version of
<tt class="docutils literal"><span class="pre">map</span></tt>, which will take several array-like objects, and calls the function
with one argument per given array-like, like this:</p>
<pre class="literal-block">
var arrayOne = [1, 2, 3, 4, 5];
var arrayTwo = [1, 5, 2, 4, 3];
var arrayThree = [5, 2, 1, 3, 4];
var biggestElements = map(objMax, arrayOne, arrayTwo, arrayThree);
assert( objEqual(biggestElements, [5, 5, 3, 4, 5]) );
</pre>
<p><tt class="docutils literal"><span class="pre">filter(func,</span> <span class="pre">arrayLike)</span></tt> takes a function and an array-like object, and
returns a new <tt class="docutils literal"><span class="pre">Array</span></tt>.  This is basically identical to the
<tt class="docutils literal"><span class="pre">Array.prototype.filter</span></tt> extension in Mozilla.</p>
<p><tt class="docutils literal"><span class="pre">xmap</span></tt> and <tt class="docutils literal"><span class="pre">xfilter</span></tt> are just special forms of <tt class="docutils literal"><span class="pre">map</span></tt> and <tt class="docutils literal"><span class="pre">filter</span></tt>
that accept a function as the first argument, and use the extra arguments as
the array-like.  Not terribly interesting, but a definite time-saver in some
cases.</p>
<p>If you appreciate the functional programming facilities here,
you should definitely check out <a class="reference" href="Iter.html">MochiKit.Iter</a>, which provides for full
blown iterators, <tt class="docutils literal"><span class="pre">range</span></tt>, <tt class="docutils literal"><span class="pre">reduce</span></tt>, and a near-complete port of Python's
<tt class="docutils literal"><span class="pre">itertools</span></tt> module, with some extra stuff thrown in for good measure!</p>
</div>
<div class="section" id="bound-and-partial-functions">
<h2><a name="bound-and-partial-functions">Bound and Partial Functions</a></h2>
<p>JavaScript's method-calling special form and lack of bound functions (functions
that know what <tt class="docutils literal"><span class="pre">this</span></tt> should be) are one of the first stumbling blocks that
programmers new to JavaScript face.  The <tt class="docutils literal"><span class="pre">bind(func,</span> <span class="pre">self)</span></tt> method fixes
that right up by returning a new function that calls func with the right
<tt class="docutils literal"><span class="pre">this</span></tt>.</p>
<p>In order to take real advantage of all this fancy functional programming stuff,
you're probably going to want partial application.  This allows you to create
a new function from an existing function that remembers some of the arguments.
For example, if you wanted to compare a given object to a slew of other 
objects, you could do something like this:</p>
<pre class="literal-block">
compareWithOne = partial(compare, 1);
results = map(compareWithOne, [0, 1, 2, 3]);
assert( objEqual(results, [-1, 0, 1, 1]) );
</pre>
<p>One of the better uses of partial functions is in <a class="reference" href="DOM.html">MochiKit.DOM</a>, which is
certainly a must-see for those of you creating lots of DOM elements with
JavaScript!</p>
</div>
</div>
<div class="section" id="api-reference">
<h1><a name="api-reference">API Reference</a></h1>
<div class="section" id="errors">
<h2><a name="errors">Errors</a></h2>
<dl class="docutils">
<dt><tt class="docutils literal"><span class="pre">NotFound</span></tt>:</dt>
<dd>A singleton error raised when no suitable adapter is found</dd>
</dl>
</div>
<div class="section" id="constructors">
<h2><a name="constructors">Constructors</a></h2>
<dl class="docutils">
<dt><tt class="docutils literal"><span class="pre">NamedError</span></tt>:</dt>
<dd>Convenience constructor for creating new errors (e.g. <tt class="docutils literal"><span class="pre">NotFound</span></tt>)</dd>
<dt><tt class="docutils literal"><span class="pre">AdapterRegistry</span></tt>:</dt>
<dd><p class="first">A registry to facilitate adaptation.</p>
<p class="last">All check/wrap functions in this registry should be of the same arity.</p>
</dd>
<dt><tt class="docutils literal"><span class="pre">AdapterRegistry.prototype.register(name,</span> <span class="pre">check,</span> <span class="pre">wrap[,</span> <span class="pre">override])</span></tt>:</dt>
<dd><p class="first">The check function should return true if the given arguments are
appropriate for the wrap function.</p>
<p class="last">If override is given and true, the check function will be given
highest priority.  Otherwise, it will be the lowest priority
adapter.</p>
</dd>
<dt><tt class="docutils literal"><span class="pre">AdapterRegistry.prototype.match(obj[,</span> <span class="pre">...])</span></tt>:</dt>
<dd><p class="first">Find an adapter for the given arguments.</p>
<p class="last">If no suitable adapter is found, throws <tt class="docutils literal"><span class="pre">NotFound</span></tt>.</p>
</dd>
<dt><tt class="docutils literal"><span class="pre">AdapterRegistry.prototype.unregister(name)</span></tt>:</dt>
<dd>Remove a named adapter from the registry</dd>
</dl>
</div>
<div class="section" id="functions">
<h2><a name="functions">Functions</a></h2>
<dl class="docutils">
<dt><tt class="docutils literal"><span class="pre">extend(self,</span> <span class="pre">obj[,</span> <span class="pre">skip])</span></tt>:</dt>
<dd><p class="first">Mutate an array by extending it with an array-like obj,
starting with the &quot;skip&quot; index of obj.  If null is given
as the initial array, a new one will be created.</p>
<p class="last">This mutates <em>and returns</em> the given array, be warned.</p>
</dd>
<dt><tt class="docutils literal"><span class="pre">update(self,</span> <span class="pre">obj[,</span> <span class="pre">...])</span></tt>:</dt>
<dd><p class="first">Mutate an object by replacing its key:value pairs with those
from other object(s).  Key:value pairs from later objects will
overwrite those from earlier objects.</p>
<p>If null is given as the initial object, a new one will be created.</p>
<p>This mutates <em>and returns</em> the given object, be warned.</p>
<p class="last">A version of this function that creates a new object is available
as <tt class="docutils literal"><span class="pre">merge(a,</span> <span class="pre">b[,</span> <span class="pre">...])</span></tt></p>
</dd>
<dt><tt class="docutils literal"><span class="pre">merge(obj[,</span> <span class="pre">...])</span></tt>:</dt>
<dd><p class="first">Create a new instance of <tt class="docutils literal"><span class="pre">Object</span></tt> that contains every property
from all given objects.  If a property is defined on more than
one of the objects, the last property is used.</p>
<p class="last">This is a special form of <tt class="docutils literal"><span class="pre">update(self,</span> <span class="pre">obj[,</span> <span class="pre">...])</span></tt>, specifically,
it is defined as <tt class="docutils literal"><span class="pre">partial(update,</span> <span class="pre">null)</span></tt>.</p>
</dd>
<dt><tt class="docutils literal"><span class="pre">setdefault(self,</span> <span class="pre">obj[,</span> <span class="pre">...])</span></tt>:</dt>
<dd><p class="first">Mutate an object by adding all properties from other object(s)
that it does not already have set.</p>
<p>If <tt class="docutils literal"><span class="pre">self</span></tt> is <tt class="docutils literal"><span class="pre">null</span></tt>, a new <tt class="docutils literal"><span class="pre">Object</span></tt> instance will be created
and returned.</p>
<p class="last">This mutates <em>and returns</em> the given <tt class="docutils literal"><span class="pre">self</span></tt>, be warned.</p>
</dd>
<dt><tt class="docutils literal"><span class="pre">keys(obj)</span></tt>:</dt>
<dd>Return an <tt class="docutils literal"><span class="pre">Array</span></tt> of the property names of an object
(in the order determined by <tt class="docutils literal"><span class="pre">for</span> <span class="pre">propName</span> <span class="pre">in</span> <span class="pre">obj</span></tt>).</dd>
<dt><tt class="docutils literal"><span class="pre">items(obj)</span></tt>:</dt>
<dd>Return an <tt class="docutils literal"><span class="pre">Array</span></tt> of <tt class="docutils literal"><span class="pre">[propertyName,</span> <span class="pre">propertyValue]</span></tt> pairs for the
given <tt class="docutils literal"><span class="pre">obj</span></tt> (in the order deterined by <tt class="docutils literal"><span class="pre">for</span> <span class="pre">propName</span> <span class="pre">in</span> <span class="pre">obj</span></tt>).</dd>
<dt>operator:</dt>
<dd><p class="first">A table of JavaScript's operators for usage with <tt class="docutils literal"><span class="pre">map</span></tt>, <tt class="docutils literal"><span class="pre">filter</span></tt>, etc.</p>
<p>Unary Logic Operators:</p>
<table border="1" class="docutils">
<colgroup>
<col width="23%" />
<col width="32%" />
<col width="45%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">Operator</th>
<th class="head">Implementation</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>truth(a)</td>
<td>!!a</td>
<td>Logical truth</td>
</tr>
<tr><td>lognot(a)</td>
<td>!a</td>
<td>Logical not</td>
</tr>
<tr><td>identity(a)</td>
<td>a</td>
<td>Logical identity</td>
</tr>
</tbody>
</table>
<p>Unary Math Operators:</p>
<table border="1" class="docutils">
<colgroup>
<col width="23%" />
<col width="32%" />
<col width="45%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">Operator</th>
<th class="head">Implementation</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>not(a)</td>
<td>~a</td>
<td>Bitwise not</td>
</tr>
<tr><td>neg(a)</td>
<td>-a</td>
<td>Negation</td>
</tr>
</tbody>
</table>
<p>Binary Operators:</p>
<table border="1" class="docutils">
<colgroup>
<col width="23%" />
<col width="32%" />
<col width="45%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">Operator</th>
<th class="head">Implementation</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>add(a, b)</td>
<td>a + b</td>
<td>Addition</td>
</tr>
<tr><td>div(a, b)</td>
<td>a / b</td>
<td>Division</td>
</tr>
<tr><td>mod(a, b)</td>
<td>a % b</td>
<td>Modulus</td>
</tr>
<tr><td>and(a, b)</td>
<td>a &amp; b</td>
<td>Bitwise and</td>
</tr>
<tr><td>or(a, b)</td>
<td>a | b</td>
<td>Bitwise or</td>
</tr>
<tr><td>xor(a, b)</td>
<td>a ^ b</td>
<td>Bitwise exclusive or</td>
</tr>
<tr><td>lshift(a, b)</td>
<td>a &lt;&lt; b</td>
<td>Bitwise left shift</td>
</tr>
<tr><td>rshift(a, b)</td>
<td>a &gt;&gt; b</td>
<td>Bitwise signed right shift</td>
</tr>
<tr><td>zrshfit(a, b)</td>
<td>a &gt;&gt;&gt; b</td>
<td>Bitwise unsigned right shift</td>
</tr>
</tbody>
</table>
<p>Built-in Comparators:</p>
<table border="1" class="docutils">
<colgroup>
<col width="23%" />
<col width="32%" />
<col width="45%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">Operator</th>
<th class="head">Implementation</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>eq(a, b)</td>
<td>a == b</td>
<td>Equals</td>
</tr>
<tr><td>ne(a, b)</td>
<td>a != b</td>
<td>Not equals</td>
</tr>
<tr><td>gt(a, b)</td>
<td>a &gt; b</td>
<td>Greater than</td>
</tr>
<tr><td>ge(a, b)</td>
<td>a &gt;= b</td>
<td>Greater than or equal to</td>
</tr>
<tr><td>lt(a, b)</td>
<td>a &lt; b</td>
<td>Less than</td>
</tr>
<tr><td>le(a, b)</td>
<td>a &lt;= b</td>
<td>Less than or equal to</td>
</tr>
</tbody>
</table>
<p>Extended Comparators (uses compare):</p>
<table border="1" class="docutils">
<colgroup>
<col width="23%" />
<col width="32%" />
<col width="45%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">Operator</th>
<th class="head">Implementation</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>ceq(a, b)</td>
<td>compare(a, b) == 0</td>
<td>Equals</td>
</tr>
<tr><td>cne(a, b)</td>
<td>compare(a, b) != 0</td>
<td>Not equals</td>
</tr>
<tr><td>cgt(a, b)</td>
<td>compare(a, b) == 1</td>
<td>Greater than</td>
</tr>
<tr><td>cge(a, b)</td>
<td>compare(a, b) != -1</td>
<td>Greater than or equal to</td>
</tr>
<tr><td>clt(a, b)</td>
<td>compare(a, b) == -1</td>
<td>Less than</td>
</tr>
<tr><td>cle(a, b)</td>
<td>compare(a, b) != 1</td>
<td>Less than or equal to</td>
</tr>
</tbody>
</table>
<p>Binary Logical Operators:</p>
<table border="1" class="last docutils">
<colgroup>
<col width="23%" />
<col width="32%" />
<col width="45%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">Operator</th>
<th class="head">Implementation</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>logand(a, b)</td>
<td>a &amp;&amp; b</td>
<td>Logical and</td>
</tr>
<tr><td>logor(a, b)</td>
<td>a || b</td>
<td>Logical or</td>
</tr>
<tr><td>contains(a, b)</td>
<td>b in a</td>
<td>Has property (note order)</td>
</tr>
</tbody>
</table>
</dd>
<dt><tt class="docutils literal"><span class="pre">forward(name)</span></tt>:</dt>
<dd>Returns a function that forwards a method call to <tt class="docutils literal"><span class="pre">this.name(...)</span></tt></dd>
<dt><tt class="docutils literal"><span class="pre">itemgetter(name)</span></tt>:</dt>
<dd>Returns a <tt class="docutils literal"><span class="pre">function(obj)</span></tt> that returns <tt class="docutils literal"><span class="pre">obj[name]</span></tt></dd>
<dt><tt class="docutils literal"><span class="pre">typeMatcher(typ[,</span> <span class="pre">...])</span></tt>:</dt>
<dd>Given a set of types (as string arguments),
returns a <tt class="docutils literal"><span class="pre">function(obj[,</span> <span class="pre">...])</span></tt> that will return <tt class="docutils literal"><span class="pre">true</span></tt> if the
types of the given arguments are all members of that set.</dd>
<dt><tt class="docutils literal"><span class="pre">isNull(obj[,</span> <span class="pre">...])</span></tt>:</dt>
<dd>Returns <tt class="docutils literal"><span class="pre">true</span></tt> if all arguments are <tt class="docutils literal"><span class="pre">null</span></tt>.</dd>
<dt><tt class="docutils literal"><span class="pre">isUndefinedOrNull(obj[,</span> <span class="pre">...])</span></tt>:</dt>
<dd>Returns <tt class="docutils literal"><span class="pre">true</span></tt> if all arguments are undefined or <tt class="docutils literal"><span class="pre">null</span></tt></dd>
<dt><tt class="docutils literal"><span class="pre">isNotEmpty(obj[,</span> <span class="pre">...])</span></tt>:</dt>
<dd>Returns <tt class="docutils literal"><span class="pre">true</span></tt> if all the given <tt class="docutils literal"><span class="pre">Array</span></tt>-like or string arguments
are not empty <tt class="docutils literal"><span class="pre">(obj.length</span> <span class="pre">&gt;</span> <span class="pre">0)</span></tt></dd>
<dt><tt class="docutils literal"><span class="pre">isArrayLike(obj[,</span> <span class="pre">...])</span></tt>:</dt>
<dd>Returns <tt class="docutils literal"><span class="pre">true</span></tt> if all given arguments are <tt class="docutils literal"><span class="pre">Array</span></tt>-like (have a
<tt class="docutils literal"><span class="pre">.length</span></tt> property and <tt class="docutils literal"><span class="pre">typeof(obj)</span> <span class="pre">==</span> <span class="pre">'object'</span></tt>)</dd>
<dt><tt class="docutils literal"><span class="pre">isDateLike(obj[,</span> <span class="pre">...])</span></tt>:</dt>
<dd>Returns <tt class="docutils literal"><span class="pre">true</span></tt> if all given arguments are <tt class="docutils literal"><span class="pre">Date</span></tt>-like (have a 
<tt class="docutils literal"><span class="pre">.getTime()</span></tt> method)</dd>
<dt><tt class="docutils literal"><span class="pre">xmap(fn,</span> <span class="pre">obj[,</span> <span class="pre">...)</span></tt>:</dt>
<dd><p class="first">Return a new <tt class="docutils literal"><span class="pre">Array</span></tt> composed of <tt class="docutils literal"><span class="pre">fn(obj)</span></tt> for every <tt class="docutils literal"><span class="pre">obj</span></tt>
given as an argument.</p>
<p class="last">If <tt class="docutils literal"><span class="pre">fn</span></tt> is <tt class="docutils literal"><span class="pre">null</span></tt>, <tt class="docutils literal"><span class="pre">operator.identity</span></tt> is used.</p>
</dd>
<dt><tt class="docutils literal"><span class="pre">map(fn,</span> <span class="pre">lst[,</span> <span class="pre">...])</span></tt>:</dt>
<dd><p class="first">Return a new array composed of the results of <tt class="docutils literal"><span class="pre">fn(x)</span></tt> for every <tt class="docutils literal"><span class="pre">x</span></tt> in
<tt class="docutils literal"><span class="pre">lst</span></tt>.</p>
<p>If fn is <tt class="docutils literal"><span class="pre">null</span></tt>, and only one sequence argument is given the identity
function is used.</p>
<blockquote>
<tt class="docutils literal"><span class="pre">map(null,</span> <span class="pre">lst)</span></tt> -&gt; <tt class="docutils literal"><span class="pre">lst.slice()</span></tt>;</blockquote>
<p>If <tt class="docutils literal"><span class="pre">fn</span></tt> is <tt class="docutils literal"><span class="pre">null</span></tt>, and more than one sequence is given as arguments,
then the <tt class="docutils literal"><span class="pre">Array</span></tt> function is used, making it equivalent to <tt class="docutils literal"><span class="pre">zip</span></tt>.</p>
<blockquote class="last">
<dl class="docutils">
<dt><tt class="docutils literal"><span class="pre">map(null,</span> <span class="pre">p,</span> <span class="pre">q,</span> <span class="pre">...)</span></tt></dt>
<dd>-&gt; <tt class="docutils literal"><span class="pre">zip(p,</span> <span class="pre">q,</span> <span class="pre">...)</span></tt>
-&gt; <tt class="docutils literal"><span class="pre">[[p0,</span> <span class="pre">q0,</span> <span class="pre">...],</span> <span class="pre">[p1,</span> <span class="pre">q1,</span> <span class="pre">...],</span> <span class="pre">...];</span></tt></dd>
</dl>
</blockquote>
</dd>
<dt><tt class="docutils literal"><span class="pre">xfilter(fn,</span> <span class="pre">obj[,</span> <span class="pre">...])</span></tt>:</dt>
<dd><p class="first">Returns a new <tt class="docutils literal"><span class="pre">Array</span></tt> composed of the arguments where
<tt class="docutils literal"><span class="pre">fn(obj)</span></tt> returns a true value.</p>
<p class="last">If <tt class="docutils literal"><span class="pre">fn</span></tt> is <tt class="docutils literal"><span class="pre">null</span></tt>, <tt class="docutils literal"><span class="pre">operator.truth</span></tt> will be used.</p>
</dd>
<dt><tt class="docutils literal"><span class="pre">filter(fn,</span> <span class="pre">lst)</span></tt>:</dt>
<dd><p class="first">Returns a new <tt class="docutils literal"><span class="pre">Array</span></tt> composed of all elements from <tt class="docutils literal"><span class="pre">lst</span></tt> where
<tt class="docutils literal"><span class="pre">fn(lst[i])</span></tt> returns a true value.</p>
<p class="last">If <tt class="docutils literal"><span class="pre">fn</span></tt> is <tt class="docutils literal"><span class="pre">null</span></tt>, <tt class="docutils literal"><span class="pre">operator.truth</span></tt> will be used.</p>
</dd>
<dt><tt class="docutils literal"><span class="pre">bind(func,</span> <span class="pre">self)</span></tt>:</dt>
<dd><p class="first">Return a copy of <tt class="docutils literal"><span class="pre">func</span></tt> bound to <tt class="docutils literal"><span class="pre">self</span></tt>.  This means whenever
and however the returned function is called, <tt class="docutils literal"><span class="pre">this</span></tt> will always
reference the given <tt class="docutils literal"><span class="pre">self</span></tt>.</p>
<p class="last">Calling <tt class="docutils literal"><span class="pre">bind(func,</span> <span class="pre">self)</span></tt> on an already bound function will
return a new function that is bound to the new <tt class="docutils literal"><span class="pre">self</span></tt>!</p>
</dd>
<dt><tt class="docutils literal"><span class="pre">bindMethods(self)</span></tt>:</dt>
<dd>Bind all methods of <tt class="docutils literal"><span class="pre">self</span></tt> present on self to <tt class="docutils literal"><span class="pre">self</span></tt>,
which gives you a semi-Pythonic sort of instance.</dd>
<dt><tt class="docutils literal"><span class="pre">registerComparator(name,</span> <span class="pre">check,</span> <span class="pre">comparator[,</span> <span class="pre">override])</span></tt>:</dt>
<dd><p class="first">Register a comparator for use with <tt class="docutils literal"><span class="pre">compare</span></tt>.</p>
<p><tt class="docutils literal"><span class="pre">name</span></tt> should be a unique identifier describing the comparator.</p>
<p><tt class="docutils literal"><span class="pre">check</span></tt> is a <tt class="docutils literal"><span class="pre">function(a,</span> <span class="pre">b)</span></tt> that returns <tt class="docutils literal"><span class="pre">true</span></tt> if <tt class="docutils literal"><span class="pre">a</span></tt> and <tt class="docutils literal"><span class="pre">b</span></tt>
can be compared with <tt class="docutils literal"><span class="pre">comparator</span></tt>.</p>
<p><tt class="docutils literal"><span class="pre">comparator</span></tt> is a <tt class="docutils literal"><span class="pre">function(a,</span> <span class="pre">b)</span></tt> that returns:</p>
<table border="1" class="docutils">
<colgroup>
<col width="39%" />
<col width="61%" />
</colgroup>
<tbody valign="top">
<tr><td>Value</td>
<td>Condition</td>
</tr>
<tr><td>0</td>
<td>a == b</td>
</tr>
<tr><td>1</td>
<td>a &gt; b</td>
</tr>
<tr><td>-1</td>
<td>a &lt; b</td>
</tr>
</tbody>
</table>
<p><tt class="docutils literal"><span class="pre">comparator</span></tt> is guaranteed to only be called if <tt class="docutils literal"><span class="pre">check(a,</span> <span class="pre">b)</span></tt>
returns a <tt class="docutils literal"><span class="pre">true</span></tt> value.</p>
<p class="last">If <tt class="docutils literal"><span class="pre">override</span></tt> is <tt class="docutils literal"><span class="pre">true</span></tt>, then it will be made the
highest precedence comparator.  Otherwise, the lowest.</p>
</dd>
<dt><tt class="docutils literal"><span class="pre">compare(a,</span> <span class="pre">b)</span></tt>:</dt>
<dd><p class="first">Compare two objects in a sensible manner.  Currently this is:</p>
<blockquote>
<ol class="arabic simple">
<li><tt class="docutils literal"><span class="pre">undefined</span></tt> and <tt class="docutils literal"><span class="pre">null</span></tt> compare equal to each other</li>
<li><tt class="docutils literal"><span class="pre">undefined</span></tt> and <tt class="docutils literal"><span class="pre">null</span></tt> are less than anything else</li>
<li>If JavaScript says <tt class="docutils literal"><span class="pre">a</span> <span class="pre">==</span> <span class="pre">b</span></tt>, then we trust it</li>
<li>comparators registered with registerComparator are
used to find a good comparator.  Built-in comparators
are currently available for <tt class="docutils literal"><span class="pre">Array</span></tt>-like and <tt class="docutils literal"><span class="pre">Date</span></tt>-like
objects.</li>
<li>Otherwise hope that the built-in comparison operators
do something useful, which should work for numbers
and strings.</li>
<li>If neither <tt class="docutils literal"><span class="pre">a</span> <span class="pre">&lt;</span> <span class="pre">b</span></tt> or <tt class="docutils literal"><span class="pre">a</span> <span class="pre">&gt;</span> <span class="pre">b</span></tt>, then throw a <tt class="docutils literal"><span class="pre">TypeError</span></tt></li>
</ol>
</blockquote>
<p>Returns what one would expect from a comparison function:</p>
<table border="1" class="last docutils">
<colgroup>
<col width="39%" />
<col width="61%" />
</colgroup>
<tbody valign="top">
<tr><td>Value</td>
<td>Condition</td>
</tr>
<tr><td>0</td>
<td>a == b</td>
</tr>
<tr><td>1</td>
<td>a &gt; b</td>
</tr>
<tr><td>-1</td>
<td>a &lt; b</td>
</tr>
</tbody>
</table>
</dd>
<dt><tt class="docutils literal"><span class="pre">registerRepr(name,</span> <span class="pre">check,</span> <span class="pre">wrap[,</span> <span class="pre">override])</span></tt>:</dt>
<dd><p class="first">Register a programmer representation function.
<tt class="docutils literal"><span class="pre">repr</span></tt> functions should take one argument and 
return a string representation of it
suitable for developers, primarily used when debugging.</p>
<p class="last">If <tt class="docutils literal"><span class="pre">override</span></tt> is given, it is used as the highest priority
repr, otherwise it will be used as the lowest.</p>
</dd>
<dt><tt class="docutils literal"><span class="pre">repr(o)</span></tt>:</dt>
<dd>Return a programmer representation for an object.  See the
<a class="reference" href="#programmer-representation">Programmer Representation</a> overview for more information about this
function.</dd>
<dt><tt class="docutils literal"><span class="pre">objEqual(a,</span> <span class="pre">b)</span></tt>:</dt>
<dd>Compare the equality of two objects.</dd>
<dt><tt class="docutils literal"><span class="pre">arrayEqual(self,</span> <span class="pre">arr)</span></tt>:</dt>
<dd>Compare two arrays for equality, with a fast-path for length
differences.</dd>
<dt><tt class="docutils literal"><span class="pre">concat(lst[,</span> <span class="pre">...])</span></tt>:</dt>
<dd><p class="first">Concatenates all given array-like arguments and returns
a new <tt class="docutils literal"><span class="pre">Array</span></tt>:</p>
<pre class="last literal-block">
var lst = concat([&quot;1&quot;,&quot;3&quot;,&quot;5&quot;], [&quot;2&quot;,&quot;4&quot;,&quot;6&quot;]);
assert( lst.toString() == &quot;1,3,5,2,4,6&quot; );
</pre>
</dd>
<dt><tt class="docutils literal"><span class="pre">keyComparator(key[,</span> <span class="pre">...])</span></tt>:</dt>
<dd><p class="first">A comparator factory that compares <tt class="docutils literal"><span class="pre">a[key]</span></tt> with <tt class="docutils literal"><span class="pre">b[key]</span></tt>.
e.g.:</p>
<pre class="last literal-block">
var lst = [&quot;a&quot;, &quot;bbb&quot;, &quot;cc&quot;];
lst.sort(keyComparator(&quot;length&quot;));
assert( lst.toString() == &quot;a,cc,bbb&quot; );
</pre>
</dd>
<dt><tt class="docutils literal"><span class="pre">reverseKeyComparator(key)</span></tt>:</dt>
<dd><p class="first">A comparator factory that compares <tt class="docutils literal"><span class="pre">a[key]</span></tt> with <tt class="docutils literal"><span class="pre">b[key]</span></tt> in reverse.
e.g.:</p>
<pre class="last literal-block">
var lst = [&quot;a&quot;, &quot;bbb&quot;, &quot;cc&quot;];
lst.sort(reverseKeyComparator(&quot;length&quot;));
assert(lst.toString() == &quot;bbb,cc,aa&quot;);
</pre>
</dd>
<dt><tt class="docutils literal"><span class="pre">partial(func,</span> <span class="pre">arg[,</span> <span class="pre">...])</span></tt>:</dt>
<dd><p class="first">Return a partially applied function, e.g.:</p>
<pre class="literal-block">
addNumbers = function (a, b) {
    return a + b;
}

addOne = partial(addNumbers, 1);

assert(addOne(2) == 3);
</pre>
<p class="last"><em>NOTE</em>: This could be used to implement, but is NOT currying.</p>
</dd>
<dt><tt class="docutils literal"><span class="pre">listMinMax(which,</span> <span class="pre">lst)</span></tt>:</dt>
<dd><p class="first">If <tt class="docutils literal"><span class="pre">which</span> <span class="pre">==</span> <span class="pre">-1</span></tt> then it will return the smallest
element of the <tt class="docutils literal"><span class="pre">Array</span></tt>-like <tt class="docutils literal"><span class="pre">lst</span></tt>.  This is also available
as <tt class="docutils literal"><span class="pre">listMin(lst)</span></tt>.</p>
<p class="last">If <tt class="docutils literal"><span class="pre">which</span> <span class="pre">==</span> <span class="pre">1</span></tt> then it will return the largest
element of the array-like lst.  This is also available
as <tt class="docutils literal"><span class="pre">listMax(list)</span></tt>.</p>
</dd>
<dt><tt class="docutils literal"><span class="pre">listMin(lst)</span></tt>:</dt>
<dd>Return the smallest element of an <tt class="docutils literal"><span class="pre">Array</span></tt>-like object, as determined
by <tt class="docutils literal"><span class="pre">compare</span></tt>.  This is a special form of <tt class="docutils literal"><span class="pre">listMinMax</span></tt>, specifically
<tt class="docutils literal"><span class="pre">partial(listMinMax,</span> <span class="pre">-1)</span></tt>.</dd>
<dt><tt class="docutils literal"><span class="pre">listMax(lst)</span></tt>:</dt>
<dd>Return the largest element of an <tt class="docutils literal"><span class="pre">Array</span></tt>-like object, as determined
by <tt class="docutils literal"><span class="pre">compare</span></tt>.  This is a special form of <tt class="docutils literal"><span class="pre">listMinMax</span></tt>, specifically
<tt class="docutils literal"><span class="pre">partial(listMinMax,</span> <span class="pre">1)</span></tt>.</dd>
<dt><tt class="docutils literal"><span class="pre">objMax(obj[,</span> <span class="pre">...])</span></tt>:</dt>
<dd>Return the maximum object out of the given arguments.  This is similar to
<tt class="docutils literal"><span class="pre">listMax</span></tt>, except is uses the arguments instead of a given
<tt class="docutils literal"><span class="pre">Array</span></tt>-like.</dd>
<dt><tt class="docutils literal"><span class="pre">objMin(obj[,</span> <span class="pre">...])</span></tt>:</dt>
<dd>Return the minimum object out of the given arguments.  This is similar
to <tt class="docutils literal"><span class="pre">listMin</span></tt>, except it uses the arguments instead of a given
<tt class="docutils literal"><span class="pre">Array</span></tt>-like.</dd>
<dt><tt class="docutils literal"><span class="pre">nodeWalk(node,</span> <span class="pre">visitor)</span></tt>:</dt>
<dd><p class="first">Non-recursive generic node walking function (e.g. for a DOM)</p>
<dl class="last docutils">
<dt><tt class="docutils literal"><span class="pre">node</span></tt>:</dt>
<dd>The initial node to be searched.</dd>
<dt><tt class="docutils literal"><span class="pre">visitor</span></tt>:</dt>
<dd>The visitor function, will be called as
<tt class="docutils literal"><span class="pre">visitor(node)</span></tt>, and should return an <tt class="docutils literal"><span class="pre">Array</span></tt>-like
of nodes to be searched next (e.g.  <tt class="docutils literal"><span class="pre">node.childNodes</span></tt>).</dd>
</dl>
</dd>
<dt><tt class="docutils literal"><span class="pre">nameFunctions(namespace)</span></tt>:</dt>
<dd><p class="first">Given a namespace with a <tt class="docutils literal"><span class="pre">NAME</span></tt> property, find all functions in it and
give them nice <tt class="docutils literal"><span class="pre">NAME</span></tt> properties too (for use with <tt class="docutils literal"><span class="pre">repr</span></tt>).  e.g.:</p>
<pre class="last literal-block">
namespace = {
    NAME: &quot;Awesome&quot;,
    Dude: function () {}
}
nameFunctions(namespace);
assert( namespace.Dude.NAME == 'Awesome.Dude' );
</pre>
</dd>
</dl>
</div>
</div>
<div class="section" id="authors">
<h1><a name="authors">Authors</a></h1>
<ul class="simple">
<li>Bob Ippolito &lt;<a class="reference" href="mailto:bob&#64;redivi.com">bob&#64;redivi.com</a>&gt;</li>
</ul>
</div>
<div class="section" id="copyright">
<h1><a name="copyright">Copyright</a></h1>
<p>Copyright 2005 Bob Ippolito &lt;<a class="reference" href="mailto:bob&#64;redivi.com">bob&#64;redivi.com</a>&gt;.  This program is free software;
you can redistribute it and/or modify it under the terms of the
<a class="reference" href="http://www.opensource.org/licenses/mit-license.php">MIT License</a>.</p>
</div>
</div>
</body>
</html>
