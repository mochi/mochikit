<?xml version="1.0" encoding="utf8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf8" />
<meta name="generator" content="Docutils 0.3.10: http://docutils.sourceforge.net/" />
<title></title>
<link rel="stylesheet" href="../../../include/css/documentation.css" type="text/css" />
</head>
<body>
<div class="document">
<!-- -*- mode: rst -*- -->
<div class="section" id="name">
<h1><a name="name">Name</a></h1>
<p>MochiKit.Iter - itertools for JavaScript; iteration made HARD, and then easy</p>
</div>
<div class="section" id="synopsis">
<h1><a name="synopsis">Synopsis</a></h1>
<pre class="literal-block">
theSum = sum(ifilter(
        partial(operator.gt, 10),
        imap(
            partial(operator.mul, 2),
            count()
        )
    )
));

assert( theSum == (0 + 0 + 2 + 4 + 6 + 8) );
</pre>
</div>
<div class="section" id="description">
<h1><a name="description">Description</a></h1>
<p>All of the functional programming missing from <a class="reference" href="Base.html">MochiKit.Base</a> lives here.
The functionality in this module is largely inspired by Python's iteration
protocol <a class="footnote-reference" href="#id4" id="id1" name="id1">[1]</a>, and the itertools module <a class="footnote-reference" href="#id5" id="id2" name="id2">[2]</a>.</p>
<p>MochiKit.Iter defines a standard way to iterate over anything, that you can
extend with <tt class="docutils literal"><span class="pre">registerIterator</span></tt>, or by implementing the <tt class="docutils literal"><span class="pre">.iter()</span></tt> protocol.
Iterators are lazy, so it can potentially be cheaper to built a filter
chain of iterators than to build lots of intermediate arrays.  Especially
when the data set is very large, but the result is not.</p>
</div>
<div class="section" id="dependencies">
<h1><a name="dependencies">Dependencies</a></h1>
<ul class="simple">
<li><a class="reference" href="Base.html">MochiKit.Base</a></li>
</ul>
</div>
<div class="section" id="overview">
<h1><a name="overview">Overview</a></h1>
<div class="section" id="iteration-for-javascript">
<h2><a name="iteration-for-javascript">Iteration for JavaScript</a></h2>
<p>The best overview right now is in my Iteration for JavaScript <a class="footnote-reference" href="#id6" id="id3" name="id3">[3]</a> blog entry.
This information will migrate here eventually.</p>
</div>
</div>
<div class="section" id="api-reference">
<h1><a name="api-reference">API Reference</a></h1>
<div class="section" id="errors">
<h2><a name="errors">Errors</a></h2>
<dl class="docutils">
<dt><tt class="docutils literal"><span class="pre">StopIteration</span></tt>:</dt>
<dd>The singleton <tt class="docutils literal"><span class="pre">NamedError</span></tt> that signifies the end of an iterator</dd>
</dl>
</div>
<div class="section" id="functions">
<h2><a name="functions">Functions</a></h2>
<p><tt class="docutils literal"><span class="pre">registerIteratorFactory(name,</span> <span class="pre">check,</span> <span class="pre">iterfactory[,</span> <span class="pre">override])</span></tt>:</p>
<blockquote>
<p>Register an iterator factory for use with the iter function.</p>
<p><tt class="docutils literal"><span class="pre">check</span></tt> is a <tt class="docutils literal"><span class="pre">function(a)</span></tt> that returns <tt class="docutils literal"><span class="pre">true</span></tt> if <tt class="docutils literal"><span class="pre">a</span></tt> can be
converted into an iterator with <tt class="docutils literal"><span class="pre">iterfactory</span></tt>.</p>
<p><tt class="docutils literal"><span class="pre">iterfactory</span></tt> is a <tt class="docutils literal"><span class="pre">function(a)</span></tt> that returns an object with a
<tt class="docutils literal"><span class="pre">.next()</span></tt> method that returns the next value in the sequence.</p>
<p><tt class="docutils literal"><span class="pre">iterfactory</span></tt> is guaranteed to only be called if <tt class="docutils literal"><span class="pre">check(a)</span></tt>
returns a true value.</p>
<p>If <tt class="docutils literal"><span class="pre">override</span></tt> is <tt class="docutils literal"><span class="pre">true</span></tt>, then it will be made the
highest precedence iterator factory.  Otherwise, the lowest.</p>
</blockquote>
<p><tt class="docutils literal"><span class="pre">iter(iterable[,</span> <span class="pre">sentinel])</span></tt>:</p>
<blockquote>
<p>Convert the given argument to an iterator (object implementing
<tt class="docutils literal"><span class="pre">.next()</span></tt>).</p>
<ol class="arabic simple">
<li>If <tt class="docutils literal"><span class="pre">iterable</span></tt> is an iterator (implements <tt class="docutils literal"><span class="pre">.next()</span></tt>), then it will
be returned as-is.</li>
<li>If <tt class="docutils literal"><span class="pre">iterable</span></tt> is an iterator factory (implements <tt class="docutils literal"><span class="pre">.iter()</span></tt>), then
the result of <tt class="docutils literal"><span class="pre">iterable.iter()</span></tt> will be returned.</li>
<li>Otherwise, the iterator factory <tt class="docutils literal"><span class="pre">AdapterRegistry</span></tt> is used to find a 
match.</li>
<li>If no factory is found, it will throw <tt class="docutils literal"><span class="pre">TypeError</span></tt></li>
</ol>
<p>When used directly, using an iterator should look like this:</p>
<pre class="literal-block">
var it = iter(iterable);
try {
    while (var o = it.next()) {
        // use o
    }
} catch (e) {
    if (e != StopIteration) {
        throw e;
    }
    // pass
}
</pre>
<p>This is ugly, so you should use the higher order funtions to work
with iterators whenever possible.</p>
</blockquote>
<p><tt class="docutils literal"><span class="pre">count(n)</span></tt>:</p>
<blockquote>
<tt class="docutils literal"><span class="pre">count([n])</span></tt> --&gt; n, n + 1, n + 2, ...</blockquote>
<p><tt class="docutils literal"><span class="pre">cycle(p)</span></tt>:</p>
<blockquote>
<tt class="docutils literal"><span class="pre">cycle(p)</span></tt> --&gt; p0, p1, ... plast, p0, p1, ...</blockquote>
<p><tt class="docutils literal"><span class="pre">repeat(elem[,</span> <span class="pre">n])</span></tt>:</p>
<blockquote>
<tt class="docutils literal"><span class="pre">repeat(elem,</span> <span class="pre">[,n])</span></tt> --&gt; elem, elem, elem, ... endlessly or up to n times</blockquote>
<p><tt class="docutils literal"><span class="pre">next(iterator)</span></tt>:</p>
<blockquote>
Return <tt class="docutils literal"><span class="pre">iterator.next()</span></tt></blockquote>
<p><tt class="docutils literal"><span class="pre">izip(p,</span> <span class="pre">q[,</span> <span class="pre">...])</span></tt>:</p>
<blockquote>
<tt class="docutils literal"><span class="pre">izip(p,</span> <span class="pre">q,</span> <span class="pre">...)</span></tt> --&gt; [p0, q0, ...], [p1, q1, ...], ...</blockquote>
<p><tt class="docutils literal"><span class="pre">ifilter(pred,</span> <span class="pre">seq)</span></tt>:</p>
<blockquote>
<tt class="docutils literal"><span class="pre">ifilter(pred,</span> <span class="pre">seq)</span></tt> --&gt; elements of seq where <tt class="docutils literal"><span class="pre">pred(elem)</span></tt> is <tt class="docutils literal"><span class="pre">true</span></tt></blockquote>
<p><tt class="docutils literal"><span class="pre">ifilterfalse(pred,</span> <span class="pre">seq)</span></tt>:</p>
<blockquote>
<dl class="docutils">
<dt><tt class="docutils literal"><span class="pre">ifilterfalse(pred,</span> <span class="pre">seq)</span></tt> --&gt; elements of seq where <tt class="docutils literal"><span class="pre">pred(elem)</span></tt> is</dt>
<dd><tt class="docutils literal"><span class="pre">false</span></tt></dd>
</dl>
</blockquote>
<p><tt class="docutils literal"><span class="pre">islice(seq,</span> <span class="pre">[start,]</span> <span class="pre">stop[,</span> <span class="pre">step])</span></tt>:</p>
<blockquote>
<dl class="docutils">
<dt><tt class="docutils literal"><span class="pre">islice(seq,</span> <span class="pre">[start,]</span> <span class="pre">stop[,</span> <span class="pre">step])</span></tt> --&gt; elements from </dt>
<dd>seq[start:stop:step] (in Python slice syntax)</dd>
</dl>
</blockquote>
<p><tt class="docutils literal"><span class="pre">imap(fun,</span> <span class="pre">p,</span> <span class="pre">q[,</span> <span class="pre">...])</span></tt>:</p>
<blockquote>
<tt class="docutils literal"><span class="pre">imap(fun,</span> <span class="pre">p,</span> <span class="pre">q,</span> <span class="pre">...)</span></tt> --&gt; fun(p0, q0, ...), fun(p1, q1, ...), ...</blockquote>
<p><tt class="docutils literal"><span class="pre">applymap(fun,</span> <span class="pre">seq[,</span> <span class="pre">self])</span></tt>:</p>
<blockquote>
<dl class="docutils">
<dt><tt class="docutils literal"><span class="pre">applymap(fun,</span> <span class="pre">seq)</span></tt> --&gt;</dt>
<dd>fun.apply(self, seq0), fun.apply(self, seq1), ...</dd>
</dl>
</blockquote>
<p><tt class="docutils literal"><span class="pre">chain(p,</span> <span class="pre">q[,</span> <span class="pre">...])</span></tt>:</p>
<blockquote>
<tt class="docutils literal"><span class="pre">chain(p,</span> <span class="pre">q,</span> <span class="pre">...)</span></tt> --&gt; p0, p1, ... plast, q0, q1, ...</blockquote>
<p><tt class="docutils literal"><span class="pre">takewhile(pred,</span> <span class="pre">seq)</span></tt>:</p>
<blockquote>
<tt class="docutils literal"><span class="pre">takewhile(pred,</span> <span class="pre">seq)</span></tt> --&gt; seq[0], seq[1], ... until pred(seq[n]) fails</blockquote>
<p><tt class="docutils literal"><span class="pre">dropwhile(pred,</span> <span class="pre">seq)</span></tt>:</p>
<blockquote>
<dl class="docutils">
<dt><tt class="docutils literal"><span class="pre">dropwhile(pred,</span> <span class="pre">seq)</span></tt> --&gt; seq[n], seq[n + 1], starting when</dt>
<dd>pred(seq[n]) fails</dd>
</dl>
</blockquote>
<p><tt class="docutils literal"><span class="pre">tee(iterable,</span> <span class="pre">n=2)</span></tt>:</p>
<blockquote>
<tt class="docutils literal"><span class="pre">tee(it,</span> <span class="pre">n=2)</span></tt> --&gt; [it1, it2, it3, ... itn] splits one iterator into n</blockquote>
<p><tt class="docutils literal"><span class="pre">list(iterable)</span></tt>:</p>
<blockquote>
Convert <tt class="docutils literal"><span class="pre">iterable</span></tt> to a new <tt class="docutils literal"><span class="pre">Array</span></tt></blockquote>
<p><tt class="docutils literal"><span class="pre">reduce(fn,</span> <span class="pre">iterable[,</span> <span class="pre">initial])</span></tt>:</p>
<blockquote>
<p>Apply <tt class="docutils literal"><span class="pre">fn(a,</span> <span class="pre">b)</span></tt> cumulatively to the items of an
iterable from left to right, so as to reduce the iterable
to a single value.</p>
<p>For example:</p>
<pre class="literal-block">
reduce(function (a, b) { return x + y; }, [1, 2, 3, 4, 5])
</pre>
<p>calculates:</p>
<pre class="literal-block">
((((1 + 2) + 3) + 4) + 5).
</pre>
<p>If initial is given, it is placed before the items of the sequence
in the calculation, and serves as a default when the sequence is
empty.</p>
<p>Note that the above example could be written more clearly as:</p>
<pre class="literal-block">
reduce(operator.add, [1, 2, 3, 4, 5])
</pre>
<p>Or even simpler:</p>
<pre class="literal-block">
sum([1, 2, 3, 4, 5])
</pre>
</blockquote>
<p><tt class="docutils literal"><span class="pre">range([start,]</span> <span class="pre">stop[,</span> <span class="pre">step])</span></tt>:</p>
<blockquote>
<p>Return an iterator containing an arithmetic progression of integers.</p>
<p><tt class="docutils literal"><span class="pre">range(i,</span> <span class="pre">j)</span></tt> returns <tt class="docutils literal"><span class="pre">iter([i,</span> <span class="pre">i</span> <span class="pre">+</span> <span class="pre">1,</span> <span class="pre">i</span> <span class="pre">+</span> <span class="pre">2,</span> <span class="pre">...,</span> <span class="pre">j</span> <span class="pre">-</span> <span class="pre">1]);</span></tt></p>
<p><tt class="docutils literal"><span class="pre">start</span></tt> (!) defaults to <tt class="docutils literal"><span class="pre">0</span></tt>.  When <tt class="docutils literal"><span class="pre">step</span></tt> is given, it specifies the
increment (or decrement).  The end point is omitted!</p>
<p>For example, <tt class="docutils literal"><span class="pre">range(4)</span></tt> returns <tt class="docutils literal"><span class="pre">iter([0,</span> <span class="pre">1,</span> <span class="pre">2,</span> <span class="pre">3])</span></tt>.
This iterates over exactly the valid indexes for an array of 4 elements.</p>
</blockquote>
<p><tt class="docutils literal"><span class="pre">sum(iterable,</span> <span class="pre">start=0)</span></tt>:</p>
<blockquote>
<p>Returns the sum of a sequence of numbers plus the value
of parameter <tt class="docutils literal"><span class="pre">start</span></tt> (with a default of 0).  When the sequence is
empty, returns start.</p>
<p>Equivalent to:</p>
<pre class="literal-block">
reduce(operator.add, iterable, start);
</pre>
</blockquote>
<p><tt class="docutils literal"><span class="pre">exhaust(iterable)</span></tt>:</p>
<blockquote>
Exhausts an iterable without saving the results anywhere,
like <tt class="docutils literal"><span class="pre">list(iterable)</span></tt> when you don't care what the output is.</blockquote>
<p><tt class="docutils literal"><span class="pre">forEach(iterable,</span> <span class="pre">func[,</span> <span class="pre">self])</span></tt>:</p>
<blockquote>
Call <tt class="docutils literal"><span class="pre">func</span></tt> for each item in <tt class="docutils literal"><span class="pre">iterable</span></tt>, and don't save the results.</blockquote>
<p><tt class="docutils literal"><span class="pre">every(iterable,</span> <span class="pre">func)</span></tt>:</p>
<blockquote>
Return <tt class="docutils literal"><span class="pre">true</span></tt> if <tt class="docutils literal"><span class="pre">func(item)</span></tt> is <tt class="docutils literal"><span class="pre">true</span></tt> for every item in
<tt class="docutils literal"><span class="pre">iterable</span></tt>.</blockquote>
<p><tt class="docutils literal"><span class="pre">sorted(iterable[,</span> <span class="pre">cmp])</span></tt>:</p>
<blockquote>
Return a sorted array from iterable.</blockquote>
<p><tt class="docutils literal"><span class="pre">reversed(iterable)</span></tt>:</p>
<blockquote>
Return a reversed array from iterable.</blockquote>
<p><tt class="docutils literal"><span class="pre">some(iterable,</span> <span class="pre">func)</span></tt>:</p>
<blockquote>
Return <tt class="docutils literal"><span class="pre">true</span></tt> if <tt class="docutils literal"><span class="pre">func(item)</span></tt> is <tt class="docutils literal"><span class="pre">true</span></tt> for at least one item in
<tt class="docutils literal"><span class="pre">iterable</span></tt>.</blockquote>
<p><tt class="docutils literal"><span class="pre">iextend(lst,</span> <span class="pre">iterable)</span></tt>:</p>
<blockquote>
Just like <tt class="docutils literal"><span class="pre">list(iterable)</span></tt>, except it pushes results on <tt class="docutils literal"><span class="pre">lst</span></tt> rather
than creating a new one.</blockquote>
</div>
</div>
<div class="section" id="see-also">
<h1><a name="see-also">See Also</a></h1>
<table class="docutils footnote" frame="void" id="id4" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1" name="id4">[1]</a></td><td>The iteration protocol is described in 
PEP 234 - Iterators: <a class="reference" href="http://www.python.org/peps/pep-0234.html">http://www.python.org/peps/pep-0234.html</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id5" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id2" name="id5">[2]</a></td><td>Python's itertools
module: <a class="reference" href="http://docs.python.org/lib/module-itertools.html">http://docs.python.org/lib/module-itertools.html</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id6" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id3" name="id6">[3]</a></td><td>Iteration in JavaScript: <a class="reference" href="http://bob.pythonmac.org/archives/2005/07/06/iteration-in-javascript/">http://bob.pythonmac.org/archives/2005/07/06/iteration-in-javascript/</a></td></tr>
</tbody>
</table>
</div>
<div class="section" id="authors">
<h1><a name="authors">Authors</a></h1>
<ul class="simple">
<li>Bob Ippolito &lt;<a class="reference" href="mailto:bob&#64;redivi.com">bob&#64;redivi.com</a>&gt;</li>
</ul>
</div>
<div class="section" id="copyright">
<h1><a name="copyright">Copyright</a></h1>
<p>Copyright 2005 Bob Ippolito &lt;<a class="reference" href="mailto:bob&#64;redivi.com">bob&#64;redivi.com</a>&gt;.  This program is dual-licensed
free software; you can redistribute it and/or modify it under the terms of the
<a class="reference" href="http://www.opensource.org/licenses/mit-license.php">MIT License</a> or the <a class="reference" href="http://www.opensource.org/licenses/afl-2.1.php">Academic Free License v2.1</a>.</p>
</div>
</div>
</body>
</html>
