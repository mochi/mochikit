<?xml version="1.0" encoding="utf8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf8" />
<meta name="generator" content="Docutils 0.3.10: http://docutils.sourceforge.net/" />
<title></title>
<link rel="stylesheet" href="../../../include/css/documentation.css" type="text/css" />
</head>
<body>
<div class="document">
<!-- -*- mode: rst -*- -->
<div class="section" id="name">
<h1><a name="name">Name</a></h1>
<p>MochiKit.Async - manage asynchronous tasks</p>
</div>
<div class="section" id="synopsis">
<h1><a name="synopsis">Synopsis</a></h1>
<pre class="literal-block">
var url = &quot;/src/b/bo/bob/MochiKit.Async/META.json&quot;;
var d = loadJSONDoc(url);
var gotMetadata = function (meta) {
    if (MochiKit.Async.VERSION == meta.version) {
        alert(&quot;You have the newest MochiKit.Async!&quot;);
    } else {
        alert(&quot;MochiKit.Async &quot; 
            + meta.version
            + &quot; is available, upgrade!&quot;);
    }
};
var metadataFetchFailed = function (err) {
  alert(&quot;The metadata for MochiKit.Async could not be fetched :(&quot;);
};
d.addCallbacks(gotMetadata, metadataFetchFailed);
</pre>
</div>
<div class="section" id="description">
<h1><a name="description">Description</a></h1>
<p>MochiKit.Async provides facilities to manage asynchronous
(as in AJAX <a class="footnote-reference" href="#id7" id="id1" name="id1">[1]</a>) tasks. The model for asynchronous computation
used in this module is heavily inspired by Twisted <a class="footnote-reference" href="#id8" id="id2" name="id2">[2]</a>.</p>
</div>
<div class="section" id="dependencies">
<h1><a name="dependencies">Dependencies</a></h1>
<ul class="simple">
<li><a class="reference" href="Base.html">MochiKit.Base</a></li>
</ul>
</div>
<div class="section" id="overview">
<h1><a name="overview">Overview</a></h1>
<div class="section" id="deferred">
<h2><a name="deferred">Deferred</a></h2>
<p>The Deferred constructor encapsulates a single value that
is not available yet.  The most important example of this
in the context of a web browser would be an <tt class="docutils literal"><span class="pre">XMLHttpRequest</span></tt>
to a server.  The importance of the Deferred is that it
allows a consistent API to be exposed for all asynchronous
computations that occur exactly once.</p>
<p>The producer of the Deferred is responsible for doing all
of the complicated work behind the scenes.  This often
means waiting for a timer to fire, or waiting for an event
(e.g. <tt class="docutils literal"><span class="pre">onreadystatechange</span></tt> of <tt class="docutils literal"><span class="pre">XMLHttpRequest</span></tt>).  
It could also be coordinating several events (e.g.
<tt class="docutils literal"><span class="pre">XMLHttpRequest</span></tt> with a timeout, or several Deferreds
(e.g. fetching a set of XML documents that should be 
processed at the same time).</p>
<p>Since these sorts of tasks do not respond immediately, the
producer of the Deferred does the following steps before
returning to the consumer:</p>
<ol class="arabic simple">
<li>Create a <tt class="docutils literal"><span class="pre">new</span> <span class="pre">Deferred();</span></tt> object and keep a reference
to it, because it will be needed later when the value is
ready.</li>
<li>Setup the conditions to create the value requested (e.g.
create a new <tt class="docutils literal"><span class="pre">XMLHttpRequest</span></tt>, set its 
<tt class="docutils literal"><span class="pre">onreadystatechange</span></tt>).</li>
<li>Return the Deferred object.</li>
</ol>
<p>Since the value is not yet ready, the consumer attaches
a function to the Deferred that will be called when the
value is ready.  This is not unlike <tt class="docutils literal"><span class="pre">setTimeout</span></tt>, or
other similar facilities you may already be familiar with.
The consumer can also attach an &quot;errback&quot; to the Deferred,
which is a callback for error handling.</p>
<p>When the value is ready, the producer simply calls
<tt class="docutils literal"><span class="pre">myDeferred.callback(theValue)</span></tt>.  If an error occurred,
it should call <tt class="docutils literal"><span class="pre">myDeferred.errback(theValue)</span></tt> instead.
As soon as this happens, the callback that the consumer
attached to the Deferred is called with <tt class="docutils literal"><span class="pre">theValue</span></tt>
as the only argument.</p>
<p>There are quite a few additional &quot;advanced&quot; features
baked into Deferred, such as cancellation and 
callback chains, so take a look at the API
reference if you would like to know more!</p>
</div>
</div>
<div class="section" id="api-reference">
<h1><a name="api-reference">API Reference</a></h1>
<div class="section" id="errors">
<h2><a name="errors">Errors</a></h2>
<p><tt class="docutils literal"><span class="pre">AlreadyCalledError</span></tt>:</p>
<blockquote>
Thrown by a <tt class="docutils literal"><span class="pre">Deferred</span></tt> if <tt class="docutils literal"><span class="pre">.callback</span></tt> or
<tt class="docutils literal"><span class="pre">.errback</span></tt> are called more than once.</blockquote>
<p><tt class="docutils literal"><span class="pre">CancelledError</span></tt>:</p>
<blockquote>
Thrown by a <tt class="docutils literal"><span class="pre">Deferred</span></tt> when it is cancelled,
unless a canceller is present and throws something else.</blockquote>
<p><tt class="docutils literal"><span class="pre">BrowserComplianceError</span></tt>:</p>
<blockquote>
Thrown when the JavaScript runtime is not capable of performing
the given function.  Currently, this happens if the browser
does not support <tt class="docutils literal"><span class="pre">XMLHttpRequest</span></tt>.</blockquote>
<p><tt class="docutils literal"><span class="pre">GenericError</span></tt>:</p>
<blockquote>
Results passed to <tt class="docutils literal"><span class="pre">.fail</span></tt> or <tt class="docutils literal"><span class="pre">.errback</span></tt> of a <tt class="docutils literal"><span class="pre">Deferred</span></tt>
are wrapped by this <tt class="docutils literal"><span class="pre">Error</span></tt> if <tt class="docutils literal"><span class="pre">!(result</span> <span class="pre">instanceof</span> <span class="pre">Error)</span></tt>.</blockquote>
<p><tt class="docutils literal"><span class="pre">XMLHttpRequestError</span></tt>:</p>
<blockquote>
Thrown when an <tt class="docutils literal"><span class="pre">XMLHttpRequest</span></tt> does not complete successfully
for any reason.</blockquote>
</div>
<div class="section" id="constructors">
<h2><a name="constructors">Constructors</a></h2>
<p><tt class="docutils literal"><span class="pre">Deferred()</span></tt>:</p>
<blockquote>
Encapsulates a sequence of callbacks in response to a value that
may not yet be available.  This is modeled after the Deferred class
from Twisted <a class="footnote-reference" href="#id9" id="id3" name="id3">[3]</a>.</blockquote>
<blockquote>
<p>Why do we want this?  JavaScript has no threads, and even if it did,
threads are hard.  Deferreds are a way of abstracting non-blocking
events, such as the final response to an <tt class="docutils literal"><span class="pre">XMLHttpRequest</span></tt>.</p>
<p>The sequence of callbacks is internally represented as a list
of 2-tuples containing the callback/errback pair.  For example,
the following call sequence:</p>
<pre class="literal-block">
var d = new Deferred();
d.addCallback(myCallback);
d.addErrback(myErrback);
d.addBoth(myBoth);
d.addCallbacks(myCallback, myErrback);
</pre>
<p>is translated into a <tt class="docutils literal"><span class="pre">Deferred</span></tt> with the following internal
representation:</p>
<pre class="literal-block">
[
    [myCallback, null],
    [null, myErrback],
    [myBoth, myBoth],
    [myCallback, myErrback]
]
</pre>
<p>The <tt class="docutils literal"><span class="pre">Deferred</span></tt> also keeps track of its current status (fired).
Its status may be one of the following three values:</p>
<blockquote>
<table border="1" class="docutils">
<colgroup>
<col width="14%" />
<col width="86%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">Value</th>
<th class="head">Condition</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>-1</td>
<td>no value yet (initial condition)</td>
</tr>
<tr><td>0</td>
<td>success</td>
</tr>
<tr><td>1</td>
<td>error</td>
</tr>
</tbody>
</table>
</blockquote>
<p>A <tt class="docutils literal"><span class="pre">Deferred</span></tt> will be in the error state if one of the following
three conditions are met:</p>
<ol class="arabic simple">
<li>The result given to callback or errback is &quot;<tt class="docutils literal"><span class="pre">instanceof</span> <span class="pre">Error</span></tt>&quot;</li>
<li>The callback or errback thew an <tt class="docutils literal"><span class="pre">Error</span></tt> while executing</li>
</ol>
<p>Otherwise, the <tt class="docutils literal"><span class="pre">Deferred</span></tt> will be in the success state.  The state of the
<tt class="docutils literal"><span class="pre">Deferred</span></tt> determines the next element in the callback sequence to run.</p>
<p>When a callback or errback occurs with the example deferred chain, something
equivalent to the following will happen (imagine that exceptions are caught
and returned as-is):</p>
<pre class="literal-block">
// d.callback(result) or d.errback(result)
if (!(result instanceof Error)) {
    result = myCallback(result);
}
if (result instanceof Error) {
    result = myErrback(result);
}
result = myBoth(result);
if (result instanceof Error) {
    result = myErrback(result);
} else {
    result = myCallback(result);
}
</pre>
<p>The result is then stored away in case another step is added to the
callback sequence.  Since the <tt class="docutils literal"><span class="pre">Deferred</span></tt> already has a value available,
any new callbacks added will be called immediately.</p>
<p>There are two other &quot;advanced&quot; details about this implementation that are 
useful:</p>
<p>Callbacks are allowed to return <tt class="docutils literal"><span class="pre">Deferred</span></tt> instances themselves, so
you can build complicated sequences of events with (relative) ease.</p>
<p>The creator of the <tt class="docutils literal"><span class="pre">Deferred</span></tt> may specify a canceller.  The canceller
is a function that will be called if <tt class="docutils literal"><span class="pre">Deferred.cancel</span></tt> is called
before the <tt class="docutils literal"><span class="pre">Deferred</span></tt> fires.  You can use this to allow an <tt class="docutils literal"><span class="pre">XMLHttpRequest</span></tt>
to be cleanly cancelled, for example.  Note that cancel will fire the
<tt class="docutils literal"><span class="pre">Deferred</span></tt> with a <tt class="docutils literal"><span class="pre">CancelledError</span></tt> (unless your canceller throws or
returns a different <tt class="docutils literal"><span class="pre">Error</span></tt>), so errbacks should be prepared to handle
that <tt class="docutils literal"><span class="pre">Error</span></tt> gracefully for cancellable <tt class="docutils literal"><span class="pre">Deferreds</span></tt>.</p>
</blockquote>
<p><tt class="docutils literal"><span class="pre">Deferred.prototype.cancel()</span></tt>:</p>
<blockquote>
<p>Cancels a <tt class="docutils literal"><span class="pre">Deferred</span></tt> that has not yet received a value,
or is waiting on another <tt class="docutils literal"><span class="pre">Deferred</span></tt> as its value.</p>
<p>If a canceller is defined, the canceller is called.
If the canceller did not return an <tt class="docutils literal"><span class="pre">Error</span></tt>, or there
was no canceller, then the errback chain is started
with <tt class="docutils literal"><span class="pre">CancelledError</span></tt>.</p>
</blockquote>
<p><tt class="docutils literal"><span class="pre">Deferred.prototype.callback([result])</span></tt>:</p>
<blockquote>
<p>Begin the callback sequence with a non-<tt class="docutils literal"><span class="pre">Error</span></tt> result.</p>
<p><em>NOTE</em>: Either <tt class="docutils literal"><span class="pre">.callback</span></tt> or <tt class="docutils literal"><span class="pre">.errback</span></tt> should
be called exactly once on a <tt class="docutils literal"><span class="pre">Deferred</span></tt>.</p>
</blockquote>
<p><tt class="docutils literal"><span class="pre">Deferred.prototype.errback([result])</span></tt>:</p>
<blockquote>
<p>Begin the callback sequence with an error result.  If 
<tt class="docutils literal"><span class="pre">!(result</span> <span class="pre">instanceof</span> <span class="pre">Error)</span></tt>, it will be wrapped
with <tt class="docutils literal"><span class="pre">GenericError</span></tt>.</p>
<p><em>NOTE</em>: Either <tt class="docutils literal"><span class="pre">.callback</span></tt> or <tt class="docutils literal"><span class="pre">.errback</span></tt> should
be called exactly once on a <tt class="docutils literal"><span class="pre">Deferred</span></tt>.</p>
</blockquote>
<p><tt class="docutils literal"><span class="pre">Deferred.prototype.addBoth(func)</span></tt>:</p>
<blockquote>
Add the same function as both a callback and an errback as the
next element on the callback sequence.  This is useful for code
that you want to guarantee to run, e.g. a finalizer.</blockquote>
<p><tt class="docutils literal"><span class="pre">Deferred.prototype.addCallback(func)</span></tt>:</p>
<blockquote>
Add a single callback to the end of the callback sequence.</blockquote>
<p><tt class="docutils literal"><span class="pre">Deferred.prototype.addErrback(func)</span></tt>:</p>
<blockquote>
Add a single errback to the end of the callback sequence.</blockquote>
<p><tt class="docutils literal"><span class="pre">Deferred.prototype.addCallbacks(callback,</span> <span class="pre">errback)</span></tt>:</p>
<blockquote>
Add separate callback and errback to the end of the callback
sequence.  Either callback or errback may be <tt class="docutils literal"><span class="pre">null</span></tt>,
but not both.</blockquote>
</div>
<div class="section" id="functions">
<h2><a name="functions">Functions</a></h2>
<p><tt class="docutils literal"><span class="pre">evalJSONRequest(req)</span></tt>:</p>
<blockquote>
<p>Evaluate a JSON <a class="footnote-reference" href="#id10" id="id4" name="id4">[4]</a> <tt class="docutils literal"><span class="pre">XMLHttpRequest</span></tt></p>
<dl class="docutils">
<dt><tt class="docutils literal"><span class="pre">req</span></tt>:</dt>
<dd>The request whose responseText is to be evaluated</dd>
<dt><tt class="docutils literal"><span class="pre">returns</span></tt>:</dt>
<dd>A JavaScript object</dd>
</dl>
</blockquote>
<p><tt class="docutils literal"><span class="pre">succeed([result])</span></tt>:</p>
<blockquote>
<p>Return a Deferred that has already had <tt class="docutils literal"><span class="pre">.callback(result)</span></tt> called.</p>
<p>This is useful when you're writing synchronous code to an asynchronous
interface: i.e., some code is calling you expecting a Deferred result,
but you don't actually need to do anything asynchronous.  Just return
<tt class="docutils literal"><span class="pre">succeed(theResult)</span></tt>.</p>
<p>See <tt class="docutils literal"><span class="pre">fail</span></tt> for a version of this function that uses a failing
<tt class="docutils literal"><span class="pre">Deferred</span></tt> rather than a successful one.</p>
<dl class="docutils">
<dt><tt class="docutils literal"><span class="pre">result</span></tt>:</dt>
<dd>The result to give to the Deferred's <tt class="docutils literal"><span class="pre">.callback(result)</span></tt> method.</dd>
<dt>returns:</dt>
<dd>a new <tt class="docutils literal"><span class="pre">Deferred</span></tt></dd>
</dl>
</blockquote>
<p><tt class="docutils literal"><span class="pre">fail([result])</span></tt>:</p>
<blockquote>
<p>Return a Deferred that has already had <tt class="docutils literal"><span class="pre">.errback(result)</span></tt> called.</p>
<p>See <tt class="docutils literal"><span class="pre">succeed</span></tt> documentation for rationale.</p>
<dl class="docutils">
<dt><tt class="docutils literal"><span class="pre">result</span></tt>:</dt>
<dd>The result to give to the Deferred's <tt class="docutils literal"><span class="pre">.errback(result)</span></tt> method.</dd>
<dt>returns:</dt>
<dd>a new <tt class="docutils literal"><span class="pre">Deferred</span></tt></dd>
</dl>
</blockquote>
<p><tt class="docutils literal"><span class="pre">sendXMLHttpRequest(req[,</span> <span class="pre">sendContent])</span></tt>:</p>
<blockquote>
<p>Set an <tt class="docutils literal"><span class="pre">onreadystatechange</span></tt> handler on an <tt class="docutils literal"><span class="pre">XMLHttpRequest</span></tt> object
and send it off.  Will return a cancellable <tt class="docutils literal"><span class="pre">Deferred</span></tt> that will
callback on success.</p>
<dl class="docutils">
<dt><tt class="docutils literal"><span class="pre">req</span></tt>:</dt>
<dd>An preconfigured <tt class="docutils literal"><span class="pre">XMLHttpRequest</span></tt> object (open has been called).</dd>
<dt><tt class="docutils literal"><span class="pre">sendContent</span></tt>:</dt>
<dd>Optional string or DOM content to send over the <tt class="docutils literal"><span class="pre">XMLHttpRequest</span></tt>.</dd>
<dt>returns:</dt>
<dd><tt class="docutils literal"><span class="pre">Deferred</span></tt> that will callback with the <tt class="docutils literal"><span class="pre">XMLHttpRequest</span></tt> instance
on success.</dd>
</dl>
</blockquote>
<p><tt class="docutils literal"><span class="pre">doSimpleXMLHttpRequest(url)</span></tt>:</p>
<blockquote>
<p>Perform a simple <tt class="docutils literal"><span class="pre">XMLHttpRequest</span></tt> and wrap it with a
<tt class="docutils literal"><span class="pre">Deferred</span></tt> that may be cancelled.</p>
<dl class="docutils">
<dt><tt class="docutils literal"><span class="pre">url</span></tt>:</dt>
<dd>The URL to GET</dd>
<dt>returns:</dt>
<dd><tt class="docutils literal"><span class="pre">Deferred</span></tt> that will callback with the <tt class="docutils literal"><span class="pre">XMLHttpRequest</span></tt>
instance on success</dd>
</dl>
</blockquote>
<p><tt class="docutils literal"><span class="pre">loadJSONDoc(url)</span></tt>:</p>
<blockquote>
<p>Do a simple <tt class="docutils literal"><span class="pre">XMLHttpRequest</span></tt> to a URL and get the response
as a JSON <a class="footnote-reference" href="#id10" id="id5" name="id5">[4]</a> document.</p>
<dl class="docutils">
<dt><tt class="docutils literal"><span class="pre">url</span></tt>:</dt>
<dd>The URL to GET</dd>
<dt>returns:</dt>
<dd><tt class="docutils literal"><span class="pre">Deferred</span></tt> that will callback with the evaluated JSON <a class="footnote-reference" href="#id10" id="id6" name="id6">[4]</a>
response upon successful <tt class="docutils literal"><span class="pre">XMLHttpRequest</span></tt></dd>
</dl>
</blockquote>
<p><tt class="docutils literal"><span class="pre">getXMLHttpRequest()</span></tt>:</p>
<blockquote>
<p>Return an <tt class="docutils literal"><span class="pre">XMLHttpRequest</span></tt> compliant object for the current
platform.</p>
<p>In order of preference:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">new</span> <span class="pre">XMLHttpRequest()</span></tt></li>
<li><tt class="docutils literal"><span class="pre">new</span> <span class="pre">ActiveXObject('Msxml2.XMLHTTP')</span></tt></li>
<li><tt class="docutils literal"><span class="pre">new</span> <span class="pre">ActiveXObject('Microsoft.XMLHTTP')</span></tt></li>
<li><tt class="docutils literal"><span class="pre">new</span> <span class="pre">ActiveXObject('Msxml2.XMLHTTP.4.0')</span></tt></li>
</ul>
</blockquote>
<p><tt class="docutils literal"><span class="pre">wait(seconds[,</span> <span class="pre">res])</span></tt>:</p>
<blockquote>
Return a new cancellable <tt class="docutils literal"><span class="pre">Deferred</span></tt> that will <tt class="docutils literal"><span class="pre">.callback(res)</span></tt>
after at least <tt class="docutils literal"><span class="pre">seconds</span></tt> seconds have elapsed.</blockquote>
<p><tt class="docutils literal"><span class="pre">callLater(seconds,</span> <span class="pre">func[,</span> <span class="pre">args...])</span></tt>:</p>
<blockquote>
<p>Call <tt class="docutils literal"><span class="pre">func(args...)</span></tt> after at least <tt class="docutils literal"><span class="pre">seconds</span></tt> seconds have elapsed.
This is a convenience method for:</p>
<pre class="literal-block">
func = partial.apply(extend(null, arguments, 1));
return wait(seconds).addCallback(function (res) { return func() });
</pre>
<p>Returns a cancellable <tt class="docutils literal"><span class="pre">Deferred</span></tt>.</p>
</blockquote>
</div>
</div>
<div class="section" id="see-also">
<h1><a name="see-also">See Also</a></h1>
<table class="docutils footnote" frame="void" id="id7" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1" name="id7">[1]</a></td><td>AJAX, Asynchronous JavaScript and XML: <a class="reference" href="http://en.wikipedia.org/wiki/AJAX">http://en.wikipedia.org/wiki/AJAX</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id8" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id2" name="id8">[2]</a></td><td>Twisted, an event-driven networking framework written in Python: <a class="reference" href="http://twistedmatrix.com/">http://twistedmatrix.com/</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id9" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id3" name="id9">[3]</a></td><td>Twisted Deferred Reference: <a class="reference" href="http://twistedmatrix.com/projects/core/documentation/howto/defer.html">http://twistedmatrix.com/projects/core/documentation/howto/defer.html</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id10" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a name="id10">[4]</a></td><td><em>(<a class="fn-backref" href="#id4">1</a>, <a class="fn-backref" href="#id5">2</a>, <a class="fn-backref" href="#id6">3</a>)</em> JSON, JavaScript Object Notation: <a class="reference" href="http://json.org/">http://json.org/</a></td></tr>
</tbody>
</table>
</div>
<div class="section" id="todo">
<h1><a name="todo">ToDo</a></h1>
<ul class="simple">
<li>Add some examples</li>
<li><tt class="docutils literal"><span class="pre">doSimpleXMLHttpRequest</span></tt> equivalent that accepts a request
instead of a URL</li>
</ul>
</div>
<div class="section" id="authors">
<h1><a name="authors">Authors</a></h1>
<ul class="simple">
<li>Bob Ippolito &lt;<a class="reference" href="mailto:bob&#64;redivi.com">bob&#64;redivi.com</a>&gt;</li>
</ul>
</div>
<div class="section" id="copyright">
<h1><a name="copyright">Copyright</a></h1>
<p>Copyright 2005 Bob Ippolito &lt;<a class="reference" href="mailto:bob&#64;redivi.com">bob&#64;redivi.com</a>&gt;.  This program is dual-licensed
free software; you can redistribute it and/or modify it under the terms of the
<a class="reference" href="http://www.opensource.org/licenses/mit-license.php">MIT License</a> or the <a class="reference" href="http://www.opensource.org/licenses/afl-2.1.php">Academic Free License v2.1</a>.</p>
</div>
</div>
</body>
</html>
