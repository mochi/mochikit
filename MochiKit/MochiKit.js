/***

    MochiKit.MochiKit 0.60 : PACKED VERSION

    THIS FILE IS AUTOMATICALLY GENERATED.  If creating patches, please
    diff against the source tree, not this file.

    See <http://mochikit.com/> for documentation, downloads, license, etc.

    (c) 2005 Bob Ippolito.  All rights Reserved.

***/

if (typeof(dojo) != 'undefined') {
    dojo.provide('MochiKit.Compat');
}
if (typeof(MochiKit) == 'undefined') {
    MochiKit = {};
}
if (typeof(MochiKit.Compat) == 'undefined') {
    MochiKit.Compat = {};
}

MochiKit.Compat.NAME = 'MochiKit.Compat';
MochiKit.Compat.VERSION = '0.60';
MochiKit.Compat.__repr__ = function () {
    return "[" + this.NAME + " " + this.VERSION + "]";
};
MochiKit.Compat.toString = function () {
    return this.__repr__();
};

if (!Array.prototype.push) {
    Array.prototype.push = function() {
        var startLength = this.length;
        for (var i = 0; i < arguments.length; i++) {
            this[startLength + i] = arguments[i];
        }
        return this.length;
    };
}

if (!Function.prototype.apply) {
    // Based on code from http://www.youngpup.net/
    Function.prototype.apply = function(object, parameters) {
        var parameterStrings = [];
        if (!object) {
            object = window;
        }
        if (!parameters) {
            parameters = [];
        }
        for (var i = 0; i < parameters.length; i++) {
            parameterStrings[i] = 'parameters[' + i + ']';
        }

        object.__apply__ = this;
        var result = eval(
            'object.__apply__(' + 
            parameterStrings.join(', ') +
            ')'
        );
        object.__apply__ = null;

        return result;
    };
}

MochiKit.Compat.EXPORT = [];
MochiKit.Compat.EXPORT_OK = [];
MochiKit.Compat.EXPORT_TAGS = {
    ":all": [],
    ":common": []
};



if (typeof(dojo) != 'undefined') {
    dojo.provide("MochiKit.Base");
}

if (typeof(MochiKit) == 'undefined') {
    MochiKit = {};
}
if (typeof(MochiKit.Base) == 'undefined') {
    MochiKit.Base = {};
}

MochiKit.Base.VERSION = "0.60";
MochiKit.Base.NAME = "MochiKit.Base"
MochiKit.Base.__repr__ = function () {
    return "[" + this.NAME + " " + this.VERSION + "]";
}
MochiKit.Base.toString = function () {
    return this.__repr__();
}

MochiKit.Base.clone = function (obj) {
    var me = arguments.callee;
    if (arguments.length == 1) {
        me.prototype = obj;
        return new me();
    }
};
        
MochiKit.Base.extend = function (self, obj, /* optional */skip) {
    
    
    // Extend an array with an array-like object starting
    // from the skip index
    if (!skip) {
        skip = 0;
    }
    if (obj) {
        // allow iterable fall-through, but skip the full isArrayLike
        // check for speed, this is called often.
        var l = obj.length;
        if (typeof(l) != 'number' /* !isArrayLike(obj) */) {
            if (MochiKit.Iter) {
                obj = MochiKit.Iter.list(obj);
                l = obj.length;
            } else {
                throw new TypeError("Argument not an array-like and MochiKit.Iter not present");
            }
        }
        if (!self) {
            self = [];
        }
        for (var i = skip; i < l; i++) {
            self.push(obj[i]);
        }
    }
    // This mutates, but it's convenient to return because
    // it's often used like a constructor when turning some
    // ghetto array-like to a real array
    return self;
};


MochiKit.Base.update = function (self, obj/*, ... */) {
    
    if (self == null) {
        self = {};
    }
    for (var i = 1; i < arguments.length; i++) {
        var o = arguments[i];
        if (typeof(o) != 'undefined' && o != null) {
            for (var k in o) {
                self[k] = o[k];
            }
        }
    }
    return self;
};

MochiKit.Base.setdefault = function (self, obj/*, ...*/) {
    
    if (self == null) {
        self = {};
    }
    for (var i = 1; i < arguments.length; i++) {
        var o = arguments[i];
        for (var k in o) {
            if (!(k in self)) {
                self[k] = o[k];
            }
        }
    }
    return self;
};

MochiKit.Base.keys = function (obj) {
    
    var rval = [];
    for (var prop in obj) {
        rval.push(prop);
    }
    return rval;
};
    
MochiKit.Base.items = function (obj) {
    
    var rval = [];
    for (var prop in obj) {
        rval.push([prop, obj[prop]]);
    }
    return rval;
};

MochiKit.Base.NamedError = function (name) {
    this.message = name;
    this.name = name;
};
MochiKit.Base.NamedError.prototype = new Error();
MochiKit.Base.NamedError.prototype.repr = function () {
    if (this.message && this.message != this.name) {
        return this.name + "(" + repr(this.message) + ")";
    } else {
        return this.name + "()";
    }
}
MochiKit.Base.NamedError.prototype.toString = function () {
    return this.repr();
}

MochiKit.Base.operator = {
    

    // unary logic operators
    "truth": function (a) { return !!a; }, 
    "lognot": function (a) { return !a; },
    "identity": function (a) { return a; },

    // bitwise unary operators
    "not": function (a) { return ~a; },
    "neg": function (a) { return -a; },

    // binary operators
    "add": function (a, b) { return a + b; },
    "div": function (a, b) { return a / b; },
    "mod": function (a, b) { return a % b; },

    // bitwise binary operators
    "and": function (a, b) { return a & b; },
    "or": function (a, b) { return a | b; },
    "xor": function (a, b) { return a ^ b; },
    "lshift": function (a, b) { return a << b; },
    "rshift": function (a, b) { return a >> b; },
    "zrshift": function (a, b) { return a >>> b; },

    // near-worthless build-in comparators
    "eq": function (a, b) { return a == b; },
    "ne": function (a, b) { return a != b; },
    "gt": function (a, b) { return a > b; },
    "ge": function (a, b) { return a >= b; },
    "lt": function (a, b) { return a < b; },
    "le": function (a, b) { return a <= b; },

    // compare comparators
    "ceq": function (a, b) { return MochiKit.Base.compare(a, b) == 0; },
    "cne": function (a, b) { return MochiKit.Base.compare(a, b) != 0; },
    "cgt": function (a, b) { return MochiKit.Base.compare(a, b) == 1; },
    "cge": function (a, b) { return MochiKit.Base.compare(a, b) != -1; },
    "clt": function (a, b) { return MochiKit.Base.compare(a, b) == -1; },
    "cle": function (a, b) { return MochiKit.Base.compare(a, b) != 1; },

    // binary logical operators
    "logand": function (a, b) { return a && b; },
    "logor": function (a, b) { return a || b; },
    "contains": function (a, b) { return b in a; }
};

MochiKit.Base.forward = function (func) {
    
    return function () {
        return this[func].apply(this, arguments);
    };
};

MochiKit.Base.itemgetter = function (func) {
    
    return function (arg) {
        return arg[func];
    };
};

MochiKit.Base.typeMatcher = function (/* typ */) {
    
    
    var types = {};
    for (var i = 0; i < arguments.length; i++) {
        var typ = arguments[i];
        types[typ] = typ;
    }
    return function () { 
        for (var i = 0; i < arguments.length; i++) {
            if (!(typeof(arguments[i]) in types)) {
                return false;
            }
        }
        return true;
    };
};

MochiKit.Base.isNull = function (/* ... */) {
    
    for (var i = 0; i < arguments.length; i++) {
        if (arguments[i] != null) {
            return false;
        }
    }
    return true;
}

MochiKit.Base.isUndefinedOrNull = function (/* ... */) {
    
    for (var i = 0; i < arguments.length; i++) {
        var o = arguments[i];
        if (!(typeof(o) == 'undefined' || o == null)) {
            return false;
        }
    }
    return true;
};

MochiKit.Base.isNotEmpty = function (obj) {
    
    for (var i = 0; i < arguments.length; i++) {
        var o = arguments[i];
        if (!(o && o.length)) {
            return false;
        }
    }
    return true;
};

MochiKit.Base.isArrayLike = function () {
    
    for (var i = 0; i < arguments.length; i++) {
        var o = arguments[i];
        var typ = typeof(o);
        if (
            (typ != 'object' && !(typ == 'function' && typeof(o.item) == 'function')) ||
            o == null ||
            typeof(o.length) != 'number'
        ) {
            return false;
        }
    }
    return true;
};

MochiKit.Base.isDateLike = function () {
    
    for (var i = 0; i < arguments.length; i++) {
        var o = arguments[i];
        if (typeof(o) != "object" || typeof(o.getTime) != 'function') {
            return false;
        }
    }
    return true;
};


MochiKit.Base.xmap = function (fn/*, obj... */) {
    
    if (fn == null) {
        return MochiKit.Base.extend(null, arguments, 1);
    }
    var rval = [];
    for (var i = 1; i < arguments.length; i++) {
        rval.push(fn(arguments[i]));
    }
    return rval;
};

MochiKit.Base.map = function (fn, lst/*, lst... */) {
    
    var isArrayLike = MochiKit.Base.isArrayLike;
    if (arguments.length <= 2) {
        // allow an iterable to be passed
        if (!isArrayLike(lst)) {
            if (MochiKit.Iter) {
                // fast path for map(null, iterable)
                lst = MochiKit.Iter.list(lst);
                if (fn == null) {
                    return lst;
                }
            } else {
                throw new TypeError("Argument not an array-like and MochiKit.Iter not present");
            }
        }
        // fast path for map(null, lst)
        if (fn == null) {
            return MochiKit.Base.extend(null, lst);
        }
        // fast path for map(fn, lst)
        if (typeof(Array.prototype.map) == 'function') {
            // Mozilla fast-path
            return Array.prototype.map.call(lst, fn);
        }
        var rval = [];
        for (var i = 0; i < lst.length; i++) {
            rval.push(fn(lst[i]));
        }
        return rval;
    } else {
        // default for map(null, ...) is zip(...)
        if (fn == null) {
            fn = Array;
        }
        var length = null;
        for (var i = 1; i < arguments.length; i++) {
            // allow iterables to be passed
            if (!isArrayLike(arguments[i])) {
                if (MochiKit.Iter) {
                    arguments[i] = MochiKit.Iter.list(arguments[i]);
                } else {
                    throw new TypeError("Argument not an array-like and MochiKit.Iter not present");
                }
            }
            // find the minimum length
            var l = arguments[i].length;
            if (length == null || length > l) {
                length = l;
            }
        }
        var rval = [];
        for (var i = 0; i < length; i++) {
            var args = [];
            for (var j = 1; j < arguments.length; j++) {
                args.push(arguments[j][i]);
            }
            rval.push(fn.apply(this, args));
        }
        return rval;
    }
};

MochiKit.Base.xfilter = function (fn/*, obj... */) {
    var rval = [];
    if (fn == null) {
        fn = MochiKit.Base.operator.truth;
    }
    for (var i = 1; i < arguments.length; i++) {
        var o = arguments[i];
        if (fn(o)) {
            rval.push(o);
        }
    }
    return rval;
};

MochiKit.Base.filter = function (fn, lst, self) {
    var rval = [];
    // allow an iterable to be passed
    if (!MochiKit.Base.isArrayLike(lst)) {
        if (MochiKit.Iter) {
            lst = MochiKit.Iter.list(lst);
        } else {
            throw new TypeError("Argument not an array-like and MochiKit.Iter not present");
        }
    }
    if (fn == null) {
        fn = MochiKit.Base.operator.truth;
    }
    if (typeof(Array.prototype.filter) == 'function') {
        // Mozilla fast-path
        return Array.prototype.filter.call(lst, fn, self);
    }
    else if (typeof(self) == 'undefined' || self == null) {
        for (var i = 0; i < lst.length; i++) {
            var o = lst[i];
            if (fn(o)) {
                rval.push(o);
            }
        }
    } else {
        for (var i = 0; i < lst.length; i++) {
            var o = lst[i];
            if (fn.call(self, o)) {
                rval.push(o);
            }
        }
    }
    return rval;
};


MochiKit.Base.bind = function (func, self/* args... */) {
    var im_func = func.im_func;
    var im_preargs = func.im_preargs;
    var im_self = func.im_self;
    if (typeof(im_func) != 'function') {
        im_func = func;
    }
    if (typeof(self) != 'undefined') {
        im_self = self;
    }
    if (typeof(im_preargs) == 'undefined') {
        im_preargs = [];
    } else  {
        im_preargs = im_preargs.slice();
    }
    MochiKit.Base.extend(im_preargs, arguments, 2);
    var newfunc = function () {
        var args = arguments;
        var me = arguments.callee;
        if (me.im_preargs.length > 0) {
            args = MochiKit.Base.concat(me.im_preargs, args);
        }
        var self = me.im_self;
        if (!self) {
            self = this;
        }
        return me.im_func.apply(self, args);
    };
    newfunc.im_self = im_self;
    newfunc.im_func = im_func;
    newfunc.im_preargs = im_preargs;
    return newfunc;
};

MochiKit.Base.bindMethods = function (self) {
    
    for (var k in self) {
        var func = self[k];
        if (typeof(func) == 'function') {
            self[k] = bind(func, self);
        }
    }
};

// A singleton raised when no suitable adapter is found
MochiKit.Base.NotFound = new MochiKit.Base.NamedError("MochiKit.Base.NotFound");

MochiKit.Base.AdapterRegistry = function () {
    
    this.pairs = [];
};

MochiKit.Base.AdapterRegistry.prototype.register = function (name, check, wrap, /* optional */ override) {
    

    if (override) {
        this.pairs.unshift([name, check, wrap]);
    } else {
        this.pairs.push([name, check, wrap]);
    }
};

MochiKit.Base.AdapterRegistry.prototype.match = function (/* ... */) {
    
    for (var i = 0; i < this.pairs.length; i++) {
        var pair = this.pairs[i];
        if (pair[1].apply(this, arguments)) {
            return pair[2].apply(this, arguments);
        }
    }
    throw MochiKit.Base.NotFound;
};

MochiKit.Base.AdapterRegistry.prototype.unregister = function (name) {
    
    for (var i = 0; i < this.pairs.length; i++) {
        var pair = this.pairs[i];
        if (pair[0] == name) {
            this.pairs.splice(i, 1);
            return true;
        }
    }
    return false;
};

MochiKit.Base.registerComparator = function (name, check, comparator, /* optional */ override) {
    
    MochiKit.Base.comparatorRegistry.register(name, check, comparator, override);
};

MochiKit.Base.compare = function (a, b) {
    
    if (a == b) {
        return 0;
    }
    var aIsNull = (typeof(a) == 'undefined' || a == null);
    var bIsNull = (typeof(b) == 'undefined' || b == null);
    if (aIsNull && bIsNull) {
        return 0;
    } else if (aIsNull) {
        return -1;
    } else if (bIsNull) {
        return 1;
    }
    try {
        return MochiKit.Base.comparatorRegistry.match(a, b);
    } catch (e) {
        if (e != MochiKit.Base.NotFound) {
            throw e;
        }
        if (a < b) {
            return -1;
        } else if (a > b) {
            return 1;
        }
        // These types can't be compared
        var repr = MochiKit.Base.repr;
        throw new TypeError(repr(a) + " and " + repr(b) + " can not be compared");
    }
};

MochiKit.Base.compareDateLike = function (a, b) {
    a = a.getTime();
    b = b.getTime();
    if (a == b) {
        return 0;
    } else if (a < b) {
        return -1;
    } else if (a > b) {
        return 1;
    }
    var repr = MochiKit.Base.repr;
    throw new TypeError(repr(a) + " and " + repr(b) + " can not be compared");
};

MochiKit.Base.compareArrayLike = function (a, b) {
    var compare = MochiKit.Base.compare;
    var count = a.length;
    var rval = 0;
    if (count > b.length) {
        rval = 1;
    } else if (count < b.length) {
        rval = -1;
        count = b.length;
    }
    for (var i = 0; i < count; i++) {
        var cmp = compare(a[i], b[i]);
        if (cmp) {
            return cmp;
        }
    }
    return rval;
};

MochiKit.Base.registerRepr = function (name, check, wrap, /* optional */override) {
    
    MochiKit.Base.reprRegistry.register(name, check, wrap, override);
};

MochiKit.Base.repr = function (o) {
    

    try {
        if (typeof(o.__repr__) == 'function') {
            return o.__repr__();
        } else if (typeof(o.repr) == 'function' && o.repr != arguments.callee) {
            return o.repr();
        }
        return MochiKit.Base.reprRegistry.match(o);
    } catch (e) {
        if (typeof(o.NAME) == 'string' && (
                o.toString == Function.prototype.toString ||
                o.toString == Object.prototype.toString
            )) {
            return o.NAME;
        }
        return o;
    }
};

MochiKit.Base.reprArrayLike = function (o) {
    return "[" + MochiKit.Base.map(MochiKit.Base.repr, o).join(", ") + "]";
};

MochiKit.Base.reprString = function (o) { 
    o = '"' + o.replace(/(["\\])/g, '\\$1') + '"';
    return o.replace(/(\n)/g, "\\n");
};

MochiKit.Base.reprNumber = function (o) {
    return o.toString();
};

MochiKit.Base.reprUndefined = function (o) {
    return "undefined";
};

MochiKit.Base.reprNull = function (o) {
    return "null";
};

MochiKit.Base.objEqual = function (a, b) {
    
    return (MochiKit.Base.compare(a, b) == 0);
};

MochiKit.Base.arrayEqual = function (self, arr) {
    
    if (self.length != arr.length) {
        return false;
    }
    return (MochiKit.Base.compare(self, arr) == 0);
};

MochiKit.Base.concat = function (/* lst... */) {
    
    var rval = [];
    var extend = MochiKit.Base.extend;
    for (var i = 0; i < arguments.length; i++) {
        extend(rval, arguments[i]);
    }
    return rval;
};

MochiKit.Base.keyComparator = function (key/* ... */) {
    
    // fast-path for single key comparisons
    var compare = MochiKit.Base.compare;
    if (arguments.length == 1) {
        return function (a, b) {
            return compare(a[key], b[key]);
        }
    }
    var compareKeys = MochiKit.Base.extend(null, arguments);
    return function (a, b) {
        var rval = 0;
        // keep comparing until something is inequal or we run out of
        // keys to compare
        for (var i = 0; (rval == 0) && (i < compareKeys.length); i++) {
            var key = compareKeys[i];
            rval = compare(a[key], b[key]);
        }
        return rval;
    };
};

MochiKit.Base.reverseKeyComparator = function (key) {
    
    var comparator = MochiKit.Base.keyComparator.apply(this, arguments);
    return function (a, b) {
        return comparator(b, a);
    }
};

MochiKit.Base.partial = function (func) {
    return MochiKit.Base.bind.apply(this, MochiKit.Base.extend([func, undefined], arguments, 1));
};
 
MochiKit.Base.listMinMax = function (which, lst) {
    
    if (lst.length == 0) {
        return null;
    }
    var cur = lst[0];
    var compare = MochiKit.Base.compare;
    for (var i = 1; i < lst.length; i++) {
        var o = lst[i];
        if (compare(o, cur) == which) {
            cur = o;
        }
    }
    return cur;
};

MochiKit.Base.objMax = function (/* obj... */) {
    
    return MochiKit.Base.listMinMax(1, arguments);
};
        
MochiKit.Base.objMin = function (/* obj... */) {
    
    return MochiKit.Base.listMinMax(-1, arguments);
};

MochiKit.Base.nodeWalk = function (node, visitor) {
    
    var nodes = [node];
    var extend = MochiKit.Base.extend;
    while (nodes.length) {
        var res = visitor(nodes.shift());
        if (res) {
            extend(nodes, res);
        }
    }
};

   
MochiKit.Base.nameFunctions = function (namespace) {
    var base = namespace.NAME;
    if (typeof(base) == 'undefined') {
        base = '';
    } else {
        base = base + '.';
    }
    for (var name in namespace) {
        var o = namespace[name];
        if (typeof(o) == 'function' && typeof(o.NAME) == 'undefined') {
            try {
                o.NAME = base + name;
            } catch (e) {
                // pass
            }
        }
    }
}

MochiKit.Base.EXPORT = [
    "clone",
    "extend",
    "update",
    "setdefault",
    "keys",
    "items",
    "NamedError",
    "operator",
    "forward",
    "itemgetter",
    "typeMatcher",
    "isCallable",
    "isUndefined",
    "isUndefinedOrNull",
    "isNull",
    "isNotEmpty",
    "isArrayLike",
    "isDateLike",
    "xmap",
    "map",
    "xfilter",
    "filter",
    "bind",
    "bindMethods",
    "NotFound",
    "AdapterRegistry",
    "registerComparator",
    "compare",
    "registerRepr",
    "repr",
    "objEqual",
    "arrayEqual",
    "concat",
    "keyComparator",
    "reverseKeyComparator",
    "partial",
    "merge",
    "listMinMax",
    "listMax",
    "listMin",
    "objMax",
    "objMin",
    "nodeWalk",
    "zip"
];

MochiKit.Base.EXPORT_OK = [
    "nameFunctions",
    "comparatorRegistry",
    "reprRegistry",
    "compareDateLike",
    "compareArrayLike",
    "reprArrayLike",
    "reprString",
    "reprNumber",
    "reprUndefined",
    "reprNull"
];


MochiKit.Base.__new__ = function () {

    this.listMax = this.partial(this.listMinMax, 1);
    this.listMin = this.partial(this.listMinMax, -1);

    this.isCallable = this.typeMatcher('function');
    this.isUndefined = this.typeMatcher('undefined');

    this.merge = this.partial(this.update, null);
    this.zip = this.partial(this.map, null);

    this.comparatorRegistry = new this.AdapterRegistry();
    this.registerComparator("dateLike", this.isDateLike, this.compareDateLike);
    this.registerComparator("arrayLike", this.isArrayLike, this.compareArrayLike);

    this.reprRegistry = new this.AdapterRegistry();
    this.registerRepr("arrayLike", this.isArrayLike, this.reprArrayLike);
    this.registerRepr("string", this.typeMatcher("string"), this.reprString);
    this.registerRepr("numbers", this.typeMatcher("number", "boolean"), this.reprNumber);
    this.registerRepr("undefined", this.isUndefined, this.reprUndefined);
    this.registerRepr("null", this.isNull, this.reprNull);

    var all = this.concat(this.EXPORT, this.EXPORT_OK);
    this.EXPORT_TAGS = {
        ":common": this.concat(this.EXPORT_OK),
        ":all": all
    };

    this.nameFunctions(this);

};

MochiKit.Base.__new__();

//
// XXX: Internet Explorer blows
//
compare = MochiKit.Base.compare;


if ((typeof(JSAN) == 'undefined' && typeof(dojo) == 'undefined')
    || (typeof(MochiKit.__compat__) == 'boolean' && MochiKit.__compat__)) {
        (function (self) {
            var all = self.EXPORT_TAGS[":all"];
            for (var i = 0; i < all.length; i++) {
                this[all[i]] = self[all[i]];
            }
        })(MochiKit.Base);
}


if (typeof(dojo) != 'undefined') {
    dojo.provide('MochiKit.Iter');
    dojo.require('MochiKit.Base');
}

if (typeof(JSAN) != 'undefined') {
    JSAN.use("MochiKit.Base", []);
}   

try {
    if (typeof(MochiKit.Base) == 'undefined') {
        throw "";
    }
} catch (e) {
    throw "MochiKit.Iter depends on MochiKit.Base!";
}  
            
if (typeof(MochiKit.Iter) == 'undefined') {
    MochiKit.Iter = {};
}           
        
MochiKit.Iter.NAME = "MochiKit.Iter";
MochiKit.Iter.VERSION = "0.60";
MochiKit.Iter.__repr__ = function () {
    return "[" + this.NAME + " " + this.VERSION + "]";
}
MochiKit.Iter.toString = function () {
    return this.__repr__();
}

MochiKit.Iter.registerIteratorFactory = function (name, check, iterfactory, /* optional */ override) {
    

    MochiKit.Iter.iteratorRegistry.register(name, check, iterfactory, override);
};

MochiKit.Iter.iter = function (iterable, /* optional */ sentinel) {
    
    
    if (arguments.length == 2) {
        return MochiKit.Iter.takewhile(
            function (a) { return a != sentinel; },
            iterable);
    }
    if (typeof(iterable.next) == 'function') {
        return iterable;
    } else if (typeof(iterable.iter) == 'function') {
        return iterable.iter();
    }
    try {
        return MochiKit.Iter.iteratorRegistry.match(iterable);
    } catch (e) {
        if (e == MochiKit.Base.NotFound) {
            e = new TypeError(typeof(iterable) + ": " + MochiKit.Base.repr(iterable) + " is not iterable");
        }
        throw e;
    }
};

MochiKit.Iter.count = function (n) {
    
    if (!n) {
        n = 0;
    }
    return {
        "repr": function () { return "count(" + n + ")"; },
        "toString": MochiKit.Base.forward("repr"),
        "next": function () { return n++; }
    };
};

MochiKit.Iter.cycle = function (p) {
    
    var lst = [];
    var iterator = MochiKit.Iter.iter(p);
    return {
        "repr": function () { return "cycle(...)"; },
        "toString": MochiKit.Base.forward("repr"),
        "next": function () {
            try {
                var rval = iterator.next();
                lst.push(rval);
                return rval;
            } catch (e) {
                if (e != MochiKit.Iter.StopIteration) {
                    throw e;
                }
                if (lst.length == 0) {
                    this.next = function () {
                        throw MochiKit.Iter.StopIteration;
                    };
                } else {
                    var i = -1;
                    this.next = function () {
                        i = (i + 1) % lst.length;
                        return lst[i];
                    }
                }
                return this.next();
            }
        }
    }
};

MochiKit.Iter.repeat = function (elem, /* optional */n) {
    
    if (typeof(n) == 'undefined') {
        return {
            "repr": function () {
                return "repeat(" + MochiKit.Base.repr(elem) + ")";
            },
            "toString": MochiKit.Base.forward("repr"),
            "next": function () {
                return elem;
            }
        };
    }
    return {
        "repr": function () {
            return "repeat(" + MochiKit.Base.repr(elem) + ", " + n + ")";
        },
        "toString": MochiKit.Base.forward("repr"),
        "next": function () {
            if (n <= 0) {
                throw MochiKit.Iter.StopIteration;
            }
            n -= 1;
            return elem;
        }
    };
};
        
MochiKit.Iter.next = function (iterator) {
    
    return iterator.next();
};

MochiKit.Iter.izip = function (p, q/*, ...*/) {
    
    var map = MochiKit.Base.map;
    var next = MochiKit.Iter.next;
    var iterables = map(iter, arguments);
    return {
        "repr" : function () { return "izip(...)"; },
        "toString" : MochiKit.Base.forward("repr"),
        "next": function () { return map(next, iterables); }
    };
};

MochiKit.Iter.ifilter = function (pred, seq) {
    
    seq = MochiKit.Iter.iter(seq);
    if (pred == null) {
        pred = MochiKit.Base.operator.truth;
    }
    return {
        "repr": function () { return "ifilter(...)"; },
        "toString": MochiKit.Base.forward("repr"),
        "next": function () {
            while (true) {
                var rval = seq.next();
                if (pred(rval)) {
                    return rval;
                }
            }
        }
    }
};

MochiKit.Iter.ifilterfalse = function (pred, seq) {
    
    seq = MochiKit.Iter.iter(seq);
    if (pred == null) {
        pred = MochiKit.Base.operator.truth;
    }
    return {
        "repr": function () { return "ifilterfalse(...)"; },
        "toString": MochiKit.Base.forward("repr"),
        "next": function () {
            while (true) {
                var rval = seq.next();
                if (!pred(rval)) {
                    return rval;
                }
            }
        }
    }
};
 
MochiKit.Iter.islice = function (seq/*, [start,] stop[, step] */) {
    
    seq = MochiKit.Iter.iter(seq);
    var start = 0;
    var stop = 0;
    var step = 1;
    var i = -1;
    if (arguments.length == 2) {
        stop = arguments[1];
    } else if (arguments.length == 3) {
        start = arguments[1];
        stop = arguments[2];
    } else {
        start = arguments[1];
        stop = arguments[2];
        step = arguments[3];
    }
    return {
        "repr": function () {
            return "islice(" + ["...", start, stop, step].join(", ") + ")";
        },
        "toString": MochiKit.Base.forward("repr"),
        "next": function () {
            var rval;
            while (i < start) {
                rval = seq.next();
                i++;
            }
            if (start >= stop) {
                throw MochiKit.Iter.StopIteration;
            }
            start += step;
            return rval;
        }
    };
};

MochiKit.Iter.imap = function (fun, p, q/*, ...*/) {
    
    var map = MochiKit.Base.map;
    var iterables = map(MochiKit.Iter.iter, MochiKit.Base.extend(null, arguments, 1));
    return {
        "repr": function () { return "imap(...)"; },
        "toString": MochiKit.Base.forward("repr"),
        "next": function () {
            return fun.apply(this, map(next, iterables));
        }
    };
};
    
MochiKit.Iter.applymap = function (fun, seq, self) {
    
    seq = MochiKit.Iter.iter(seq);
    return {
        "repr": function () { return "applymap(...)"; },
        "toString": MochiKit.Base.forward("repr"),
        "next": function () {
            return fun.apply(self, seq.next());
        }
    };
};

MochiKit.Iter.chain = function (p, q/*, ...*/) {
    
    // dumb fast path
    var iter = MochiKit.Iter.iter;
    if (arguments.length == 1) {
        return iter(arguments[0]);
    }
    var argiter = MochiKit.Base.map(iter, arguments);
    var bind = MochiKit.Base.bind;
    return {
        "repr": function () { return "chain(...)"; },
        "toString": MochiKit.Base.forward("repr"),
        "next": function () {
            while (argiter.length > 1) {
                try {
                    return argiter[0].next();
                } catch (e) {
                    if (e != MochiKit.Iter.StopIteration) {
                        throw e;
                    }
                    argiter.shift();
                }
            }
            if (argiter.length == 1) {
                // optimize last element
                var arg = argiter.shift();
                this.next = bind(arg.next, arg);
                return this.next();
            }
            throw MochiKit.Iter.StopIteration;
        }
    };
};

MochiKit.Iter.takewhile = function (pred, seq) {
    
    seq = MochiKit.Iter.iter(seq);
    return {
        "repr": function () { return "takewhile(...)"; },
        "toString": MochiKit.Base.forward("repr"),
        "next": function () {
            var rval = seq.next();
            if (!pred(rval)) {
                this.next = function () {
                    throw MochiKit.Iter.StopIteration;
                };
                throw MochiKit.Iter.StopIteration;
            }
            return rval;
        }
    };
};

MochiKit.Iter.dropwhile = function (pred, seq) {
    
    seq = MochiKit.Iter.iter(seq);
    var bind = MochiKit.Base.bind;
    return {
        "repr": function () { return "dropwhile(...)"; },
        "toString": MochiKit.Base.forward("repr"),
        "next": function () {
            while (true) {
                var rval = seq.next();
                if (!pred(rval)) {
                    break;
                }
            }
            this.next = bind(seq.next, seq);
            return rval;
        }
    };
};

MochiKit.Iter._tee = function (ident, sync, iterable) {
    sync.pos[ident] = -1;
    var listMin = MochiKit.Base.listMin;
    return {
        "repr": function () { return "tee(" + ident + ", ...)"; },
        "toString": MochiKit.Base.forward("repr"),
        "next": function () {
            var rval;
            var i = sync.pos[ident];

            if (i == sync.max) {
                rval = iterable.next();
                sync.deque.push(rval);
                sync.max += 1;
                sync.pos[ident] += 1;
            } else {
                rval = sync.deque[i - sync.min];
                sync.pos[ident] += 1;
                if (i == sync.min && listMin(sync.pos) != sync.min) {
                    sync.min += 1;
                    sync.deque.shift();
                }
            }
            return rval;
        }
    };
};

MochiKit.Iter.tee = function (iterable, n/* = 2 */) {
    
    var rval = [];
    var sync = {
        "pos": [],
        "deque": [],
        "max": -1,
        "min": -1
    };
    if (arguments.length == 1) {
        n = 2;
    }
    iterable = MochiKit.Iter.iter(iterable);
    var _tee = MochiKit.Iter._tee;
    for (var i = 0; i < n; i++) {
        rval.push(_tee(i, sync, iterable));
    }
    return rval;
};

MochiKit.Iter.list = function (iterable) {
    

    // Fast-path for Array and Array-like
    if (typeof(iterable.slice) == 'function') {
        return iterable.slice();
    } else if (MochiKit.Base.isArrayLike(iterable)) {
        return MochiKit.Base.concat(iterable);
    }

    iterable = MochiKit.Iter.iter(iterable);
    var rval = [];
    try {
        while (true) {
            rval.push(iterable.next());
        }
    } catch (e) {
        if (e != MochiKit.Iter.StopIteration) {
            throw e;
        }
        return rval;
    }
};

    
MochiKit.Iter.reduce = function (fn, iterable, /* optional */initial) {
    
    var i = 0;
    var x = initial;
    iterable = MochiKit.Iter.iter(iterable);
    if (arguments.length < 3) {
        try {
            x = iterable.next();
        } catch (e) {
            if (e == MochiKit.Iter.StopIteration) {
                e = new TypeError("reduce() of empty sequence with no initial value");
            }
            throw e;
        }
        i++;
    }
    try {
        while (true) {
            x = fn(x, iterable.next());
        }
    } catch (e) {
        if (e != MochiKit.Iter.StopIteration) {
            throw e;
        }
        return x;
    }
};

MochiKit.Iter.range = function (/* [start,] stop[, step] */) {
    
    var start = 0;
    var stop = 0;
    var step = 1;
    if (arguments.length == 1) {
        stop = arguments[0];
    } else if (arguments.length == 2) {
        start = arguments[0];
        stop = arguments[1];
    } else if (arguments.length == 3) {
        start = arguments[0];
        stop = arguments[1];
        step = arguments[2];
    } else {
        throw TypeError("range() takes 1, 2, or 3 arguments!");
    }
    return {
        "next": function () {
            if (start >= stop) {
                throw MochiKit.Iter.StopIteration;
            }
            var rval = start;
            start += step;
            return rval;
        },
        "repr": function () {
            return "range(" + [start, stop, step].join(", ") + ")";
        },
        "toString": MochiKit.Base.forward("repr")
    };
};
        
MochiKit.Iter.sum = function (iterable, start/* = 0 */) {
    
    var x = start ? start : 0;
    iterable = MochiKit.Iter.iter(iterable);
    try {
        while (true) {
            x += iterable.next();
        }
    } catch (e) {
        if (e != MochiKit.Iter.StopIteration) {
            throw e;
        }
        return x;
    }
};
        
MochiKit.Iter.exhaust = function (iterable) {
    

    iterable = MochiKit.Iter.iter(iterable);
    try {
        while (true) {
            iterable.next();
        }
    } catch (e) {
        if (e != MochiKit.Iter.StopIteration) {
            throw e;
        }
    }
};

MochiKit.Iter.forEach = function (iterable, func, /* optional */self) {
    
    if (arguments.length > 2) {
        func = MochiKit.Base.bind(func, self);
    }
    // fast path for array
    if (MochiKit.Base.isArrayLike(iterable)) {
        for (var i = 0; i < iterable.length; i++) {
            func(iterable[i]);
        }
    } else {
        MochiKit.Iter.exhaust(MochiKit.Iter.imap(func, iterable));
    }
};

MochiKit.Iter.every = function (iterable, func) {
    
    try {
        MochiKit.Iter.ifilterfalse(func, iterable).next();
        return false;
    } catch (e) {
        if (e != MochiKit.Iter.StopIteration) {
            throw e;
        }
        return true;
    }
};

MochiKit.Iter.sorted = function (iterable, /* optional */cmp) {
    
    var rval = MochiKit.Iter.list(iterable);
    if (arguments.length == 1) {
        cmp = MochiKit.Base.compare;
    }
    rval.sort(cmp);
    return rval;
};

MochiKit.Iter.reversed = function (iterable) {
    
    var rval = MochiKit.Iter.list(iterable);
    rval.reverse();
    return rval;
};

MochiKit.Iter.some = function (iterable, func) {
    
    try {
        MochiKit.Iter.ifilter(func, iterable).next();
        return true;
    } catch (e) {
        if (e != MochiKit.Iter.StopIteration) {
            throw e;
        }
        return false;
    }
};

MochiKit.Iter.iextend = function (lst, iterable) {
    
    
    iterable = MochiKit.Iter.iter(iterable);
    try {
        while (true) {
            lst.push(iterable.next());
        }
    } catch (e) {
        if (e != MochiKit.Iter.StopIteration) {
            throw e;
        }
    }
    return lst;
};


MochiKit.Iter.arrayLikeIter = function (iterable) {
    var i = 0;
    return {
        "repr": function () { return "arrayLikeIter(...)"; },
        "toString": MochiKit.Base.forward("repr"),
        "next": function () {
            if (i >= iterable.length) {
                throw MochiKit.Iter.StopIteration;
            }
            return iterable[i++];
        }
    };
};


MochiKit.Iter.EXPORT_OK = [
    "iteratorRegistry",
    "arrayLikeIter"
];

MochiKit.Iter.EXPORT = [
    "StopIteration",
    "registerIteratorFactory",
    "iter",
    "count",
    "cycle",
    "repeat",
    "next",
    "izip",
    "ifilter",
    "ifilterfalse",
    "islice",
    "imap",
    "applymap",
    "chain",
    "takewhile",
    "dropwhile",
    "tee",
    "list",
    "reduce",
    "range",
    "sum",
    "exhaust",
    "forEach",
    "every",
    "sorted",
    "reversed",
    "some",
    "iextend"
];

MochiKit.Iter.__new__ = function () {
    this.StopIteration = new MochiKit.Base.NamedError("StopIteration");
    this.iteratorRegistry = new MochiKit.Base.AdapterRegistry();
    // Register the iterator factory for arrays
    this.registerIteratorFactory(
        "arrayLike",
        MochiKit.Base.isArrayLike,
        this.arrayLikeIter
    );

    this.EXPORT_TAGS = {
        ":common": this.EXPORT,
        ":all": MochiKit.Base.concat(this.EXPORT, this.EXPORT_OK)
    };

    MochiKit.Base.nameFunctions(this);
        
};

MochiKit.Iter.__new__();

//
// XXX: Internet Explorer blows
//
reduce = MochiKit.Iter.reduce;

if ((typeof(JSAN) == 'undefined' && typeof(dojo) == 'undefined')
    || (typeof(MochiKit.__compat__) == 'boolean' && MochiKit.__compat__)) {
    (function (self) {
            var all = self.EXPORT_TAGS[":all"];
            for (var i = 0; i < all.length; i++) {
                this[all[i]] = self[all[i]];
            }
        })(MochiKit.Iter);
}


if (typeof(dojo) != 'undefined') {
    dojo.provide('MochiKit.Logging');
    dojo.require('MochiKit.Base');
}

if (typeof(JSAN) != 'undefined') {
    JSAN.use("MochiKit.Base", []);
}

try {
    if (typeof(MochiKit.Base) == 'undefined') {
        throw "";
    }
} catch (e) {
    throw "MochiKit.Logging depends on MochiKit.Base!";
}

if (typeof(MochiKit.Logging) == 'undefined') {
    MochiKit.Logging = {};
}

MochiKit.Logging.NAME = "MochiKit.Logging";
MochiKit.Logging.VERSION = "0.60";
MochiKit.Logging.__repr__ = function () {
    return "[" + this.NAME + " " + this.VERSION + "]";
};

MochiKit.Logging.toString = function () {
    return this.__repr__();
};


MochiKit.Logging.EXPORT = [
    "LogLevel",
    "LogMessage",
    "Logger",
    "alertListener",
    "logger",
    "log",
    "logError",
    "logDebug",
    "logFatal",
    "logWarning"
];


MochiKit.Logging.EXPORT_OK = [
    "logLevelAtLeast",
    "isLogMessage",
    "compareLogMessage"
];


MochiKit.Logging.logLevelAtLeast = function (minLevel) {
    
    if (typeof(minLevel) == 'string') {
        minLevel = MochiKit.Logging.LogLevel[minLevel];
    }
    return function (msg) {
        var msgLevel = msg.level;
        if (typeof(msgLevel) == 'string') {
            msgLevel = MochiKit.Logging.LogLevel[msgLevel];
        }
        return msgLevel >= minLevel;
    }
};

MochiKit.Logging.LogMessage = function (num, level, info) {
    this.num = num;
    this.level = level;
    this.info = info;
    this.timestamp = new Date();
};

MochiKit.Logging.LogMessage.prototype.repr = function () {
    return 'LogMessage(' + 
        MochiKit.Base.map(
            MochiKit.Base.repr,
            [this.num, this.level, this.info]
        ).join(', ') + ')';
};

MochiKit.Logging.LogMessage.prototype.toString = function () {
    return this.repr();
};

MochiKit.Logging.isLogMessage = function (/* ... */) {
    var LogMessage = MochiKit.Logging.LogMessage;
    for (var i = 0; i < arguments.length; i++) {
        if (!(arguments[i] instanceof LogMessage)) {
            return false;
        }
    }
    return true;
};

MochiKit.Logging.compareLogMessage = function (a, b) {
    return MochiKit.Base.compare([a.level, a.info], [b.level, b.info]);
};

MochiKit.Logging.Logger = function (/* optional */maxSize) {
    
    this.counter = 0;
    if (typeof(maxSize) == 'undefined' || maxSize == null) {
        maxSize = -1;
    }
    this.maxSize = maxSize;
    this._messages = [];
    this.listeners = {};
};

MochiKit.Logging.Logger.prototype.clear = function () {
    
    this._messages.splice(0, this._messages.length);
};

MochiKit.Logging.Logger.prototype.dispatchListeners = function (msg) {
    
    for (var k in this.listeners) {
        var pair = this.listeners[k];
        if (pair[0] && !pair[0](msg)) {
            continue;
        }
        pair[1](msg);
    }
};

MochiKit.Logging.Logger.prototype.addListener = function (ident, filter, listener) {
    
            
            
    if (typeof(filter) == 'string') {
        filter = MochiKit.Logging.logLevelAtLeast(filter);
    }
    this.listeners[ident] = [filter, listener];
};

MochiKit.Logging.Logger.prototype.removeListener = function (ident) {
    
    delete this.listeners[ident];
};

MochiKit.Logging.Logger.prototype.baseLog = function (level, message/*, ...*/) {
    
            
    var msg = new MochiKit.Logging.LogMessage(
        this.counter,
        level,
        MochiKit.Base.extend(null, arguments, 1)
    );
    this._messages.push(msg);
    this.dispatchListeners(msg);
    this.counter += 1;
    while (this.maxSize >= 0 && this._messages.length > this.maxSize) {
        this._messges.shift();
    }
};

MochiKit.Logging.Logger.prototype.getMessages = function (howMany) {
    
    var firstMsg = 0;
    if (!(typeof(howMany) == 'undefined' || howMany == null)) {
        firstMsg = Math.max(0, this._messages.length - howMany);
    }
    return this._messages.slice(firstMsg);
};

MochiKit.Logging.Logger.prototype.getMessageText = function (howMany) {
    
    if (typeof(howMany) == 'undefined' || howMany == null) {
        howMany = 30;
    }
    var messages = this.getMessages(howMany);
    if (messages.length) {
        var lst = map(function (m) {
            return '\n  [' + m.num + '] ' + m.level + ': ' + m.info.join(' '); 
        }, messages);
        lst.unshift('LAST ' + messages.length + ' MESSAGES:');
        return lst.join('');
    }
    return '';
};

MochiKit.Logging.Logger.prototype.debuggingBookmarklet = function () {
    alert(this.getMessageText());
};

MochiKit.Logging.alertListener = function (msg) {
    
    alert(
        "num: " + msg.num +
        "\nlevel: " +  msg.level +
        "\ninfo: " + msg.info.join(" ")
    );
};

MochiKit.Logging.__new__ = function () {
    this.LogLevel = {
        'ERROR': 40,
        'FATAL': 50,
        'WARNING': 30,
        'INFO': 20,
        'DEBUG': 10
    };

    MochiKit.Base.registerComparator("LogMessage",
        this.isLogMessage,
        this.compareLogMessage
    );

    var partial = MochiKit.Base.partial;

    var Logger = this.Logger;
    Logger.prototype.debug = partial(Logger.prototype.baseLog, 'DEBUG');
    Logger.prototype.log = partial(Logger.prototype.baseLog, 'INFO');
    Logger.prototype.error = partial(Logger.prototype.baseLog, 'ERROR');
    Logger.prototype.fatal = partial(Logger.prototype.baseLog, 'FATAL');
    Logger.prototype.warning = partial(Logger.prototype.baseLog, 'WARNING');

    var bind = MochiKit.Base.bind;

    var logger = new Logger();
    this.log = bind(logger.log, logger);
    this.logError = bind(logger.error, logger);
    this.logDebug = bind(logger.debug, logger);
    this.logFatal = bind(logger.fatal, logger);
    this.logWarning = bind(logger.warning, logger);
    this.logger = logger;

    this.EXPORT_TAGS = {
        ":common": this.EXPORT,
        ":all": MochiKit.Base.concat(this.EXPORT, this.EXPORT_OK)
    };

    MochiKit.Base.nameFunctions(this);

};

MochiKit.Logging.__new__();

if ((typeof(JSAN) == 'undefined' && typeof(dojo) == 'undefined')
    || (typeof(MochiKit.__compat__) == 'boolean' && MochiKit.__compat__)) {
    (function (self) {
            var all = self.EXPORT_TAGS[":all"];
            for (var i = 0; i < all.length; i++) {
                this[all[i]] = self[all[i]];
            }
        })(MochiKit.Logging);
}



if (typeof(dojo) != 'undefined') {
    dojo.provide('MochiKit.DateTime');
}

if (typeof(MochiKit) == 'undefined') {
    MochiKit = {};
}
       
if (typeof(MochiKit.DateTime) == 'undefined') {
    MochiKit.DateTime = {};
}

MochiKit.DateTime.NAME = "MochiKit.DateTime";
MochiKit.DateTime.VERSION = "0.60";
MochiKit.DateTime.__repr__ = function () {
    return "[" + this.NAME + " " + this.VERSION + "]";
}
MochiKit.DateTime.toString = function () {
    return this.__repr__();
}

MochiKit.DateTime.isoDate = function (str) {
    
    var iso = str.split('-');
    return new Date(iso[0], iso[1] - 1, iso[2]);
};

MochiKit.DateTime.isoTimestamp = function (str) {
    
    var tmp = str.split(' ');
    if (tmp.length == 1) {
        tmp = str.split('T');
    }
    var iso = tmp[0].split('-');
    var t = tmp[1].split(':');
    return new Date(iso[0], iso[1] - 1, iso[2], t[0], t[1], t[2]);
};

MochiKit.DateTime.toISOTime = function (date) {
    
    var hh = date.getHours();
    var mm = date.getMinutes();
    var ss = date.getSeconds();
    var lst = [hh, ((mm < 10) ? "0" + mm : mm), ((ss < 10) ? "0" + ss : ss)];
    return lst.join(":");
};

MochiKit.DateTime.toISOTimestamp = function (date, realISO) {
    
    var sep = realISO ? "T" : " ";
    return MochiKit.DateTime.toISODate(date) + sep + MochiKit.DateTime.toISOTime(date);
};

MochiKit.DateTime.toISODate = function (date) {
    
    return [date.getFullYear(), date.getMonth() + 1, date.getDate()].join("-");
};

MochiKit.DateTime.americanDate = function (d) {
    
    var a = d.split('/');
    return new Date(a[2], a[0] - 1, a[1]);
};

var _padTwo = function (n) {
    return (n > 9) ? n : "0" + n;
};

MochiKit.DateTime.toPaddedAmericanDate = function (d) {
    
    return [
        _padTwo(d.getMonth() + 1),
        _padTwo(d.getDate()),
        d.getFullYear()
    ].join('/');
};

MochiKit.DateTime.toAmericanDate = function (d) {
    
    return [d.getMonth() + 1, d.getDate(), d.getFullYear()].join('/');
};

MochiKit.DateTime.EXPORT = [
    "isoDate",
    "isoTimestamp",
    "toISOTime",
    "toISOTimestamp",
    "toISODate",
    "americanDate",
    "toPaddedAmericanDate",
    "toAmericanDate"
];

MochiKit.DateTime.EXPORT_OK = [];
MochiKit.DateTime.EXPORT_TAGS = {
    ":common": MochiKit.DateTime.EXPORT,
    ":all": MochiKit.DateTime.EXPORT
}

MochiKit.DateTime.__new__ = function () {
    // MochiKit.Base.nameFunctions(this);
    var base = this.NAME + ".";
    for (var k in this) {
        var o = this[k];
        if (typeof(o) == 'function' && typeof(o.NAME) == 'undefined') {
            try {
                o.NAME = base + k;
            } catch (e) {
                // pass
            }
        }   
    }
}

MochiKit.DateTime.__new__();

if ((typeof(JSAN) == 'undefined' && typeof(dojo) == 'undefined')
    || (typeof(MochiKit.__compat__) == 'boolean' && MochiKit.__compat__)) {
    (function (self) {
            var all = self.EXPORT_TAGS[":all"];
            for (var i = 0; i < all.length; i++) {
                this[all[i]] = self[all[i]];
            }
        })(MochiKit.DateTime);
}



if (typeof(dojo) != 'undefined') {
    dojo.provide('MochiKit.Format');
}

if (typeof(MochiKit) == 'undefined') {
    MochiKit = {};
}

if (typeof(MochiKit.Format) == 'undefined') {
    MochiKit.Format = {};
}

MochiKit.Format.NAME = "MochiKit.Format";
MochiKit.Format.VERSION = "0.60";
MochiKit.Format.__repr__ = function () {
    return "[" + this.NAME + " " + this.VERSION + "]";
}
MochiKit.Format.toString = function () {
    return this.__repr__();
}

MochiKit.Format.twoDigitAverage = function (numerator, denominator) {
    
    if (denominator) {
        var res = numerator / denominator;
        if (!isNaN(res)) {
            return MochiKit.Format.twoDigitFloat(numerator / denominator);
        }
    }
    return "0";
};

MochiKit.Format.twoDigitFloat = function (someFloat) {
    
    var sign = (someFloat < 0 ? '-' : '');
    var s = Math.floor(Math.abs(someFloat) * 100).toString();
    if (s == '0') {
        return s;
    }
    if (s.length < 3) {
        while (s.charAt(s.length - 1) == '0') {
            s = s.substring(0, s.length - 1);
        }
        return sign + '0.' + s;
    }
    var head = sign + s.substring(0, s.length - 2);
    var tail = s.substring(s.length - 2, s.length);
    if (tail == '00') {
        return head;
    } else if (tail.charAt(1) == '0') {
        return head + '.' + tail.charAt(0);
    } else {
        return head + '.' + tail;
    }
};

MochiKit.Format.percentFormat = function (someFloat) {
    
    return MochiKit.Format.twoDigitFloat(100 * someFloat) + '%';
};

MochiKit.Format.EXPORT = [
    "twoDigitAverage",
    "twoDigitFloat",
    "percentFormat"
];

MochiKit.Format.EXPORT_OK = [];
MochiKit.Format.EXPORT_TAGS = {
    ':all': MochiKit.Format.EXPORT,
    ':common': MochiKit.Format.EXPORT
};

MochiKit.Format.__new__ = function () {
    // MochiKit.Base.nameFunctions(this);
    var base = this.NAME + ".";
    for (var k in this) {
        var o = this[k];
        if (typeof(o) == 'function' && typeof(o.NAME) == 'undefined') {
            try {
                o.NAME = base + k;
            } catch (e) {
                // pass
            }
        }
    }
}

MochiKit.Format.__new__();

if ((typeof(JSAN) == 'undefined' && typeof(dojo) == 'undefined')
    || (typeof(MochiKit.__compat__) == 'boolean' && MochiKit.__compat__)) {
    (function (self) {
            var all = self.EXPORT_TAGS[":all"];
            for (var i = 0; i < all.length; i++) {
                this[all[i]] = self[all[i]];
            }
        })(MochiKit.Format);
}



if (typeof(dojo) != 'undefined') {
    dojo.provide("MochiKit.Async");
    dojo.require("MochiKit.Base");
}
if (typeof(JSAN) != 'undefined') {
    JSAN.use("MochiKit.Base", []);
}

try {
    if (typeof(MochiKit.Base) == 'undefined') {
        throw "";
    }
} catch (e) {
    throw "MochiKit.Async depends on MochiKit.Base!";
}

if (typeof(MochiKit.Async) == 'undefined') {
    MochiKit.Async = {};
}

MochiKit.Async.NAME = "MochiKit.Async";
MochiKit.Async.VERSION = "0.60";
MochiKit.Async.__repr__ = function () {
    return "[" + this.NAME + " " + this.VERSION + "]";
}
MochiKit.Async.toString = function () {
    return this.__repr__();
}

MochiKit.Async.AlreadyCalledError = function (deferred) {
    
    this.deferred = deferred;
};
MochiKit.Async.AlreadyCalledError.prototype = new MochiKit.Base.NamedError("MochiKit.Async.AlreadyCalledError");

MochiKit.Async.CancelledError = function (deferred) {
    
    this.deferred = deferred;
};
MochiKit.Async.CancelledError.prototype = new MochiKit.Base.NamedError("MochiKit.Async.CancelledError");

MochiKit.Async.BrowserComplianceError = function (msg) {
    
    this.message = msg;
};
MochiKit.Async.BrowserComplianceError.prototype = new MochiKit.Base.NamedError("MochiKit.Async.BrowserComplianceError");

MochiKit.Async.GenericError = function (msg) {
    this.message = msg;
};
MochiKit.Async.GenericError.prototype = new MochiKit.Base.NamedError("MochiKit.Async.GenericError");

MochiKit.Async.XMLHttpRequestError = function (req, msg) {
    
    this.req = req;
    this.message = msg;
    try {
        // Strange but true that this can raise in some cases.
        this.number = req.status;
    } catch (e) {
        // pass
    }
};
MochiKit.Async.XMLHttpRequestError.prototype = new MochiKit.Base.NamedError("MochiKit.Async.XMLHttpRequestError");


MochiKit.Async.Deferred = function (/* optional */ canceller) {
    

    
    this.chain = [];
    this.id = this._nextId();
    this.fired = -1;
    this.paused = 0;
    this.results = [null, null];
    this.canceller = canceller;
    this.silentlyCancelled = false;
};

MochiKit.Async.Deferred.prototype.repr = function () {
    var state;
    if (this.fired == -1) {
        state = 'unfired';
    } else if (this.fired == 0) {
        state = 'success';
    } else {
        state = 'error';
    }
    return 'Deferred(' + this.id + ', ' + state + ')';
};

MochiKit.Async.Deferred.prototype.toString = MochiKit.Base.forward("repr");

MochiKit.Async.Deferred.prototype._nextId = (function () {
    var x = 0;
    return function () {
        return ++x;
    }
})();

MochiKit.Async.Deferred.prototype.cancel = function () {
    
    if (this.fired == -1) {
        if (this.canceller) {
            this.canceller(this);
        } else {
            this.silentlyCancelled = true;
        }
        if (this.fired == -1) {
            this.errback(new MochiKit.Async.CancelledError(this));
        }
    } else if ((this.fired == 0) && (this.results[0] instanceof MochiKit.Async.Deferred)) {
        this.results[0].cancel();
    }
};
        

MochiKit.Async.Deferred.prototype._pause = function () {
    
    this.paused++;
};

MochiKit.Async.Deferred.prototype._unpause = function () {
    
    this.paused--;
    if ((this.paused == 0) && (this.fired >= 0)) {
        this._fire();
    }
};

MochiKit.Async.Deferred.prototype._continue = function (res) {
    
    this._resback(res);
    this._unpause();
};

MochiKit.Async.Deferred.prototype._resback = function (res) {
    
    this.fired = ((res instanceof Error) ? 1 : 0);
    this.results[this.fired] = res;
    this._fire();
};

MochiKit.Async.Deferred.prototype._check = function () {
    if (this.fired != -1) {
        if (!this.silentlyCancelled) {
            throw new MochiKit.Async.AlreadyCalledError(this);
        }
        this.silentlyCancelled = false;
        return;
    }
};

MochiKit.Async.Deferred.prototype.callback = function (res) {
    
    this._check();
    this._resback(res);
};

MochiKit.Async.Deferred.prototype.errback = function (res) {
    
    this._check();
    if (!(res instanceof Error)) {
        res = new MochiKit.Async.GenericError(res);
    }
    this._resback(res);
};

MochiKit.Async.Deferred.prototype.addBoth = function (fn) {
    
    return this.addCallbacks(fn, fn);
};

MochiKit.Async.Deferred.prototype.addCallback = function (fn) {
    
    return this.addCallbacks(fn, null);
};

MochiKit.Async.Deferred.prototype.addErrback = function (fn) {
    
    return this.addCallbacks(null, fn);
};

MochiKit.Async.Deferred.prototype.addCallbacks = function (cb, eb) {
    
    this.chain.push([cb, eb])
    if (this.fired >= 0) {
        this._fire();
    }
    return this;
};

MochiKit.Async.Deferred.prototype._fire = function () {
    
    var chain = this.chain;
    var fired = this.fired;
    var res = this.results[fired];
    var self = this;
    var cb = null;
    while (chain.length > 0 && this.paused == 0) {
        // Array
        var pair = chain.shift();
        var f = pair[fired];
        if (f == null) {
            continue;
        }
        try {
            res = f(res);
            fired = ((res instanceof Error) ? 1 : 0);
            if (res instanceof MochiKit.Async.Deferred) {
                cb = function (res) {
                    self._continue(res);
                }
                this._pause();
            }
        } catch (err) {
            fired = 1;
            res = err;
        }
    }
    this.fired = fired;
    this.results[fired] = res;
    if (cb && this.paused) {
        // this is for "tail recursion" in case the dependent deferred
        // is already fired
        res.addBoth(cb);
    }
};

MochiKit.Async.evalJSONRequest = function (req) {
    
    return eval('(' + req.responseText + ')');
};

MochiKit.Async.succeed = function (/* optional */result) {
    
    var d = new MochiKit.Async.Deferred();
    d.callback.apply(d, arguments);
    return d;
};

MochiKit.Async.fail = function (/* optional */result) {
    
    var d = new MochiKit.Async.Deferred();
    d.errback.apply(d, arguments);
    return d;
};

MochiKit.Async.getXMLHttpRequest = function () {
    var self = arguments.callee;
    if (!self.XMLHttpRequest) {
        var tryThese = [
            function () { return new XMLHttpRequest(); },
            function () { return new ActiveXObject('Msxml2.XMLHTTP'); },
            function () { return new ActiveXObject('Microsoft.XMLHTTP'); },
            function () { return new ActiveXObject('Msxml2.XMLHTTP.4.0'); },
            function () {
                throw new MochiKit.Async.BrowserComplianceError("Browser does not support XMLHttpRequest");
            }
        ];
        for (var i = 0; i < tryThese.length; i++) {
            var func = tryThese[i];
            try {
                self.XMLHttpRequest = func;
                return func();
            } catch (e) {
                // pass
            }
        }
    }
    return self.XMLHttpRequest();
};

MochiKit.Async.sendXMLHttpRequest = function (req, /* optional */ sendContent) {
    if (typeof(sendContent) == 'undefined') {
        send = null;
    }

    var canceller = function () {
        // IE SUCKS
        try {
            req.onreadystatechange = null;
        } catch (e) {
            try {
                req.onreadystatechange = function () {};
            } catch (e) {
            }
        }
        req.abort();
    }

    var d = new MochiKit.Async.Deferred(canceller);
    
    var onreadystatechange = function () {
        // MochiKit.Logging.logDebug('req.readyState', req.readyState);
        if (req.readyState == 4) {
            // IE SUCKS
            try {
                req.onreadystatechange = null;
            } catch (e) {
                try {
                    req.onreadystatechange = function () {};
                } catch (e) {
                }
            }
            var status = null;
            try {
                status = req.status;
                if (typeof(status) == 'undefined' && MochiKit.Base.isNotEmpty(req.responseText)) {
                    // XXX: Safari heisenbug workaround
                    // MochiKit.Logging.logDebug('Fixing up status due to Safari heisenbug');
                    status = 200;
                }
            } catch (e) {
                // pass
                // MochiKit.Logging.logDebug('error getting status?', repr(items(e)));
            }
            if (status == 200) { // OK
                d.callback(req);
            } else {
                var err = new MochiKit.Async.XMLHttpRequestError(req, "Request failed");
                if (err.number) {
                    // XXX: This seems to happen on page change
                    d.errback(err);
                } else {
                    // MochiKit.Logging.logDebug("Ignoring XMLHttpRequest, undefined status");
                }
            }
        }
    }
    try {
        req.onreadystatechange = onreadystatechange;
        req.send(sendContent);
    } catch (e) {
        try {
            req.onreadystatechange = null;
        } catch (ignore) {
            // pass
        }
        d.errback(e);
    }

    return d;

}

MochiKit.Async.doSimpleXMLHttpRequest = function (url) {
    var req = MochiKit.Async.getXMLHttpRequest();
    req.open("GET", url, true);
    return MochiKit.Async.sendXMLHttpRequest(req);
};

MochiKit.Async.loadJSONDoc = function (url) {
    

    var d = MochiKit.Async.doSimpleXMLHttpRequest(url);
    d = d.addCallback(MochiKit.Async.evalJSONRequest);
    return d;
};

MochiKit.Async.wait = function (seconds, /* optional */value) {
    var d = new MochiKit.Async.Deferred();
    var bind = MochiKit.Base.bind;
    var partial = MochiKit.Base.partial;
    if (typeof(value) != 'undefined') {
        d.addCallback(function () { return value; });
    }
    var timeout = setTimeout(bind(d.callback, d), Math.floor(seconds * 1000));
    d.canceller = partial(clearTimeout, timeout);
    return d;
};

MochiKit.Async.callLater = function (seconds, func) {
    var m = MochiKit.Base;
    var func = m.partial.apply(null, m.extend(null, arguments, 1));
    return MochiKit.Async.wait(seconds).addCallback(
        function (res) { return func(); }
    );
};

MochiKit.Async.EXPORT = [
    "AlreadyCalledError",
    "CancelledError",
    "BrowserComplianceError",
    "GenericError",
    "XMLHttpRequestError",
    "Deferred",
    "succeed",
    "fail",
    "getXMLHttpRequest",
    "doSimpleXMLHttpRequest",
    "loadJSONDoc",
    "wait",
    "callLater"
];
    
MochiKit.Async.EXPORT_OK = [
    "evalJSONRequest"
];

MochiKit.Async.__new__ = function () {

    this.EXPORT_TAGS = {
        ":common": this.EXPORT,
        ":all": MochiKit.Base.concat(this.EXPORT, this.EXPORT_OK)
    };

    MochiKit.Base.nameFunctions(this);

};

MochiKit.Async.__new__();

if ((typeof(JSAN) == 'undefined' && typeof(dojo) == 'undefined')
    || (typeof(MochiKit.__compat__) == 'boolean' && MochiKit.__compat__)) {
    (function (self) {
            var all = self.EXPORT_TAGS[":all"];
            for (var i = 0; i < all.length; i++) {
                this[all[i]] = self[all[i]];
            }
        })(MochiKit.Async);
}



if (typeof(dojo) != 'undefined') {
    dojo.provide("MochiKit.DOM");
    dojo.require("MochiKit.Iter");
}
if (typeof(JSAN) != 'undefined') {
    JSAN.use("MochiKit.Iter", []);
}

try {
    if (typeof(MochiKit.Iter) == 'undefined') {
        throw "";
    }
} catch (e) {
    throw "MochiKit.DOM depends on MochiKit.Iter!";
}

if (typeof(MochiKit.DOM) == 'undefined') {
    MochiKit.DOM = {};
}

MochiKit.DOM.NAME = "MochiKit.DOM";
MochiKit.DOM.VERSION = "0.60";
MochiKit.DOM.__repr__ = function () {
    return "[" + this.NAME + " " + this.VERSION + "]";
}
MochiKit.DOM.toString = function () {
    return this.__repr__();
}

MochiKit.DOM.EXPORT = [
    "registerDOMConverter",
    "coerceToDOM",
    "createDOM",
    "createDOMFunc",
    "swapDOM",
    "TD",
    "TR",
    "TBODY",
    "TFOOT",
    "TABLE",
    "TH",
    "INPUT",
    "SPAN",
    "A",
    "DIV",
    "IMG",
    "getElement",
    "$",
    "getElementsByTagAndClassName",
    "addToCallStack",
    "addLoadEvent",
    "focusOnLoad",
    "setElementClass",
    "toggleElementClass",
    "addElementClass",
    "removeElementClass",
    "swapElementClass",
    "hasElementClass",
    "escapeHTML",
    "toHTML",
    "emitHTML",
    "setDisplayForElement",
    "hideElement",
    "showElement",
    "scrapeText"
];

MochiKit.DOM.EXPORT_OK = [
    "domConverters"
];


MochiKit.DOM.registerDOMConverter = function (name, check, wrap, /* optional */override) {
    
    domConverters.register(name, check, wrap, override);
};

MochiKit.DOM.coerceToDOM = function (node, ctx) {
    

    var iter = MochiKit.Iter.iter;
    var repeat = MochiKit.Iter.repeat;
    var imap = MochiKit.Iter.imap;
    var domConverters = MochiKit.DOM.domConverters;
    while (true) {
        if (typeof(node) == 'undefined' || node == null) {
            return null;
        }
        if (node.nodeType > 0) {
            return node;
        }
        if (typeof(node) == 'number' || typeof(node) == 'bool') {
            node = node.toString();
            // FALL THROUGH
        }
        if (typeof(node) == 'string') {
            return document.createTextNode(node);
        }
        if (typeof(node.toDOM) == 'function') {
            node = node.toDOM(ctx);
            continue;
        }
        if (typeof(node) == 'function') {
            node = node(ctx);
            continue;
        }

        // iterable
        var iterNodes = null;
        try {
            iterNodes = iter(node);
        } catch (e) {
            // pass
        }
        if (iterNodes) {
            return imap(
                coerceToDOM,
                iterNodes,
                repeat(ctx)
            );
        }

        // adapter
        try {
            node = domConverters.match(node, ctx);
            continue;
        } catch (e) {
            if (e != NotFound) {
                throw e;
            }
        }

        // fallback
        return document.createTextNode(node.toString());
    }
};
    
MochiKit.DOM.createDOM = function (name, attrs/*, nodes... */) {
    

    var elem = document.createElement(name);
    if (attrs) {
        if (MochiKit.DOM.attributeArray.compliant) {
            // not IE, good.
            for (var k in attrs) {
                elem.setAttribute(k, attrs[k]);
            }
        } else {
            // IE is insane in the membrane
            for (var k in attrs) {
                elem.setAttribute((k == "class" ? "className" : k), attrs[k]);
            }
        }
    }

    nodeStack = [
        MochiKit.DOM.coerceToDOM(
            MochiKit.Base.extend(null, arguments, 2),
            elem
        )
    ];
    var iextend = MochiKit.Iter.iextend;
    while (nodeStack.length) {
        var node = nodeStack.shift();
        if (typeof(node) == 'undefined' || node == null) {
            // pass
        } else if (typeof(node.nodeType) == 'number') {
            elem.appendChild(node);
        } else {
            iextend(nodeStack, node);
        }
    }
    return elem;
};

MochiKit.DOM.createDOMFunc = function (/* tag, attrs, *nodes */) {
    
    return MochiKit.Base.partial.apply(
        this,
        MochiKit.Base.extend([MochiKit.DOM.createDOM], arguments)
    );
};

MochiKit.DOM.swapDOM = function (dest, src) {
    
    dest = MochiKit.DOM.getElement(dest);
    src = MochiKit.DOM.getElement(src);
    var parent = dest.parentNode;
    parent.insertBefore(src, dest);
    parent.removeChild(dest);
    return src;
};

MochiKit.DOM.getElement = function (id) {
    
    if (arguments.length == 1) {
        return ((typeof(id) == "string") ? document.getElementById(id) : id);
    } else {
        return MochiKit.Base.map(getElement, arguments);
    }
};

MochiKit.DOM.getElementsByTagAndClassName = function (tagName, className, /* optional */parent) {
    if (typeof(tagName) == 'undefined' || tagName == null) {
        tagName = '*';
    }
    if (typeof(parent) == 'undefined' || parent == null) {
        parent = document;
    }
    var children = parent.getElementsByTagName(tagName) || document.all;
    if (typeof(className) == 'undefined' || className == null) {
        return children;
    }

    var elements = [];
    for (var i = 0; i < children.length; i++) {
        var child = children[i];
        var classNames = child.className.split(' ');
        for (var j = 0; j < classNames.length; j++) {
            if (classNames[j] == className) {
                elements.push(child);
                break;
            }
        }
    }

    return elements;
}

MochiKit.DOM.addToCallStack = function (target, path, func, once) {
    var existing = target[path];
    var regfunc = existing;
    if (!(typeof(existing) == 'function' && existing.callStack)) {
        var regfunc = function () {
            var callStack = regfunc.callStack;
            for (var i = 0; i < callStack.length; i++) {
                if (callStack[i].apply(this, arguments) === false) {
                    break;
                }
            }
            if (once) {
                try {
                    target[path] = null;
                } catch (e) {
                    // pass
                }
            }
        }
        regfunc.callStack = [];
        if (typeof(existing) == 'function') {
            regfunc.callStack.push(existing);
        }
        target[path] = regfunc;
    }
    regfunc.callStack.push(func);
}

MochiKit.DOM.addLoadEvent = function (func) {
    
    MochiKit.DOM.addToCallStack(window, "onload", func, true);
    
};

MochiKit.DOM.focusOnLoad = function (element) {
    MochiKit.DOM.addLoadEvent(function () {
        element = MochiKit.DOM.getElement(element);
        if (element) {
            element.focus();
        }
    });
};
        

MochiKit.DOM.setElementClass = function (element, className) {
    
    var obj = MochiKit.DOM.getElement(element);
    if (MochiKit.DOM.attributeArray.compliant) {
        obj.setAttribute("class", className);
    } else {
        obj.setAttribute("className", className);
    }
};
        
MochiKit.DOM.toggleElementClass = function (className/*, element... */) {
    
    var getElement = MochiKit.DOM.getElement;
    var addElementClass = MochiKit.DOM.addElementClass;
    var removeElementClass = MochiKit.DOM.removeElementClass;
    for (i = 1; i < arguments.length; i++) {
        var obj = getElement(arguments[i]);
        if (!addElementClass(obj, className)) {
            removeElementClass(obj, className);
        }
    }
};

MochiKit.DOM.addElementClass = function (element, className) {
    
    var obj = MochiKit.DOM.getElement(element);
    var cls = obj.className;
    // trivial case, no className yet
    if (cls.length == 0) {
        MochiKit.DOM.setElementClass(obj, className);
        return true;
    }
    // the other trivial case, already set as the only class
    if (cls == className) {
        return false;
    }
    var classes = obj.className.split(" ");
    for (var i = 0; i < classes.length; i++) {
        // already present
        if (classes[i] == className) {
            return false;
        }
    }
    // append class
    MochiKit.DOM.setElementClass(obj, cls + " " + className);
    return true;
};

MochiKit.DOM.removeElementClass = function (element, className) {
    
    var obj = MochiKit.DOM.getElement(element);
    var cls = obj.className;
    // trivial case, no className yet
    if (cls.length == 0) {
        return false;
    }
    // other trivial case, set only to className
    if (cls == className) {
        MochiKit.DOM.setElementClass(obj, "");
        return true;
    }
    var classes = obj.className.split(" ");
    for (var i = 0; i < classes.length; i++) {
        // already present
        if (classes[i] == className) {
            // only check sane case where the class is used once
            classes.splice(i, 1);
            MochiKit.DOM.setElementClass(obj, classes.join(" "));
            return true;
        }
    }
    // not found
    return false;
};

MochiKit.DOM.swapElementClass = function (element, fromClass, toClass) {
    
    var obj = MochiKit.DOM.getElement(element);
    var res = MochiKit.DOM.removeElementClass(obj, fromClass);
    if (res) {
        MochiKit.DOM.addElementClass(obj, toClass);
    }
    return res;
};

MochiKit.DOM.hasElementClass = function (element, className/*...*/) {
  
  var obj = MochiKit.DOM.getElement(element);
  var classes = obj.className.split(" ");
  for (var i = 1; i < arguments.length; i++) {
    good = false;
    for (var j = 0; j < classes.length; j++) {
      if (classes[j] == arguments[i]) {
	good = true;
	break;
      }
    }
    if (! good) {
      return false;
    }
  }
  return true;
};

MochiKit.DOM.escapeHTML = function (s) {
    
    var buf = [];
    var _TRANSTABLE = MochiKit.DOM._TRANSTABLE;
    for (var i = 0; i < s.length; i++) {
        var c = s.charAt(i);
        var o = _TRANSTABLE[c];
        if (o) {
            c = o;
        }
        buf.push(c);
    }
    return buf.join("");
};

MochiKit.DOM.toHTML = function (dom) {
    
    return MochiKit.DOM.emitHTML(dom).join("");
};

MochiKit.DOM.emitHTML = function (dom, /* optional */lst) {
    

    if (typeof(lst) == 'undefined' || lst == null) {
        lst = [];
    }
    // queue is the call stack, we're doing this non-recursively
    var queue = [dom];
    var escapeHTML = MochiKit.DOM.escapeHTML;
    var attributeArray = MochiKit.DOM.attributeArray;
    while (queue.length) {
        dom = queue.pop();
        if (typeof(dom) == 'string') {
            lst.push(dom);
        } else if (dom.nodeType == 1) {
            // we're not using higher order stuff here
            // because safari has heisenbugs.. argh.
            //
            // I think it might have something to do with
            // garbage collection and function calls.
            lst.push('<' + dom.nodeName.toLowerCase());
            var attributes = [];
            var domAttr = attributeArray(dom);
            for (var i = 0; i < domAttr.length; i++) {
                var a = domAttr[i];
                attributes.push([
                    " ",
                    a.name,
                    '="',
                    escapeHTML(a.value),
                    '"'
                ]);
            }
            attributes.sort();
            for (var i = 0; i < attributes.length; i++) {
                var attrs = attributes[i];
                for (var j = 0; j < attrs.length; j++) {
                    lst.push(attrs[j]);
                }
            }
            if (dom.hasChildNodes()) {
                lst.push(">");
                // queue is the FILO call stack, so we put the close tag
                // on first
                queue.push("</" + dom.nodeName.toLowerCase() + ">");
                var cnodes = dom.childNodes;
                for (var i = cnodes.length - 1; i >= 0; i--) {
                    queue.push(cnodes[i]);
                }
            } else {
                lst.push('/>');
            }
        } else if (dom.nodeType == 3) {
            lst.push(escapeHTML(dom.nodeValue));
        }
    }
    return lst;
};

MochiKit.DOM.setDisplayForElement = function (display, element/*, ...*/) {
    
    var elements = MochiKit.Base.extend(null, arguments, 1);
    MochiKit.Iter.forEach(
        MochiKit.Base.filter(null, MochiKit.Base.map(getElement, elements)),
        function (element) {
            element.style.display = display;
        }
    );
};

MochiKit.DOM.scrapeText = function (node) {
    
    var rval = [];
    MochiKit.Base.nodeWalk(node, function (node) {
        var nodeValue = node.nodeValue;
        if (typeof(nodeValue) == 'string') {
            rval.push(nodeValue);
        }
        return node.childNodes;
    });
    return rval;
};


MochiKit.DOM.__new__ = function () {

    this.domConverters = new MochiKit.Base.AdapterRegistry(); 

    var __tmpElement = document.createElement("span");
    var attributeArray;
    if (__tmpElement.attributes.length > 0) {
        // for braindead browsers (IE) that insert extra junk
        var filter = MochiKit.Base.filter;
        attributeArray = function (node) {
            return filter(attributeArray.ignoreAttrFilter, node.attributes);
        }
        attributeArray.ignoreAttr = {};
        MochiKit.Iter.forEach(__tmpElement.attributes, function (a) {
            attributeArray.ignoreAttr[a.name] = a.value;
        });
        attributeArray.ignoreAttrFilter = function (a) {
            return (attributeArray.ignoreAttr[a.name] != a.value);
        }
        attributeArray.compliant = false;
    } else {
        attributeArray = function (node) {
            
            return node.attributes;
        }
        attributeArray.compliant = true;
    }
    this.attributeArray = attributeArray;


    // shorthand for createDOM syntax
    var createDOMFunc = this.createDOMFunc;
    this.TD = createDOMFunc("td");
    this.TR = createDOMFunc("tr");
    this.TBODY = createDOMFunc("tbody");
    this.TFOOT = createDOMFunc("tfoot");
    this.TABLE = createDOMFunc("table");
    this.TH = createDOMFunc("th");
    this.INPUT = createDOMFunc("input");
    this.SPAN = createDOMFunc("span");
    this.A = createDOMFunc("a");
    this.DIV = createDOMFunc("div");
    this.IMG = createDOMFunc("img");

    this._TRANSTABLE = {
        "<": "&lt;",
        ">": "&gt;",
        "&": "&amp;",
        "'": "&apos;",
        '"': "&quot;"
    };

    var partial = MochiKit.Base.partial;
    this.hideElement = partial(this.setDisplayForElement, "none");
    this.showElement = partial(this.setDisplayForElement, "block");

    this.$ = this.getElement;

    this.EXPORT_TAGS = {
        ":common": this.EXPORT,
        ":all": MochiKit.Base.concat(this.EXPORT, this.EXPORT_OK)
    };

    MochiKit.Base.nameFunctions(this);

};

MochiKit.DOM.__new__();

if ((typeof(JSAN) == 'undefined' && typeof(dojo) == 'undefined')
    || (typeof(MochiKit.__compat__) == 'boolean' && MochiKit.__compat__)) {
    (function (self) {
            var all = self.EXPORT_TAGS[":all"];
            for (var i = 0; i < all.length; i++) {
                this[all[i]] = self[all[i]];
            }
        })(MochiKit.DOM);
}



if (typeof(dojo) != 'undefined') {
    dojo.provide('MochiKit.Visual');
    dojo.require('MochiKit.Base');
    dojo.require('MochiKit.DOM');
}

if (typeof(JSAN) != 'undefined') {
    JSAN.use("MochiKit.Base", []);
    JSAN.use("MochiKit.DOM", []);
}

try {
    if (typeof(MochiKit.Base) == 'undefined' ||
        typeof(MochiKit.DOM) == 'undefined') {
        throw "";
    }
} catch (e) {
    throw "MochiKit.Visual depends on MochiKit.Base and MochiKit.DOM!";
}

if (typeof(MochiKit.Visual) == "undefined") {
    MochiKit.Visual = {};
}

MochiKit.Visual.NAME = "MochiKit.Visual";
MochiKit.Visual.VERSION = "0.60";

MochiKit.Visual.__repr__ = function () {
    return "[" + this.NAME + " " + this.VERSION + "]";
};

MochiKit.Visual.toString = function () {
    return this.__repr__();
};


MochiKit.Visual.clampColorComponent = function (v, scale) {
    v *= scale;
    if (v < 0) {
        return 0;
    } else if (v > scale) {
        return scale;
    } else {
        return v;
    }
};

MochiKit.Visual.Color = function (red, green, blue, alpha) {
    if (typeof(alpha) == 'undefined' || alpha == null) {
        alpha = 1.0;
    }
    this.rgb = {
        "r": red,
        "g": green,
        "b": blue,
        "a": alpha
    };
};


MochiKit.Visual.Color.prototype = {

    "__class__": MochiKit.Visual.Color,

    "colorWithAlpha": function (alpha) {
        var rgb = this.rgb;
        var m = MochiKit.Visual;
        return m.Color.fromRGB(rgb.r, rgb.g, rgb.b, alpha);
    },

    "colorWithHue": function (hue) {
        // get an HSL model, and set the new hue...
        var hsl = this.asHSL();
        hsl.h = hue;
        var m = MochiKit.Visual;
        // convert back to RGB...
        return m.Color.fromHSL(hsl);
    },

    "colorWithSaturation": function (saturation) {
        // get an HSL model, and set the new hue...
        var hsl = this.asHSL();
        hsl.s = saturation;
        var m = MochiKit.Visual;
        // convert back to RGB...
        return m.Color.fromHSL(hsl);
    },

    "colorWithLightness": function (lightness) {
        // get an HSL model, and set the new hue...
        var hsl = this.asHSL();
        hsl.l = lightness;
        var m = MochiKit.Visual;
        // convert back to RGB...
        return m.Color.fromHSL(hsl);
    },

    "darkerColorWithLevel": function (level) {
        var hsl  = this.asHSL();
        hsl.l = Math.max(hsl.l - level, 0);
        var m = MochiKit.Visual;
        return m.Color.fromHSL(hsl);
    },

    "lighterColorWithLevel": function (level) {
        var hsl  = this.asHSL();
        Math.min(hsl.l + level, 1);
        var m = MochiKit.Visual;
        return m.Color.fromHSL(hsl);
    },

    "blendedColor": function (other, /* optional */ fraction) {
        if (typeof(fraction) == 'undefined' || fraction == null) {
            fraction = 0.5;
        }
        var sf = 1.0 - fraction;
        var s = this.rgb;
        var d = other.rgb;
        var df = fraction;
        return MochiKit.Visual.Color.fromRGB(
            (s.r * sf) + (d.r * df),
            (s.g * sf) + (d.g * df),
            (s.b * sf) + (d.b * df),
            (s.a * sf) + (d.a * df)
        );
    },

    "compareRGB": function (other) {
        var a = this.asRGB();
        var b = other.asRGB();
        return MochiKit.Base.compare(
            [a.r, a.g, a.b, a.a],
            [b.r, b.g, b.b, b.a]
        );
    },
        
    "isLight": function () {
        return this.asHSL().b > 0.5;
    },

    "isDark": function () {
        return (!this.isLight());
    },

    "toHSLString": function () {
        var c = this.asHSL();
        var ccc = MochiKit.Visual.clampColorComponent;
        var rval = this._hslString;
        if (!rval) {
            var mid = (
                ccc(c.h, 360).toFixed(0)
                + "," + ccc(c.s, 100).toPrecision(4) + "%" 
                + "," + ccc(c.l, 100).toPrecision(4) + "%"
            );
            var a = c.a;
            if (a >= 1) {
                a = 1;
                rval = "hsl(" + mid + ")";
            } else {
                if (a <= 0) {
                    a = 0;
                }
                rval = "hsla(" + mid + "," + a + ")";
            }
            this._hslString = rval;
        }
        return rval;
    },

    "toRGBString": function () {
        var c = this.rgb;
        var ccc = MochiKit.Visual.clampColorComponent;
        var rval = this._rgbString;
        if (!rval) {
            var mid = (
                ccc(c.r, 255).toFixed(0)
                + "," + ccc(c.g, 255).toFixed(0)
                + "," + ccc(c.b, 255).toFixed(0)
            );
            if (c.a != 1) {
                rval = "rgba(" + mid + "," + c.a + ")";
            } else {
                rval = "rgb(" + mid + ")";
            }
            this._rgbString = rval;
        }
        return rval;
    },

    "asRGB": function () {
        return MochiKit.Base.clone(this.rgb);
    },

    "toHexString": function () {
        var m = MochiKit.Visual;
        var c = this.rgb;
        var ccc = MochiKit.Visual.clampColorComponent;
        var rval = this._hexString;
        if (!rval) {
            rval = ("#" + 
                m.toColorPart(ccc(c.r, 255)) +
                m.toColorPart(ccc(c.g, 255)) +
                m.toColorPart(ccc(c.b, 255))
            );
            this._hexString = rval;
        }
        return rval;
    },

    "asHSL": function () {
        var hsl = this.hsl;
        var c = this.rgb;
        if (typeof(hsl) == 'undefined' || hsl == null) {
            hsl = MochiKit.Visual.rgbToHSL(this.rgb);
            this.hsl = hsl;
        }
        return MochiKit.Base.clone(hsl);
    },

    "toString": function () {
        return this.toRGBString();
    },

    "repr": function () {
        var c = this.rgb;
        var col = [c.r, c.g, c.b, c.a];
        return this.__class__.NAME + "(" + col.join(", ") + ")";
    }

};

MochiKit.Visual.Color.fromRGB = function (red, green, blue, alpha) {
    // designated initializer
    var Color = MochiKit.Visual.Color;
    if (arguments.length == 1) {
        var rgb = red;
        red = rgb.r;
        green = rgb.g;
        blue = rgb.b;
        alpha = rgb.a;
    }
    return new Color(red, green, blue, alpha);
};

MochiKit.Visual.Color.fromHSL = function (hue, saturation, lightness, alpha) {
    var m = MochiKit.Visual;
    return m.Color.fromRGB(m.hslToRGB.apply(m, arguments));
};

MochiKit.Visual.Color.fromName = function (name) {
    var Color = MochiKit.Visual.Color;
    var htmlColor = Color._namedColors[name.toLowerCase()];
    if (typeof(htmlColor) == 'string') {
        return Color.fromHexString(htmlColor);
    } else if (name == "transparent") {
        return Color.transparentColor();
    }
    return null;
};

MochiKit.Visual.Color.fromString = function (colorString) {
    // TODO: support RGBA
    var self = MochiKit.Visual.Color;
    var three = colorString.substr(0, 3);
    if (three == "rgb") {
        return self.fromRGBString(colorString);
    } else if (three == "hsl") {
        return self.fromHSLString(colorString);
    } else if (colorString.charAt(0) == "#") {
        return self.fromHexString(colorString);
    }
    return self.fromName(colorString);
};


MochiKit.Visual.Color.fromHexString = function (hexCode) {
    if (hexCode.charAt(0) == '#') {
        hexCode = hexCode.substring(1);
    }
    var components = [];
    if (hexCode.length == 3) {
        for (var i = 0; i < 3; i++) {
            var hex = hexCode.substr(i, 1);
            components.push(parseInt(hex + hex, 16) / 255.0);
        }
    } else {
        for (var i = 0; i < 6; i += 2) {
            var hex = hexCode.substr(i, 2);
            components.push(parseInt(hex, 16) / 255.0);
        }
    }
    var Color = MochiKit.Visual.Color;
    return Color.fromRGB.apply(Color, components);
};
        

MochiKit.Visual.Color._fromColorString = function (pre, method, scales, colorCode) {
    // parses either HSL or RGB
    if (colorCode.indexOf(pre) == 0) {
        colorCode = colorCode.substring(colorCode.indexOf("(", 3) + 1, colorCode.length - 1);
    } 
    var colorChunks = colorCode.split(/\s*,\s*/);
    var colorFloats = [];
    for (var i = 0; i < colorChunks.length; i++) {
        var c = colorChunks[i];
        var val;
        var three = c.substring(c.length - 3);
        if (c.charAt(c.length - 1) == '%') {
            val = 0.01 * parseFloat(c.substring(0, c.length - 1));
        } else if (three == "deg") {
            val = parseFloat(c) / 360.0;
        } else if (three == "rad") {
            val = parseFloat(c) / (Math.PI * 2);
        } else {
            val = scales[i] * parseFloat(c);
        }
        colorFloats.push(val);
    }
    return this[method].apply(this, colorFloats);
};
    
MochiKit.Visual.Color.fromBackground = function (elem) {
    var m = MochiKit.Visual;
    while (elem) {
        var actualColor = m.getElementsComputedStyle(
            MochiKit.DOM.getElement(elem),
            "backgroundColor",
            "background-color"
        );
        if (!actualColor) {
            break;
        }
        var color = m.Color.fromString(actualColor);
        if (!color) {
            break;
        }
        if (color.asRGB().a > 0) {
            return color;
        }
        elem = elem.parent;
    }
    return m.Color.whiteColor();
};

MochiKit.Visual._hslValue = function (n1, n2, hue) {
    if (hue > 6.0) {
        hue -= 6.0;
    } else if (hue < 0.0) {
        hue += 6.0;
    }
    var val;
    if (hue < 1.0) {
        val = n1 + (n2 - n1) * hue;
    } else if (hue < 3.0) {
        val = n2;
    } else if (hue < 4.0) {
        val = n1 + (n2 - n1) * (4.0 - hue);
    } else {
        val = n1;
    }
    return val;
};
    
MochiKit.Visual.hslToRGB = function (hue, saturation, lightness, alpha) {
    if (arguments.length == 1) {
        var hsl = hue;
        hue = hsl.h;
        saturation = hsl.s;
        lightness = hsl.l;
        alpha = hsl.a;
    }
    var red;
    var green;
    var blue;
    if (saturation == 0) {
        red = lightness;
        green = lightness;
        blue = lightness;
    } else {
        var m2;
        if (lightness <= 0.5) {
            m2 = lightness * (1.0 + saturation);
        } else {
            m2 = lightness + saturation - (lightness * saturation);
        }
        var m1 = (2.0 * lightness) - m2;
        var f = MochiKit.Visual._hslValue;
        var h6 = hue * 6.0;
        red = f(m1, m2, h6 + 2);
        green = f(m1, m2, h6);
        blue = f(m1, m2, h6 - 2);
    }
    return {
        "r": red,
        "g": green,
        "b": blue,
        "a": alpha

    };
};

MochiKit.Visual.rgbToHSL = function (red, green, blue, alpha) {
    if (arguments.length == 1) {
        var rgb = red;
        red = rgb.r;
        green = rgb.g;
        blue = rgb.b;
        alpha = rgb.a;
    }
    var max = Math.max(red, Math.max(green, blue));
    var min = Math.min(red, Math.min(green, blue));
    var hue;
    var saturation;
    var lightness = (max + min) / 2.0;
    var delta = max - min;
    if (delta == 0) {
        hue = 0;
        saturation = 0;
    } else {
        if (lightness <= 0.5) {
            saturation = delta / (max + min);
        } else {
            saturation = delta / (2 - max - min);
        }
        if (delta == 0.0) {
            delta = 1.0;
        }
        if (red == max) {
            hue = (green - blue) / delta;
        } else if (green == max) {
            hue = 2 + ((blue - red) / delta);
        } else {
            hue = 4 + ((red - green) / delta);
        }
        hue /= 6;
        if (hue < 0) {
            hue += 1;
        }
        if (hue > 1) {
            hue -= 1;
        }
        
    }
    return {
        "h": hue,
        "s": saturation,
        "l": lightness,
        "a": alpha
    };
};

MochiKit.Visual.toColorPart = function (num) {
    var digits = Math.round(num).toString(16);
    if (num < 16) {
        return '0' + digits;
    }
    return digits;
};

MochiKit.Visual.roundElement = function (e, options) {
    new MochiKit.Visual._RoundCorners(e, options);
};

/*
    The following section is partially adapted from
    Rico <http://www.openrico.org>
*/

MochiKit.Visual.getElementsComputedStyle = function (htmlElement, cssProperty, mozillaEquivalentCSS) {
    if (arguments.length == 2) {
        mozillaEquivalentCSS = cssProperty;
    }
    var el = MochiKit.DOM.getElement(htmlElement);
    if (el.currentStyle) {
        return el.currentStyle[cssProperty];
    } else {
        var style = document.defaultView.getComputedStyle(el, null);
        return style.getPropertyValue(mozillaEquivalentCSS);
    }
};

MochiKit.Visual._RoundCorners = function (e, options) {
    var e = MochiKit.DOM.getElement(e);
    this._setOptions(options);

    var color = this.options.color;
    var m = MochiKit.Visual;
    if (this.options.color == "fromElement") {
        color = m.Color.fromBackground(e);
    } else if (!(color instanceof m.Color)) {
        color = m.Color.fromString(color);
    }
    this.isTransparent = (color.asRGB().a <= 0);

    var bgColor = this.options.bgColor;
    if (this.options.bgColor == "fromParent") {
        bgColor = m.Color.fromBackground(e.offsetParent);
    } else if (!(bgColor instanceof m.Color)) {
        bgColor = m.Color.fromString(bgColor);
    }

    this._roundCornersImpl(e, color, bgColor);
};

MochiKit.Visual._RoundCorners.prototype = {
    "_roundCornersImpl": function (e, color, bgColor) {
        if (this.options.border) {
            this._renderBorder(e, bgColor);
        }
        if (this._isTopRounded()) {
            this._roundTopCorners(e, color, bgColor);
        }
        if (this._isBottomRounded()) {
            this._roundBottomCorners(e, color, bgColor);
        }
    },

    "_renderBorder": function (el, bgColor) {
        var borderValue = "1px solid " + this._borderColor(bgColor);
        var borderL = "border-left: "  + borderValue;
        var borderR = "border-right: " + borderValue;
        var style   = "style='" + borderL + ";" + borderR +  "'";
        el.innerHTML = "<div " + style + ">" + el.innerHTML + "</div>";
    },

    "_roundTopCorners": function (el, color, bgColor) {
        var corner = this._createCorner(bgColor);
        for (var i = 0; i < this.options.numSlices; i++) {
            corner.appendChild(
                this._createCornerSlice(color, bgColor, i, "top")
            );
        }
        el.style.paddingTop = 0;
        el.insertBefore(corner, el.firstChild);
    },

    "_roundBottomCorners": function (el, color, bgColor) {
        var corner = this._createCorner(bgColor);
        for (var i = (this.options.numSlices - 1); i >= 0; i--) {
            corner.appendChild(
                this._createCornerSlice(color, bgColor, i, "bottom")
            );
        }
        el.style.paddingBottom = 0;
        el.appendChild(corner);
    },

    "_createCorner": function (bgColor) {
        var corner = document.createElement("div");
        corner.style.backgroundColor = bgColor.toString();
        return corner;
    },

    "_createCornerSlice": function (color, bgColor, n, position) {
        var slice = document.createElement("span");

        var inStyle = slice.style;
        inStyle.backgroundColor = color.toString();
        inStyle.display = "block";
        inStyle.height = "1px";
        inStyle.overflow = "hidden";
        inStyle.fontSize = "1px";

        var borderColor = this._borderColor(color, bgColor);
        if (this.options.border && n == 0) {
            inStyle.borderTopStyle = "solid";
            inStyle.borderTopWidth = "1px";
            inStyle.borderLeftWidth = "0px";
            inStyle.borderRightWidth = "0px";
            inStyle.borderBottomWidth = "0px";
            // assumes css compliant box model
            inStyle.height = "0px";
            inStyle.borderColor = borderColor.toString();
        } else if (borderColor) {
            inStyle.borderColor = borderColor.toString();
            inStyle.borderStyle = "solid";
            inStyle.borderWidth = "0px 1px";
        }

        if (!this.options.compact && (n == (this.options.numSlices - 1))) {
            inStyle.height = "2px";
        }

        this._setMargin(slice, n, position);
        this._setBorder(slice, n, position);

        return slice;
    },

    "_setOptions": function (options) {
        this.options = {
            corners : "all",
            color   : "fromElement",
            bgColor : "fromParent",
            blend   : true,
            border  : false,
            compact : false
        };
        MochiKit.Base.update(this.options, options);

        this.options.numSlices = (this.options.compact ? 2 : 4);
    },

    "_whichSideTop": function () {
        var corners = this.options.corners;
        if (this._hasString(corners, "all", "top")) {
            return "";
        }

        var has_tl = (corners.indexOf("tl") != -1);
        var has_tr = (corners.indexOf("tr") != -1);
        if (has_tl && has_tr) {
            return "";
        }
        if (has_tl) {
            return "left";
        }
        if (has_tr) {
            return "right";
        }
        return "";
    },

    "_whichSideBottom": function () {
        var corners = this.options.corners;
        if (this._hasString(corners, "all", "bottom")) {
            return "";
        }

        var has_bl = (corners.indexOf('bl') != -1);
        var has_br = (corners.indexOf('br') != -1);
        if (has_bl && has_br) {
            return "";
        }
        if (has_bl) {
            return "left";
        }
        if (has_br) {
            return "right";
        }
        return "";
    },

    "_borderColor": function (color, bgColor) {
        if (color == "transparent") {
            return bgColor;
        } else if (this.options.border) {
            return this.options.border;
        } else if (this.options.blend) {
            return bgColor.blendedColor(color);
        }
        return "";
    },


    "_setMargin": function (el, n, corners) {
        var marginSize = this._marginSize(n) + "px";
        var whichSide = (
            corners == "top" ? this._whichSideTop() : this._whichSideBottom()
        );
        var style = el.style;

        if (whichSide == "left") {
            style.marginLeft = marginSize;
            style.marginRight = "0px";
        } else if (whichSide == "right") {
            style.marginRight = marginSize;
            style.marginLeft  = "0px";
        } else {
            style.marginLeft = marginSize;
            style.marginRight = marginSize;
        }
    },

    "_setBorder": function (el, n, corners) {
        var borderSize = this._borderSize(n) + "px";
        var whichSide = (
            corners == "top" ? this._whichSideTop() : this._whichSideBottom()
        );

        var style = el.style;
        if (whichSide == "left") {
            style.borderLeftWidth = borderSize;
            style.borderRightWidth = "0px";
        } else if (whichSide == "right") {
            style.borderRightWidth = borderSize;
            style.borderLeftWidth  = "0px";
        } else {
            style.borderLeftWidth = borderSize;
            style.borderRightWidth = borderSize;
        }
    },

    "_marginSize": function (n) {
        if (this.isTransparent) {
            return 0;
        }

        var o = this.options;
        if (o.compact && o.blend) {
            var smBlendedMarginSizes = [1, 0];
            return smBlendedMarginSizes[n];
        } else if (o.compact) {
            var compactMarginSizes = [2, 1];
            return compactMarginSizes[n];
        } else if (o.blend) {
            var blendedMarginSizes = [3, 2, 1, 0];
            return blendedMarginSizes[n];
        } else {
            var marginSizes = [5, 3, 2, 1];
            return marginSizes[n];
        }
    },

    "_borderSize": function (n) {
        var o = this.options;
        var borderSizes;
        if (o.compact && (o.blend || this.isTransparent)) {
            return 1;
        } else if (o.compact) {
            borderSizes = [1, 0];
        } else if (o.blend) {
            borderSizes = [2, 1, 1, 1];
        } else if (o.border) {
            borderSizes = [0, 2, 0, 0];
        } else if (this.isTransparent) {
            borderSizes = [5, 3, 2, 1];
        } else {
            return 0;
        }
        return borderSizes[n];
    },

    "_hasString": function (str) {
        for (var i = 1; i< arguments.length; i++) {
            if (str.indexOf(arguments[i]) != -1) {
                return true;
            }
        }
        return false;
    },

    "_isTopRounded": function () {
        return this._hasString(this.options.corners,
            "all", "top", "tl", "tr"
        );
    },

    "_isBottomRounded": function () {
        return this._hasString(this.options.corners,
            "all", "bottom", "bl", "br"
        );
    },

    "_hasSingleTextChild": function (el) {
        return (el.childNodes.length == 1 && el.childNodes[0].nodeType == 3);
    }
};

MochiKit.Visual.roundClass = function (tagName, className, options) {
    var elements = MochiKit.DOM.getElementsByTagAndClassName(
        tagName, className
    );
    for (var i = 0; i < elements.length; i++) {
        roundElement(elements[i], options);
    }
};

/* end of Rico adaptation */

MochiKit.Visual.__new__  = function () {
    var bind = MochiKit.Base.bind;
    var map = MochiKit.Base.map;
    var concat = MochiKit.Base.concat;
    this.Color.fromRGBString = bind(
        this.Color._fromColorString, this.Color, "rgb", "fromRGB",
        [1.0/255.0, 1.0/255.0, 1.0/255.0, 1]
    );
    this.Color.fromHSLString = bind(
        this.Color._fromColorString, this.Color, "hsl", "fromHSL",
        [1.0/360.0, 0.01, 0.01, 1]
    );
    
    var third = 1.0 / 3.0;
    var colors = {
        // NSColor colors plus transparent
        black: [0, 0, 0],
        blue: [0, 0, 1],
        brown: [0.6, 0.4, 0.2],
        cyan: [0, 1, 1],
        darkGray: [third, third, third],
        gray: [0.5, 0.5, 0.5],
        green: [0, 1, 0],
        lightGray: [2 * third, 2 * third, 2 * third],
        magenta: [1, 0, 1],
        orange: [1, 0.5, 0],
        purple: [0.5, 0, 0.5],
        red: [1, 0, 0],
        transparent: [0, 0, 0, 0],
        white: [1, 1, 1],
        yellow: [1, 1, 0]
    };

    var makeColor = function (name, r, g, b, a) {
        var rval = this.fromRGB(r, g, b, a);
        this[name] = function () { return rval; };
        return rval;
    }

    for (var k in colors) {
        var name = k + "Color";
        var bindArgs = concat(
            [makeColor, this.Color, name],
            colors[k]
        );
        this.Color[name] = bind.apply(null, bindArgs);
    }

    var isColor = function () {
        for (var i = 0; i < arguments.length; i++) {
            if (!(arguments[i] instanceof Color)) {
                return false;
            }
        }
        return true;
    }

    var compareColor = function (a, b) {
        return a.compareRGB(b);
    }

    MochiKit.Base.registerComparator(this.Color.NAME, isColor, compareColor);
        
    this.EXPORT_TAGS = {
        ":common": this.EXPORT,
        ":all": MochiKit.Base.concat(this.EXPORT, this.EXPORT_OK)
    };

    MochiKit.Base.nameFunctions(this);

};

MochiKit.Visual.EXPORT = [
    "Color",
    "roundElement",
    "roundClass"
];

MochiKit.Visual.EXPORT_OK = [
    "clampColorComponent",
    "rgbToHSL",
    "hslToRGB",
    "toColorPart"
];

MochiKit.Visual.__new__();

if ((typeof(JSAN) == 'undefined' && typeof(dojo) == 'undefined')
    || (typeof(MochiKit.__compat__) == 'boolean' && MochiKit.__compat__)) {
    (function (self) {
            var all = self.EXPORT_TAGS[":all"];
            for (var i = 0; i < all.length; i++) {
                this[all[i]] = self[all[i]];
            }
        })(MochiKit.Visual);
}

// Full table of css3 X11 colors <http://www.w3.org/TR/css3-color/#X11COLORS>
MochiKit.Visual.Color.namedColors = function () {
    return MochiKit.Base.clone(MochiKit.Visual.Color._namedColors);
}

MochiKit.Visual.Color._namedColors = {
    aliceblue: "#f0f8ff",
    antiquewhite: "#faebd7",
    aqua: "#00ffff",
    aquamarine: "#7fffd4",
    azure: "#f0ffff",
    beige: "#f5f5dc",
    bisque: "#ffe4c4",
    black: "#000000",
    blanchedalmond: "#ffebcd",
    blue: "#0000ff",
    blueviolet: "#8a2be2",
    brown: "#a52a2a",
    burlywood: "#deb887",
    cadetblue: "#5f9ea0",
    chartreuse: "#7fff00",
    chocolate: "#d2691e",
    coral: "#ff7f50",
    cornflowerblue: "#6495ed",
    cornsilk: "#fff8dc",
    crimson: "#dc143c",
    cyan: "#00ffff",
    darkblue: "#00008b",
    darkcyan: "#008b8b",
    darkgoldenrod: "#b8860b",
    darkgray: "#a9a9a9",
    darkgreen: "#006400",
    darkgrey: "#a9a9a9",
    darkkhaki: "#bdb76b",
    darkmagenta: "#8b008b",
    darkolivegreen: "#556b2f",
    darkorange: "#ff8c00",
    darkorchid: "#9932cc",
    darkred: "#8b0000",
    darksalmon: "#e9967a",
    darkseagreen: "#8fbc8f",
    darkslateblue: "#483d8b",
    darkslategray: "#2f4f4f",
    darkslategrey: "#2f4f4f",
    darkturquoise: "#00ced1",
    darkviolet: "#9400d3",
    deeppink: "#ff1493",
    deepskyblue: "#00bfff",
    dimgray: "#696969",
    dimgrey: "#696969",
    dodgerblue: "#1e90ff",
    firebrick: "#b22222",
    floralwhite: "#fffaf0",
    forestgreen: "#228b22",
    fuchsia: "#ff00ff",
    gainsboro: "#dcdcdc",
    ghostwhite: "#f8f8ff",
    gold: "#ffd700",
    goldenrod: "#daa520",
    gray: "#808080",
    green: "#008000",
    greenyellow: "#adff2f",
    grey: "#808080",
    honeydew: "#f0fff0",
    hotpink: "#ff69b4",
    indianred: "#cd5c5c",
    indigo: "#4b0082",
    ivory: "#fffff0",
    khaki: "#f0e68c",
    lavender: "#e6e6fa",
    lavenderblush: "#fff0f5",
    lawngreen: "#7cfc00",
    lemonchiffon: "#fffacd",
    lightblue: "#add8e6",
    lightcoral: "#f08080",
    lightcyan: "#e0ffff",
    lightgoldenrodyellow: "#fafad2",
    lightgray: "#d3d3d3",
    lightgreen: "#90ee90",
    lightgrey: "#d3d3d3",
    lightpink: "#ffb6c1",
    lightsalmon: "#ffa07a",
    lightseagreen: "#20b2aa",
    lightskyblue: "#87cefa",
    lightslategray: "#778899",
    lightslategrey: "#778899",
    lightsteelblue: "#b0c4de",
    lightyellow: "#ffffe0",
    lime: "#00ff00",
    limegreen: "#32cd32",
    linen: "#faf0e6",
    magenta: "#ff00ff",
    maroon: "#800000",
    mediumaquamarine: "#66cdaa",
    mediumblue: "#0000cd",
    mediumorchid: "#ba55d3",
    mediumpurple: "#9370db",
    mediumseagreen: "#3cb371",
    mediumslateblue: "#7b68ee",
    mediumspringgreen: "#00fa9a",
    mediumturquoise: "#48d1cc",
    mediumvioletred: "#c71585",
    midnightblue: "#191970",
    mintcream: "#f5fffa",
    mistyrose: "#ffe4e1",
    moccasin: "#ffe4b5",
    navajowhite: "#ffdead",
    navy: "#000080",
    oldlace: "#fdf5e6",
    olive: "#808000",
    olivedrab: "#6b8e23",
    orange: "#ffa500",
    orangered: "#ff4500",
    orchid: "#da70d6",
    palegoldenrod: "#eee8aa",
    palegreen: "#98fb98",
    paleturquoise: "#afeeee",
    palevioletred: "#db7093",
    papayawhip: "#ffefd5",
    peachpuff: "#ffdab9",
    peru: "#cd853f",
    pink: "#ffc0cb",
    plum: "#dda0dd",
    powderblue: "#b0e0e6",
    purple: "#800080",
    red: "#ff0000",
    rosybrown: "#bc8f8f",
    royalblue: "#4169e1",
    saddlebrown: "#8b4513",
    salmon: "#fa8072",
    sandybrown: "#f4a460",
    seagreen: "#2e8b57",
    seashell: "#fff5ee",
    sienna: "#a0522d",
    silver: "#c0c0c0",
    skyblue: "#87ceeb",
    slateblue: "#6a5acd",
    slategray: "#708090",
    slategrey: "#708090",
    snow: "#fffafa",
    springgreen: "#00ff7f",
    steelblue: "#4682b4",
    tan: "#d2b48c",
    teal: "#008080",
    thistle: "#d8bfd8",
    tomato: "#ff6347",
    turquoise: "#40e0d0",
    violet: "#ee82ee",
    wheat: "#f5deb3",
    white: "#ffffff",
    whitesmoke: "#f5f5f5",
    yellow: "#ffff00",
    yellowgreen: "#9acd32"
};



if (typeof(MochiKit) == 'undefined') {
    MochiKit = {};
}

if (typeof(MochiKit.MochiKit) == 'undefined') {
    MochiKit.MochiKit = {};
}

MochiKit.MochiKit.NAME = "MochiKit.MochiKit";
MochiKit.MochiKit.VERSION = "0.60";
MochiKit.MochiKit.__repr__ = function () {
    return "[" + this.NAME + " " + this.VERSION + "]";
};

MochiKit.MochiKit.toString = function () {
    return this.__repr__();
};

MochiKit.MochiKit.SUBMODULES = [
    "Base",
    "Iter",
    "Logging",
    "DateTime",
    "Format",
    "Async",
    "DOM",
    "Visual"
];

if (typeof(JSAN) != 'undefined' || typeof(dojo) != 'undefined') {
    if (typeof(dojo) != 'undefined') {
        dojo.provides('MochiKit.MochiKit');
        dojo.require("MochiKit.*");
    }
    if (typeof(JSAN) != 'undefined') {
        // hopefully this makes it easier for static analysis?
        JSAN.use("MochiKit.Base", []);
        JSAN.use("MochiKit.Iter", []);
        JSAN.use("MochiKit.Logging", []);
        JSAN.use("MochiKit.DateTime", []);
        JSAN.use("MochiKit.Format", []);
        JSAN.use("MochiKit.Async", []);
        JSAN.use("MochiKit.DOM", []);
        JSAN.use("MochiKit.Visual", []);
    }
    (function () {
        var extend = MochiKit.Base.extend;
        var self = MochiKit.MochiKit;
        var modules = self.SUBMODULES;
        var EXPORT = [];
        var EXPORT_OK = [];
        var EXPORT_TAGS = {};
        for (var i = 0; i < modules.length; i++) {
            var m = MochiKit[modules[i]];
            extend(EXPORT, m.EXPORT);
            extend(EXPORT_OK, m.EXPORT_OK);
            for (var k in m.EXPORT_TAGS) {
                EXPORT_TAGS[k] = extend(EXPORT_TAGS[k], m.EXPORT_TAGS[k]);
            }
            var all = m.EXPORT_TAGS[":all"];
            if (!all) {
                all = extend(null, m.EXPORT, m.EXPORT_OK);
            }
            for (var i = 0; i < all.length; i++) {
                var k = all[i];
                self[k] = m[k];
            }
        }
        self.EXPORT = EXPORT;
        self.EXPORT_OK = EXPORT_OK;
        self.EXPORT_TAGS = EXPORT_TAGS;
    }());
    
} else {
    if (typeof(MochiKit.__compat__) == 'undefined') {
        MochiKit.__compat__ = true;
    }
    (function () {
        var scripts = document.getElementsByTagName("script");
        var base = null;
        var baseElem = null;
        var allScripts = {};
        for (var i = 0; i < scripts.length; i++) {
            src = scripts[i].src;
            allScripts[src] = true;
            if (src.match(/MochiKit.js$/)) {
                base = src.substring(0, src.lastIndexOf('MochiKit.js'));
                baseElem = scripts[i];
            }
        }
        if (base == null) {
            return;
        }
        var modules = MochiKit.MochiKit.SUBMODULES;
        modules.unshift("Compat");
        for (var i = 0; i < modules.length; i++) {
            if (MochiKit[modules[i]]) {
                continue;
            }
            var uri = base + modules[i] + '.js';
            if (uri in allScripts) {
                continue;
            }
            if (false) {
                // doesn't work in Safari
                var s = document.createElement('script');
                s.setAttribute("src", uri);
                s.setAttribute("type", "text/javascript");
                baseElem.parentNode.appendChild(s);
            } else {
                var tag = '<' + 'script src="' + uri + '" type="text/javascript"' + '>' + '<' + '/script' + '>';
                document.write(tag);
            }
        }
    })();
}

